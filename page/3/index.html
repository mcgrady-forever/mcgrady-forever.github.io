<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta property="og:type" content="website">
<meta property="og:title" content="HeLei Blog">
<meta property="og:url" content="http://hlei.io/page/3/index.html">
<meta property="og:site_name" content="HeLei Blog">
<meta property="og:description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HeLei Blog">
<meta name="twitter:description" content="c/c++/python | redis | recommend algorithm | search engine">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hlei.io/page/3/"/>





  <title> HeLei Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HeLei Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">不要因为走得太远，就忘记为什么而出发</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/12/os-memory-layout/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/12/os-memory-layout/" itemprop="url">
                  内存布局
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T17:25:18+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程的内存空间布局"><a href="#进程的内存空间布局" class="headerlink" title="进程的内存空间布局"></a>进程的内存空间布局</h1><p>进程的内存布局在结构上是有规律的，具体来说对于 linux 系统上的进程，其内存空间一般可以粗略地分为以下几大段【1】，从高内存到低内存排列：</p>
<ol>
<li><p>内核态内存空间，其大小一般比较固定（可以编译时调整），但 32 位系统和 64 位系统的值不一样。</p>
</li>
<li><p>用户态的堆栈，大小不固定，可以用 ulimit -s 进行调整，默认一般为 8M，从高地址向低地址增长。</p>
</li>
<li><p>mmap 区域，进程茫茫内存空间里的主要部分，既可以从高地址到低地址延伸(所谓 flexible layout)，也可以从低到高延伸(所谓 legacy layout)，看进程具体情况【2】【3】。</p>
</li>
<li><p>brk 区域，紧邻数据段(甚至贴着)，从低位向高位伸展，但它的大小主要取决于 mmap 如何增长，一般来说，即使是 32 位的进程以传统方式延伸，也有差不多 1 GB 的空间（准确地说是 TASK_SIZE/3 - 代码段数据段，参看 arch/x86/include/asm/processor.h 里的定义)【4】</p>
</li>
<li><p>数据段，主要是进程里初始化和未初始化的全局数据总和，当然还有编译器生成一些辅助数据结构等等)，大小取决于具体进程，其位置紧贴着代码段。</p>
</li>
<li><p>代码段，主要是进程的指令，包括用户代码和编译器生成的辅助代码，其大小取决于具体程序，但起始位置根据 32 位还是 64 位一般固定(-fPIC, -fPIE等除外【5】)。<br><img src="/2018/03/12/os-memory-layout/os_memory_layout.png" alt="img01"></p>
</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>【1】<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Growing_the_Oracle_SGA_to_2.7_GB_in_x86_Red_Hat_Enterprise_Linux_2.1_Without_VLM-Linux_Memory_Layout.html" target="_blank" rel="external">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Growing_the_Oracle_SGA_to_2.7_GB_in_x86_Red_Hat_Enterprise_Linux_2.1_Without_VLM-Linux_Memory_Layout.html</a></li>
<li>【2】understanding the linux kernel, page 819, flexible memory region layout: <a href="https://books.google.com.hk/books?id=h0lltXyJ8aIC&amp;pg=PT925&amp;lpg=PT925&amp;dq=linux+flexible+memory&amp;source=bl&amp;ots=gO7rIYb8HR&amp;sig=pirB5pswdHFHSljy57EksxS3ABw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjpkfa-2_rRAhVGFJQKHcETDSUQ6AEITDAH#v=onepage&amp;q=linux%20flexible%20memory&amp;f=false" target="_blank" rel="external">https://books.google.com.hk/books?id=h0lltXyJ8aIC&amp;pg=PT925&amp;lpg=PT925&amp;dq=linux+flexible+memory&amp;source=bl&amp;ots=gO7rIYb8HR&amp;sig=pirB5pswdHFHSljy57EksxS3ABw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjpkfa-2_rRAhVGFJQKHcETDSUQ6AEITDAH#v=onepage&amp;q=linux%20flexible%20memory&amp;f=false</a></li>
<li>【3】<a href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4" target="_blank" rel="external">https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4</a></li>
<li>【4】<a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h#L770" target="_blank" rel="external">http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h#L770</a></li>
<li>【5】<a href="https://access.redhat.com/blogs/766093/posts/1975793" target="_blank" rel="external">https://access.redhat.com/blogs/766093/posts/1975793</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/12/c-compile/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/12/c-compile/" itemprop="url">
                  程序的编译与链接
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T16:50:34+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="编译过程预览"><a href="#编译过程预览" class="headerlink" title="编译过程预览"></a>编译过程预览</h1><p><img src="/2018/03/12/c-compile/c_compile01.png" alt="img01"></p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><ul>
<li>预处理(Prepressing) :   -E 表示只进行预处理, 即 : gcc –E hello.c –o hello.i<ul>
<li>展开所有 #define 定义的宏</li>
<li>处理所有条件预编译指令,如 #if, #ifdef</li>
<li>递归的将 #include 的文件插入到该预编译文件中</li>
<li>删除各类注释</li>
<li>添加行和文件标识,如  #2 “hello.c” 2 ,用于调试或编译出错报警</li>
<li>保留所有的 #pragma 编译指令,编译器要使用</li>
</ul>
</li>
<li>对于C++ 来说,预处理后的文件扩展名是 .ii</li>
</ul>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ul>
<li>编译(Compilation):  gcc –S hello.i –o hello.s<br>编译过程就是把预处理完的文件进行一系列词法分析,语法分析,语义分析及优化后生成相应的汇编代码文件.</li>
<li>现在的gcc 把预处理和编译两个步骤合成一个步骤,C语言使用一个叫做 cc1 的程序来完成,C++则是 cc1plus ,位于 /usr/libexec/gcc/x86_64-redhat-linux/4.1.2/</li>
<li>gcc 实际上是这些后台程序的包装,它会根据参数要求去调用 cc1(cclplus), 汇编器 as 和链接器 ld</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li>链接(Linking):解决一个程序被分割成多个模块后,模块间最后如何组合成一个单一程序的问题.</li>
<li>链接的主要任务是把各个模块之间相互引用的部分处理好,使各个模块之间能正确的衔接.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/12/linux-command/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/12/linux-command/" itemprop="url">
                  linux-command
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T10:49:48+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="查看某个进程的线程数量"><a href="#查看某个进程的线程数量" class="headerlink" title="查看某个进程的线程数量"></a>查看某个进程的线程数量</h1><ol>
<li>根据进程号进行查询：<ul>
<li><h1 id="pstree-p-进程号"><a href="#pstree-p-进程号" class="headerlink" title="pstree -p 进程号"></a>pstree -p 进程号</h1></li>
</ul>
</li>
</ol>
<p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~/myspace/test/network$ pstree -p 5629</div><div class="line">test05(5629)─┬─&#123;test05&#125;(5630)</div><div class="line">             ├─&#123;test05&#125;(5631)</div><div class="line">             ├─&#123;test05&#125;(5632)</div><div class="line">             └─&#123;test05&#125;(5633)</div></pre></td></tr></table></figure></p>
<ul>
<li><h1 id="top-Hp-进程号"><a href="#top-Hp-进程号" class="headerlink" title="top -Hp 进程号"></a>top -Hp 进程号</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND </div><div class="line">  5629 chris     20   0 47680 1420 1188 S    0  0.1   0:00.02 test05                                          </div><div class="line"> 5630 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05                                          </div><div class="line"> 5631 chris     20   0 47680 1420 1188 S    0  0.1   0:00.03 test05                                          </div><div class="line"> 5632 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05                                          </div><div class="line"> 5633 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05</div><div class="line"> ``` </div><div class="line"></div><div class="line">2. 根据进程名字进行查询：</div></pre></td></tr></table></figure>
<h1 id="pstree-p-ps-e-grep-test05-awk-39-print-1-39"><a href="#pstree-p-ps-e-grep-test05-awk-39-print-1-39" class="headerlink" title="pstree -p ps -e | grep test05 | awk &#39;{print $1}&#39;"></a>pstree -p <code>ps -e | grep test05 | awk &#39;{print $1}&#39;</code></h1><h1 id="pstree-p-ps-e-grep-test05-awk-39-print-1-39-wc-l"><a href="#pstree-p-ps-e-grep-test05-awk-39-print-1-39-wc-l" class="headerlink" title="pstree -p ps -e | grep test05 | awk &#39;{print $1}&#39; | wc -l"></a>pstree -p <code>ps -e | grep test05 | awk &#39;{print $1}&#39;</code> | wc -l</h1><p>```<br>执行效果和上面的命令是一样的</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/07/distributed-system-consistent-hashing/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/07/distributed-system-consistent-hashing/" itemprop="url">
                  一致性哈希算法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-07T17:02:49+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一些场景希望同样的请求尽量落到一台机器上，比如访问缓存集群时，我们往往希望同一种请求能落到同一个后端上，以充分利用其上已有的缓存，不同的机器承载不同的稳定working set。而不是随机地散落到所有机器上，那样的话会迫使所有机器缓存所有的内容，最终由于存不下形成颠簸而表现糟糕。 我们都知道hash能满足这个要求，比如当有n台服务器时，输入x总是会发送到第hash(x) % n台服务器上。但当服务器变为m台时，hash(x) % n和hash(x) % m很可能都不相等，这会使得几乎所有请求的发送目的地都发生变化，如果目的地是缓存服务，所有缓存将失效，继而对原本被缓存遮挡的数据库或计算服务造成请求风暴，触发雪崩。一致性哈希是一种特殊的哈希算法，在增加服务器时，发向每个老节点的请求中只会有一部分转向新节点，从而实现平滑的迁移。这篇论文中提出了一致性hash的概念。</p>
<p>一致性hash满足以下四个性质：</p>
<ul>
<li>平衡性 (Balance) : 每个节点被选到的概率是O(1/n)。</li>
<li>单调性 (Monotonicity) : 当新节点加入时， 不会有请求在老节点间移动， 只会从老节点移动到新节点。当有节点被删除时，也不会影响落在别的节点上的请求。</li>
<li>分散性 (Spread) : 当上游的机器看到不同的下游列表时(在上线时及不稳定的网络中比较常见), 同一个请求尽量映射到少量的节点中。</li>
<li>负载 (Load) : 当上游的机器看到不同的下游列表的时候， 保证每台下游分到的请求数量尽量一致。</li>
</ul>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>所有server的32位hash值在32位整数值域上构成一个环(Hash Ring)，环上的每个区间和一个server唯一对应，如果一个key落在某个区间内， 它就被分流到对应的server上。<br><img src="/2018/03/07/distributed-consistent-hashing/chash.png" alt="img01"><br>当删除一个server的， 它对应的区间会归属于相邻的server，所有的请求都会跑过去。当增加一个server时，它会分割某个server的区间并承载落在这个区间上的所有请求。单纯使用Hash Ring很难满足我们上节提到的属性，主要两个问题：</p>
<ul>
<li>在机器数量较少的时候， 区间大小会不平衡。</li>
<li>当一台机器故障的时候， 它的压力会完全转移到另外一台机器， 可能无法承载。<br>为了解决这个问题，我们为每个server计算m个hash值，从而把32位整数值域划分为n*m个区间，当key落到某个区间时，分流到对应的server上。那些额外的hash值使得区间划分更加均匀，被称为Virtual Node。当删除一个server时，它对应的m个区间会分别合入相邻的区间中，那个server上的请求会较为平均地转移到其他server上。当增加server时，它会分割m个现有区间，从对应server上分别转移一些请求过来。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/07/distributed-system-raft/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/07/distributed-system-raft/" itemprop="url">
                  Raft一致性算法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-07T12:04:19+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>在分布式系统中,一致性问题(consensus problem)是指对于一组服务器，给定一组操作，我们需要一个协议使得最后它们的结果达成一致。</p>
<p>在理论计算机科学中，计算机科学家Eric Brewer之后命名为布鲁尔定理的CAP定理指出，分布式数据存储不可能同时提供以下三种保证中的两种以上：</p>
<table>
<thead>
<tr>
<th>一致性</th>
<th>可用性</th>
<th>分区容忍</th>
</tr>
</thead>
<tbody>
<tr>
<td>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</td>
<td>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</td>
<td>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</td>
</tr>
</tbody>
</table>
<p>换句话说，<strong>CAP</strong>定理指出，在存在网络分区的情况下，必须在一致性和可用性之间进行选择。请注意，CAP定理中定义的一致性与ACID 数据库事务中保证的一致性完全不同。</p>
<p>由于CAP理论告诉我们对于分布式系统，如果不想牺牲一致性，我们就只能放弃可用性，所以，数据一致性模型主要有以下几种：强一致性、弱一致性和最终一致性等，在本篇章中，我们主要讨论的算法Raft，是一种分布式系统中的强一致性的实现算法。</p>
<p>强一致性的一般实现的原理：当其中某个服务器收到客户端的一组指令时,它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令,这样的话所有的服务器会产生一致的结果,看起来就像是一台机器一样.</p>
<h2 id="Raft算法描述"><a href="#Raft算法描述" class="headerlink" title="Raft算法描述"></a>Raft算法描述</h2><p>在Raft被提出来之前，Paxos协议是第一个被证明的一致性算法，但是Paxos的论文非常难懂，导致基于Paxos的工程实践和教学都十分头疼，于是Raft在设计的过程中，就从可理解性出发，使用算法分解和减少状态等手段，目前已经应用非常广泛。</p>
<p>在Raft中，问题分解为：领导选取、日志复制、安全和成员变化。</p>
<h3 id="复制状态机（Replicated-State-Machine）"><a href="#复制状态机（Replicated-State-Machine）" class="headerlink" title="复制状态机（Replicated State Machine）"></a>复制状态机（Replicated State Machine）</h3><p><img src="/2018/03/07/distributed-system-raft/raft01.png" alt="img01"></p>
<ul>
<li><p>复制状态机通过复制日志来实现：</p>
<ul>
<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>
<li>状态机：状态机会按顺序执行这些命令</li>
<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>
</ul>
</li>
<li><p>一致性算法作用于一致性模型，一般有以下特性：</p>
<ul>
<li>safety：在非拜占庭问题下（网络延时，网络分区，丢包，重复发包以及包乱序等），结果是正确的</li>
<li>availability：在半数以上机器能正常工作时，则系统可用</li>
<li>timing-unindependent：不依赖于时钟来保证日志一致性，错误的时钟以及极端的消息时延最多会造成可用性问题</li>
</ul>
</li>
</ul>
<h3 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h3><p>每台服务器一定会处于三种状态：</p>
<ul>
<li>领导者</li>
<li>候选人</li>
<li>追随者<br><img src="/2018/03/07/distributed-system-raft/raft02.png" alt="img02"><br>追随者只响应其他服务器的请求。如果追随者没有收到任何消息，它会成为一个候选人并且开始一次选举。收到大多数服务器投票的候选人会成为新的领导人。领导人在它们宕机之前会一直保持领导人的状态。</li>
</ul>
<h3 id="任期-Term"><a href="#任期-Term" class="headerlink" title="任期(Term)"></a>任期(Term)</h3><p>Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。<br><img src="/2018/03/07/distributed-system-raft/raft03.png" alt="img03"></p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起，然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制。为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。<br>RPC有三种：</p>
<ol>
<li>RequestVote RPC：候选人在选举期间发起</li>
<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>
<li>InstallSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。</li>
</ol>
<p>超时设置：</p>
<ol>
<li>BroadcastTime: 领导者的心跳超时时间</li>
<li>Election Timeout: 追随者设置的候选超时时间</li>
<li>MTBT: 指的是单个服务器发生故障的间隔时间的平均数<br>BroadcastTime &lt;&lt; ElectionTimeout &lt;&lt; MTBF</li>
</ol>
<p>两个原则：</p>
<ol>
<li>BroadcastTime应该比ElectionTimeout小一个数量级，为的是使领导人能够持续发送心跳信息（heartbeat）来阻止追随者们开始选举；</li>
<li>ElectionTimeout也要比MTBF小几个数量级，为的是使得系统稳定运行。<br>一般BroadcastTime大约为0.5毫秒到20毫秒，ElectionTimeout一般在10ms到500ms之间。大多数服务器的MTBF都在几个月甚至更长。</li>
</ol>
<h3 id="领导人选取"><a href="#领导人选取" class="headerlink" title="领导人选取"></a>领导人选取</h3><ul>
<li>触发条件：</li>
</ul>
<ol>
<li>一般情况下，追随者接到领导者的心跳时，把ElectionTimeout清零，不会触发；</li>
<li>领导者故障，追随者的ElectionTimeout超时发生时，会变成候选者，触发领导人选取；</li>
</ol>
<ul>
<li>候选操作过程：</li>
</ul>
<p>追随者自增当前任期，转换为Candidate，对自己投票，并发起RequestVote RPC，等待下面三种情形发生；</p>
<ol>
<li>获得超过半数服务器的投票，赢得选举，成为领导者；</li>
<li>另一台服务器赢得选举，并接收到对应的心跳，成为追随者；</li>
<li>选举超时，没有任何一台服务器赢得选举，自增当前任期，重新发起选举；</li>
</ol>
<p>注意事项：</p>
<ol>
<li>服务器在一个任期内，最多能给一个候选人投票，采用先到先服务原则；</li>
<li>候选者等待投票时，可能会接收到来自其它声明为领导人的的AppendEntries RPC。如果该领导人的任期（RPC中有）比当前候选人的当前任期要大，则候选人认为该领导人合法，并转换成追随者；如果RPC中的任期小于候选人的当前任期，则候选人拒绝此次RPC，继续保持候选人状态；</li>
<li>候选人既没有赢得选举也没有输掉选举：如果许多追随者在同一时刻都成为了候选人，选票会被分散，可能没有候选人能获得大多数的选票。当这种情形发生时，每一个候选人都会超时，并且通过自增任期号和发起另一轮 RequestVote RPC 来开始新的选举。然而，如果没有其它手段来分配选票的话，这种情形可能会无限的重复下去。所以Raft使用的随机的选举超时时间（150~300ms之间），来避免这种情况发生。</li>
</ol>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p><img src="/2018/03/07/distributed-system-raft/raft04.png" alt="img04"><br>接受命令的过程：</p>
<ol>
<li>领导者接受客户端请求；</li>
<li>领导者把指令追加到日志；</li>
<li>发送AppendEntries RPC到追随者；</li>
<li>领导者收到大多数追随者的确认后，领导者Commit该日志，把日志在状态机中回放，并返回结果给客户端；</li>
</ol>
<p>提交过程：</p>
<ol>
<li>在下一个心跳阶段，领导者再次发送AppendEntries RPC给追随者，日志已经commited；</li>
<li>追随者收到Commited日志后，将日志在状态机中回放。</li>
</ol>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令，例如：一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p>
<ol>
<li><p>领导者追加日志（Append-Only)<br>领导者永远不会覆盖已经存在的日志条目；<br>日志永远只有一个流向：从领导者到追随者；</p>
</li>
<li><p>选举限制：投票阻止没有全部日志条目的服务器赢得选举<br>如果投票者的日志比候选人的新，拒绝投票请求；<br>这意味着要赢得选举，候选者的日志至少和大多数服务器的日志一样新，那么它一定包含全部的已经提交的日志条目。</p>
</li>
<li><p>永远不提交任期之前的日志条目（只提交任期内的日志条目）<br>在Raft算法中，当一个日志被安全的复制到绝大多数的机器上面，即AppendEntries RPC在绝大多数服务器正确返回了，那么这个日志就是被提交了，然后领导者会更新commit index。<br><img src="/2018/03/07/distributed-system-raft/raft05.png" alt="img05"></p>
</li>
</ol>
<p>如果允许提交任期之前的日志条目，那么在步骤c中，我们就会把之前任期为2的日志提交到其他服务器中去，并造成了大多数机器存在了日志为2的情况。所以造成了d中S5中任期为3的日志条目会覆盖掉已经提交的日志的情况。</p>
<p>Raft 从来不会通过计算复制的数目来提交之前人气的日志条目。只有领导人当前任期的日志条目才能通过计算数目来进行提交。一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配原则（Log Matching Property），之前的日志条目也都会被间接的提交。</p>
<p>论文中的这段话比较难理解，更加直观的说：由于Raft不会提交任期之前的日志条目，那么就不会从b过渡到c的情况，只能从b发生S5down机的情况下直接过渡到e，这样就产生的更新的任期，这样S5就没有机会被选为领导者了。</p>
<ol>
<li>候选者和追随者崩溃<br>候选者和追随者崩溃的情况处理要简单的多。如果这类角色崩溃了，那么后续发送给他们的 RequestVote和AppendEntries的所有RCP都会失败，Raft算法中处理这类失败就是简单的无限重试的方式。<br>　　如果这些服务器重新可用，那么这些RPC就会成功返回。如果一个服务器完成了一个RPC，但是在响应Leader前崩溃了，那么当他再次可用的时候还会收到相同的RPC请求，此时接收服务器负责检查，比如如果收到了已经包含该条日志的RPC请求，可以直接忽略这个请求，确保对系统是无害的。</li>
</ol>
<h3 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h3><p>集群成员的变更和成员的宕机与重启不同，因为前者会修改成员个数进而影响到领导者的选取和决议过程，因为在分布式系统这对于majority这个集群中成员大多数的概念是极为重要的。</p>
<p>简单的做法是，运维人员将系统临时下线，修改配置，重新上线。但是这种做法存在两个缺点：</p>
<ol>
<li>更改时集群不可用</li>
<li>人为操作失误风险<br>直接从一种配置转到新的配置是十分不安全的<br>如下图所示：<br><img src="/2018/03/07/distributed-system-raft/raft06.png" alt="img06"></li>
</ol>
<p>因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</p>
<p>两阶段方法保证安全性：<br>为了保证安全性，配置更改必须使用两阶段方法。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合。</p>
<p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程人依然响应服务器请求。</p>
<p>一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定。领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。当C-old,new日志条目被提交以后，领导人在使用相同的策略提交C-new，如下图所示，C-old 和 C-new 没有任何机会同时做出单方面的决定，这就保证了安全性。<br><img src="/2018/03/07/distributed-system-raft/raft07.png" alt="img07"></p>
<p>一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的条目，实线表示最后被提交的日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old,new 的大多数和 C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在 C-new 和 C-old 可以同时做出决定的时间点。</p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>日志会随着系统的不断运行会无限制的增长，这会给存储带来压力，几乎所有的分布式系统(Chubby、ZooKeeper)都采用快照的方式进行日志压缩，做完快照之后快照会在稳定持久存储中保存，而快照之前的日志和快照就可以丢弃掉。</p>
<p>Raft的具体做法如下图所示：<br><img src="/2018/03/07/distributed-system-raft/raft08.png" alt="img08"><br>与Raft其它操作Leader-Based不同，snapshot是由各个节点独立生成的。除了日志压缩这一个作用之外，snapshot还可以用于同步状态：slow-follower以及new-server，Raft使用InstallSnapshot RPC完成该过程，不再赘述。</p>
<p>Client交互<br>Client只向领导者发送请求；<br>Client开始会向追随者发送请求，追随者拒绝Client的请求，并重定向到领导者；<br>Client请求失败，会超时重新发送请求；<br>Raft算法要求Client的请求线性化，防止请求被多次执行。有两个解决方案：</p>
<p>Raft算法提出要求每个请求有个唯一标识；<br>Raft的请求保持幂等性；</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/28/os-memory-management/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/28/os-memory-management/" itemprop="url">
                  内存管理比较:ptmalloc & tcmalloc & jemalloc
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-28T18:02:10+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>系统的物理内存是有限的，而对内存的需求是变化的, 程序的动态性越强，内存管理就越重要，选择合适的内存管理算法会带来明显的性能提升。<br>比如nginx， 它在每个连接accept后会malloc一块内存，作为整个连接生命周期内的内存池。 当HTTP请求到达的时候，又会malloc一块当前请求阶段的内存池, 因此对malloc的分配速度有一定的依赖关系。(而apache的内存池是有父子关系的，请求阶段的内存池会和连接阶段的使用相同的分配器，如果连接内存池释放则请求阶段的子内存池也会自动释放)。</p>
<p>内存管理可以分为三个层次，自底向上分别是：</p>
<ol>
<li>操作系统内核的内存管理</li>
<li>glibc层使用系统调用维护的内存管理算法</li>
<li>应用程序从glibc动态分配内存后，根据应用程序本身的程序特性进行优化， 比如使用引用计数std::shared_ptr，apache的内存池方式等等。<br>当然应用程序也可以直接使用系统调用从内核分配内存，自己根据程序特性来维护内存，但是会大大增加开发成本。</li>
</ol>
<p>一个优秀的通用内存分配器应具有以下特性:</p>
<ul>
<li>额外的空间损耗尽量少</li>
<li>分配速度尽可能快</li>
<li>尽量避免内存碎片</li>
<li>缓存本地化友好</li>
<li>通用性，兼容性，可移植性，易调试</li>
</ul>
<p>目前大部分服务端程序使用glibc提供的malloc/free系列函数，而glibc使用的ptmalloc2在性能上远远弱后于google的tcmalloc和facebook的jemalloc。 而且后两者只需要使用LD_PRELOAD环境变量启动程序即可，甚至并不需要重新编译。</p>
<h2 id="glibc-ptmalloc2"><a href="#glibc-ptmalloc2" class="headerlink" title="glibc ptmalloc2"></a>glibc ptmalloc2</h2><h3 id="ptmalloc原理"><a href="#ptmalloc原理" class="headerlink" title="ptmalloc原理"></a>ptmalloc原理</h3><h4 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h4><p><img src="/2018/02/28/os-memory-management/os_mem_manage01.png" alt="os-mem01"></p>
<p>上图是 x86_64 下 Linux 进程的默认地址空间, 对 heap 的操作, 操作系统提供了brk()系统调用，设置了Heap的上边界； 对 mmap 映射区域的操作,操作系 统 供了 mmap()和 munmap()函数。<br>因为系统调用的代价很高，不可能每次申请内存都从内核分配空间，尤其是对于小内存分配。 而且因为mmap的区域容易被munmap释放，所以一般大内存采用mmap()，小内存使用brk()。</p>
<h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h4><ul>
<li>Ptmalloc2有一个主分配区(main arena)， 有多个非主分配区。 非主分配区只能使用mmap向操作系统批发申请HEAP_MAX_SIZE（64位系统为64MB）大小的虚拟内存。 当某个线程调用malloc的时候，会先查看线程私有变量中是否已经存在一个分配区，如果存在则尝试加锁，如果加锁失败则遍历arena链表试图获取一个没加锁的arena， 如果依然获取不到则创建一个新的非主分配区。</li>
<li>free()的时候也要获取锁。分配小块内存容易产生碎片，ptmalloc在整理合并的时候也要对arena做加锁操作。在线程多的时候，锁的开销就会增大。</li>
</ul>
<h4 id="ptmalloc内存管理"><a href="#ptmalloc内存管理" class="headerlink" title="ptmalloc内存管理"></a>ptmalloc内存管理</h4><p>用户请求分配的内存在ptmalloc中使用chunk表示， 每个chunk至少需要8个字节额外的开销。 用户free掉的内存不会马上归还操作系统，ptmalloc会统一管理heap和mmap区域的空闲chunk，避免了频繁的系统调用。<br>ptmalloc 将相似大小的 chunk 用双向链表链接起来, 这样的一个链表被称为一个 bin。Ptmalloc 一共 维护了 128 个 bin,并使用一个数组来存储这些 bin(如下图所示)。<br><img src="/2018/02/28/os-memory-management/os_mem_manage02.png" alt="os-mem02"><br>数组中的第一个为 unsorted bin, 数组中从 2 开始编号的前 64 个 bin 称为 small bins, 同一个small bin中的chunk具有相同的大小。small bins后面的bin被称作large bins。</p>
<ul>
<li>当free一个chunk并放入bin的时候， ptmalloc 还会检查它前后的 chunk 是否也是空闲的, 如果是的话,ptmalloc会首先把它们合并为一个大的 chunk, 然后将合并后的 chunk 放到 unstored bin 中。 另外ptmalloc 为了提高分配的速度,会把一些小的(不大于64B) chunk先放到一个叫做 fast bins 的容器内。</li>
<li>在fast bins和bins都不能满足需求后，ptmalloc会设法在一个叫做top chunk的空间分配内存。 对于非主分配区会预先通过mmap分配一大块内存作为top chunk， 当bins和fast bins都不能满足分配需要的时候, ptmalloc会设法在top chunk中分出一块内存给用户, 如果top chunk本身不够大, 分配程序会重新mmap分配一块内存chunk, 并将 top chunk 迁移到新的chunk上，并用单链表链接起来。如果free()的chunk恰好 与 top chunk 相邻,那么这两个 chunk 就会合并成新的 top chunk，如果top chunk大小大于某个阈值才还给操作系统。主分配区类似，不过通过sbrk()分配和调整top chunk的大小，只有heap顶部连续内存空闲超过阈值的时候才能回收内存。</li>
<li>需要分配的 chunk 足够大,而且 fast bins 和 bins 都不能满足要求,甚至 top chunk 本身也不能满足分配需求时,ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。</li>
</ul>
<h4 id="ptmalloc分配流程"><a href="#ptmalloc分配流程" class="headerlink" title="ptmalloc分配流程"></a>ptmalloc分配流程</h4><p><img src="/2018/02/28/os-memory-management/os_mem_manage03.png" alt="os-mem03"></p>
<h4 id="ptmalloc的缺陷"><a href="#ptmalloc的缺陷" class="headerlink" title="ptmalloc的缺陷"></a>ptmalloc的缺陷</h4><ul>
<li>后分配的内存先释放,因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放。</li>
<li>多线程锁开销大， 需要避免多线程频繁分配释放。</li>
<li>内存从thread的areana中分配， 内存不能从一个arena移动到另一个arena， 就是说如果多线程使用内存不均衡，容易导致内存的浪费。 比如说线程1使用了300M内存，完成任务后glibc没有释放给操作系统，线程2开始创建了一个新的arena， 但是线程1的300M却不能用了。</li>
<li>每个chunk至少8字节的开销很大</li>
<li>不定期分配长生命周期的内存容易造成内存碎片，不利于回收。 64位系统最好分配32M以上内存，这是使用mmap的阈值。</li>
</ul>
<h2 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a>tcmalloc</h2><p>tcmalloc是Google开源的一个内存管理库， 作为glibc malloc的替代品。目前已经在chrome、safari等知名软件中运用。<br>根据官方测试报告，ptmalloc在一台2.8GHz的P4机器上（对于小对象）执行一次malloc及free大约需要300纳秒。而TCMalloc的版本同样的操作大约只需要50纳秒。</p>
<h3 id="小对象分配"><a href="#小对象分配" class="headerlink" title="小对象分配"></a>小对象分配</h3><p>tcmalloc为每个线程分配了一个线程本地ThreadCache，小内存从ThreadCache分配，此外还有个中央堆（CentralCache），ThreadCache不够用的时候，会从CentralCache中获取空间放到ThreadCache中。<br>小对象（&lt;=32K）从ThreadCache分配，大对象从CentralCache分配。大对象分配的空间都是4k页面对齐的，多个pages也能切割成多个小对象划分到ThreadCache中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage04.png" alt="os-mem04"><br>小对象有将近170个不同的大小分类(class)，每个class有个该大小内存块的FreeList单链表，分配的时候先找到best fit的class，然后无锁的获取该链表首元素返回。如果链表中无空间了，则到CentralCache中划分几个页面并切割成该class的大小，放入链表中。</p>
<h3 id="CentralCache分配管理"><a href="#CentralCache分配管理" class="headerlink" title="CentralCache分配管理"></a>CentralCache分配管理</h3><ul>
<li>大对象(&gt;32K)先4k对齐后，从CentralCache中分配。 CentralCache维护的PageHeap如下图所示， 数组中第256个元素是所有大于255个页面都挂到该链表中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage05.png" alt="os-mem05"></li>
<li>当best fit的页面链表中没有空闲空间时，则一直往更大的页面空间则，如果所有256个链表遍历后依然没有成功分配。 则使用sbrk, mmap, /dev/mem从系统中分配。</li>
<li>tcmalloc PageHeap管理的连续的页面被称为span.<br>如果span未分配， 则span是PageHeap中的一个链表元素<br>如果span已经分配，它可能是返回给应用程序的大对象， 或者已经被切割成多小对象，该小对象的size-class会被记录在span中</li>
<li>在32位系统中，使用一个中央数组(central array)映射了页面和span对应关系， 数组索引号是页面号，数组元素是页面所在的span。 在64位系统中，使用一个3-level radix tree记录了该映射关系。</li>
</ul>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><ul>
<li>当一个object free的时候，会根据地址对齐计算所在的页面号，然后通过central array找到对应的span。</li>
<li>如果是小对象，span会告诉我们他的size class，然后把该对象插入当前线程的ThreadCache中。如果此时ThreadCache超过一个预算的值（默认2MB），则会使用垃圾回收机制把未使用的object从ThreadCache移动到CentralCache的central free lists中。</li>
<li>如果是大对象，span会告诉我们对象锁在的页面号范围。 假设这个范围是[p,q]， 先查找页面p-1和q+1所在的span，如果这些临近的span也是free的，则合并到[p,q]所在的span， 然后把这个span回收到PageHeap中。</li>
<li>CentralCache的central free lists类似ThreadCache的FreeList，不过它增加了一级结构，先根据size-class关联到spans的集合， 然后是对应span的object链表。如果span的链表中所有object已经free， 则span回收到PageHeap中。</li>
</ul>
<h3 id="tcmalloc的改进"><a href="#tcmalloc的改进" class="headerlink" title="tcmalloc的改进"></a>tcmalloc的改进</h3><ul>
<li>ThreadCache会阶段性的回收内存到CentralCache里。 解决了ptmalloc2中arena之间不能迁移的问题。</li>
<li>Tcmalloc占用更少的额外空间。例如，分配N个8字节对象可能要使用大约8N * 1.01字节的空间。即，多用百分之一的空间。Ptmalloc2使用最少8字节描述一个chunk。</li>
<li>更快。小对象几乎无锁， &gt;32KB的对象从CentralCache中分配使用自旋锁。 并且&gt;32KB对象都是页面对齐分配，多线程的时候应尽量避免频繁分配，否则也会造成自旋锁的竞争和页面对齐造成的浪费。</li>
</ul>
<h2 id="Jemalloc"><a href="#Jemalloc" class="headerlink" title="Jemalloc"></a>Jemalloc</h2><p>jemalloc是facebook推出的， 最早的时候是freebsd的libc malloc实现。 目前在firefox、facebook服务器各种组件中大量使用。</p>
<h3 id="jemalloc原理"><a href="#jemalloc原理" class="headerlink" title="jemalloc原理"></a>jemalloc原理</h3><ul>
<li>与tcmalloc类似，每个线程同样在&lt;32KB的时候无锁使用线程本地cache。</li>
<li>Jemalloc在64bits系统上使用下面的size-class分类：<ul>
<li>Small: [8], [16, 32, 48, …, 128], [192, 256, 320, …, 512], [768, 1024, 1280, …, 3840]</li>
<li>Large: [4 KiB, 8 KiB, 12 KiB, …, 4072 KiB] </li>
<li>Huge: [4 MiB, 8 MiB, 12 MiB, …]</li>
</ul>
</li>
<li>small/large对象查找metadata需要常量时间， huge对象通过全局红黑树在对数时间内查找。</li>
<li>虚拟内存被逻辑上分割成chunks（默认是4MB，1024个4k页），应用线程通过round-robin算法在第一次malloc的时候分配arena， 每个arena都是相互独立的，维护自己的chunks， chunk切割pages到small/large对象。free()的内存总是返回到所属的arena中，而不管是哪个线程调用free()。<br><img src="/2018/02/28/os-memory-management/os_mem_manage06.png" alt="os-mem06"><br>上图可以看到每个arena管理的arena chunk结构， 开始的header主要是维护了一个page map（1024个页面关联的对象状态）， header下方就是它的页面空间。 Small对象被分到一起， metadata信息存放在起始位置。 large chunk相互独立，它的metadata信息存放在chunk header map中。<ul>
<li>通过arena分配的时候需要对arena bin（每个small size-class一个，细粒度）加锁，或arena本身加锁。<br>并且线程cache对象也会通过垃圾回收指数退让算法返回到arena中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage07.png" alt="os-mem07"></li>
</ul>
</li>
</ul>
<h3 id="jemalloc的优化"><a href="#jemalloc的优化" class="headerlink" title="jemalloc的优化"></a>jemalloc的优化</h3><ul>
<li>Jmalloc小对象也根据size-class，但是它使用了低地址优先的策略，来降低内存碎片化。</li>
<li>Jemalloc大概需要2%的额外开销。（tcmalloc 1%， ptmalloc最少8B）</li>
<li>Jemalloc和tcmalloc类似的线程本地缓存，避免锁的竞争</li>
<li>相对未使用的页面，优先使用dirty page，提升缓存命中。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>jemalloc <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919" target="_blank" rel="external">https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919</a></li>
<li>tcmalloc <a href="https://yq.aliyun.com/articles/6045" target="_blank" rel="external">https://yq.aliyun.com/articles/6045</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/27/mysql-index-analysis/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/27/mysql-index-analysis/" itemprop="url">
                  MySQL索引原理剖析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-27T22:52:45+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p>
<p>文章主要内容分为三个部分。</p>
<ul>
<li>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</li>
<li>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</li>
<li>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。</li>
</ul>
<h2 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h2><h3 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是一种数据结构。</p>
<p>数据库查询是数据库的主要功能之一，最基本的查询算法是顺序查找（linear search）时间复杂度为O(n)，显然在数据量很大时效率很低。优化的查找算法如二分查找（binary search）、二叉树查找（binary tree search）等，虽然查找效率提高了。但是各自对检索的数据都有要求：二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织）。所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</p>
<p>看一个例子：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index01.png" alt="pic01"></p>
<p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
<h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h3><p>关于B树和B+树请参考关于B树的一些总结，这篇文章介绍的比较详细，同时容易理解。</p>
<p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<ol>
<li>d&gt;=2，即B-Tree的度；</li>
<li>h为B-Tree的高；</li>
<li>每个非叶子结点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d；</li>
<li>每个叶子结点至少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶结点的指针均为NULL；</li>
<li>所有叶结点都在同一层，深度等于树高h；</li>
<li>key和指针相互间隔，结点两端是指针；</li>
<li>一个结点中的key从左至右非递减排列；</li>
<li>如果某个指针在结点node最左边且不为null，则其指向结点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</li>
<li>如果某个指针在结点node最右边且不为null，则其指向结点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</li>
<li>如果某个指针在结点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向结点的所有key小于v(keyi+1)且大于v(keyi)。<br>图2是一个d=2的B-Tree示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index02.png" alt="pic02"></li>
</ol>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">BTree_Search(node, key) &#123;</div><div class="line">    if(node == null) return null;</div><div class="line">    foreach(node.key)</div><div class="line">    &#123;</div><div class="line">        if(node.key[i] == key) return node.data[i];</div><div class="line">            if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</div><div class="line">    &#125;</div><div class="line">    return BTree_Search(point[i+1]-&gt;node);</div><div class="line">&#125;</div><div class="line">data = BTree_Search(root, my_key);</div></pre></td></tr></table></figure></p>
<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找结点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<ul>
<li>每个结点的指针上限为2d而不是2d+1。</li>
<li>内结点不存储data，只存储key；叶子结点不存储指针。<br>图3是一个简单的B+Tree示意。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index03.png" alt="pic03"></li>
</ul>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶结点和内结点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个结点的域和上限是一致的，所以在实现中B-Tree往往对每个结点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<h4 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h4><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index04.png" alt="pic04"><br>如图4所示，在B+Tree的每个叶子结点增加一个指向相邻叶子结点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着结点和指针顺序遍历就可以一次性访问到所有数据结点，极大提到了区间查询效率。</p>
<p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p>
<h4 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h4><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h4 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h4><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index05.png" alt="pic05"><br>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h4 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h4><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>图6是磁盘的整体结构示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index06.png" alt="pic06"><br>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p>
<p>图7是磁盘结构的示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index07.png" alt="pic07"><br>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>从使用磁盘I/O次数评价索引结构的优劣性：根据B-Tree的定义，可知检索一次最多需要访问h个结点。数据库系统的设计者巧妙的利用了磁盘预读原理，将一个结点的大小设为等于一个页面，这样每个结点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根结点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出读d是非常大的数字，通常超过100，因此h非常小。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树结构，h明显要深得多。由于逻辑上很近的结点（父子结点）物理上可能离得很远，无法利用局部性原理。所以即使红黑树的I/O渐进复杂度也为O(h)，但是查找效率明显比B-Tree差得多。</p>
<p>B+Tree更适合外存索引，是和内结点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于结点内key和data的大小：dmax=floor(pagesize/(keysize+datasize+pointsize))。</p>
<p>floor表示向下取整。由于B+Tree内结点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>
<h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎(MySQL数据库MyISAM和InnoDB存储引擎的比较)的索引实现方式。</p>
<h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶结点的data域存放的是数据记录的地址。下面是MyISAM索引的原理图：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index08.png" alt="pic08"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index09.png" alt="pic09"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做<em>“非聚集”</em>的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶结点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index10.png" alt="pic10"><br>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶结点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index11.png" alt="pic11"><br>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h2 id="聚簇索引-amp-非聚簇索引"><a href="#聚簇索引-amp-非聚簇索引" class="headerlink" title="聚簇索引 &amp; 非聚簇索引"></a>聚簇索引 &amp; 非聚簇索引</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。</li>
<li>非聚簇索引，叶级页指向表中的记录，记录的物理顺序与逻辑顺序没有必然的联系</li>
</ul>
<p>在mysql数据库中，myisam引擎和innodb引擎使用的索引类型不同，myisam对应的是非聚簇索引，而innodb对应的是聚簇索引。聚簇索引也叫复合索引、聚集索引等等。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在聚簇索引中，数据会被按照顺序整理排列，当使用where进行顺序、范围、大小检索时，会大大加速检索效率。非聚簇索引在存储时不会对数据进行排序，相对产生的数据文件体积也比较大。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/26/redis-analysis-sentinel01/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/26/redis-analysis-sentinel01/" itemprop="url">
                  redis-analysis-sentinel01
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-26T03:23:37+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/23/redis-analysis-replicatesource/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/23/redis-analysis-replicatesource/" itemprop="url">
                  Redis源码剖析和注释（二十二）--- Redis 复制(replicate)源码详细解析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T20:08:12+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-复制的介绍"><a href="#1-复制的介绍" class="headerlink" title="1. 复制的介绍"></a>1. 复制的介绍</h2><p>Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="2-复制的实现"><a href="#2-复制的实现" class="headerlink" title="2. 复制的实现"></a>2. 复制的实现</h2><h3 id="2-1-主从关系的建立"><a href="#2-1-主从关系的建立" class="headerlink" title="2.1 主从关系的建立"></a>2.1 主从关系的建立</h3><p>复制的建立方法有三种。</p>
<ol>
<li>在redis.conf文件中配置slaveof <masterip> <masterport>选项，然后指定该配置文件启动Redis生效。</masterport></masterip></li>
<li>在redis-server启动命令后加上–slaveof <masterip> <masterport>启动生效。</masterport></masterip></li>
<li>直接使用 slaveof <masterip> <masterport>命令在从节点执行生效。<br>无论是通过哪一种方式来建立主从复制，都是从节点来执行slaveof命令，那么从节点执行了这个命令到底做了什么，我们上源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// SLAVEOF host port命令实现</div><div class="line">void slaveofCommand(client *c) &#123;</div><div class="line">    // 如果当前处于集群模式，不能进行复制操作</div><div class="line">    if (server.cluster_enabled) &#123;</div><div class="line">        addReplyError(c,&quot;SLAVEOF not allowed in cluster mode.&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // SLAVEOF NO ONE命令使得这个从节点关闭复制功能，并从从节点转变回主节点，原来同步所得的数据集不会被丢弃。</div><div class="line">    if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;no&quot;) &amp;&amp;</div><div class="line">        !strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;one&quot;)) &#123;</div><div class="line">        // 如果保存了主节点IP</div><div class="line">        if (server.masterhost) &#123;</div><div class="line">            // 取消复制操作，设置服务器为主服务器</div><div class="line">            replicationUnsetMaster();</div><div class="line">            // 获取client的每种信息，并以sds形式返回，并打印到日志中</div><div class="line">            sds client = catClientInfoString(sdsempty(),c);</div><div class="line">            serverLog(LL_NOTICE,&quot;MASTER MODE enabled (user request from &apos;%s&apos;)&quot;,</div><div class="line">                client);</div><div class="line">            sdsfree(client);</div><div class="line">        &#125;</div><div class="line">    // SLAVEOF host port</div><div class="line">    &#125; else &#123;</div><div class="line">        long port;</div><div class="line"></div><div class="line">        // 获取端口号</div><div class="line">        if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;port, NULL) != C_OK))</div><div class="line">            return;</div><div class="line"></div><div class="line">        // 如果已存在从属于masterhost主节点且命令参数指定的主节点和masterhost相等，端口也相等，直接返回</div><div class="line">        if (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[1]-&gt;ptr)</div><div class="line">            &amp;&amp; server.masterport == port) &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.&quot;);</div><div class="line">            addReplySds(c,sdsnew(&quot;+OK Already connected to specified master\r\n&quot;));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 第一次执行设置端口和ip，或者是重新设置端口和IP</div><div class="line">        // 设置服务器复制操作的主节点IP和端口</div><div class="line">        replicationSetMaster(c-&gt;argv[1]-&gt;ptr, port);</div><div class="line">        // 获取client的每种信息，并以sds形式返回，并打印到日志中</div><div class="line">        sds client = catClientInfoString(sdsempty(),c);</div><div class="line">        serverLog(LL_NOTICE,&quot;SLAVE OF %s:%d enabled (user request from &apos;%s&apos;)&quot;,</div><div class="line">            server.masterhost, server.masterport, client);</div><div class="line">        sdsfree(client);</div><div class="line">    &#125;</div><div class="line">    // 回复ok</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</masterport></masterip></li>
</ol>
<p>当从节点的client执行SLAVEOF命令后，该命令会被构建成Redis协议格式，发送给从节点服务器，然后节点服务器会调用slaveofCommand()函数执行该命令。</p>
<p>而SLAVEOF命令做的操作并不多，主要以下三步：</p>
<ul>
<li>判断当前环境是否在集群模式下，因为集群模式下不行执行该命令。</li>
<li>是否执行的是SLAVEOF NO ONE命令，该命令会断开主从的关系，设置当前节点为主节点服务器。</li>
<li>设置从节点所属主节点的IP和port。调用了replicationSetMaster()函数。</li>
</ul>
<p>SLAVEOF命令能做的只有这么多，我们来具体看下replicationSetMaster()函数的代码，看看它做了哪些与复制相关的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 设置复制操作的主节点IP和端口</div><div class="line">void replicationSetMaster(char *ip, int port) &#123;</div><div class="line">    // 按需清除原来的主节点信息</div><div class="line">    sdsfree(server.masterhost);</div><div class="line">    // 设置ip和端口</div><div class="line">    server.masterhost = sdsnew(ip);</div><div class="line">    server.masterport = port;</div><div class="line">    // 如果有其他的主节点，在释放</div><div class="line">    // 例如服务器1是服务器2的主节点，现在服务器2要同步服务器3，服务器3要成为服务器2的主节点，因此要释放服务器1</div><div class="line">    if (server.master) freeClient(server.master);</div><div class="line">    // 解除所有客户端的阻塞状态</div><div class="line">    disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */</div><div class="line">    // 关闭所有从节点服务器的连接，强制从节点服务器进行重新同步操作</div><div class="line">    disconnectSlaves(); /* Force our slaves to resync with us as well. */</div><div class="line">    // 释放主节点结构的缓存，不会执行部分重同步PSYNC</div><div class="line">    replicationDiscardCachedMaster(); /* Don&apos;t try a PSYNC. */</div><div class="line">    // 释放复制积压缓冲区</div><div class="line">    freeReplicationBacklog(); /* Don&apos;t allow our chained slaves to PSYNC. */</div><div class="line">    // 取消执行复制操作</div><div class="line">    cancelReplicationHandshake();</div><div class="line">    // 设置复制必须重新连接主节点的状态</div><div class="line">    server.repl_state = REPL_STATE_CONNECT;</div><div class="line">    // 初始化复制的偏移量</div><div class="line">    server.master_repl_offset = 0;</div><div class="line">    // 清零连接断开的时长</div><div class="line">    server.repl_down_since = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由代码知，replicationSetMaster()函数执行操作的也很简单，总结为两步：</p>
<ul>
<li>清理之前所属的主节点的信息。</li>
<li>设置新的主节点IP和port等。<br>因为，当前从节点有可能之前从属于另外的一个主节点服务器，因此要清理所有关于之前主节点的缓存、关闭旧的连接等等。然后设置该从节点的新主节点，设置了IP和port，还设置了以下状态：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 设置复制必须重新连接主节点的状态</div><div class="line">server.repl_state = REPL_STATE_CONNECT;</div><div class="line">// 初始化全局复制的偏移量</div><div class="line">server.master_repl_offset = 0;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后，就没有然后了，然后就会执行复制操作吗？这也没有什么关于复制的操作执行了，那么复制操作是怎么开始的呢？</p>
<h3 id="2-2-主从网络连接建立"><a href="#2-2-主从网络连接建立" class="headerlink" title="2.2 主从网络连接建立"></a>2.2 主从网络连接建立</h3><p>slaveof命令是一个异步命令，执行命令时，从节点保存主节点的信息，确立主从关系后就会立即返回，后续的复制流程在节点内部异步执行。那么，如何触发复制的执行呢？</p>
<p>周期性执行的函数：replicationCron()函数，该函数被服务器的时间事件的回调函数serverCron()所调用，而serverCron()函数在Redis服务器初始化时，被设置为时间事件的处理函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// void initServer(void) Redis服务器初始化</div><div class="line">aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL)</div></pre></td></tr></table></figure></p>
<p>replicationCron()函数执行频率为1秒一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 节选自serverCron函数</div><div class="line">// 周期性执行复制的任务</div><div class="line">run_with_period(1000) replicationCron();</div></pre></td></tr></table></figure></p>
<p>主从关系建立后，从节点服务器的server.repl_state被设置为REPL_STATE_CONNECT，而replicationCron()函数会被每秒执行一次，该函数会发现我（从节点）现在有主节点了，而且我要的状态是要连接主节点（REPL_STATE_CONNECT）。</p>
<p>replicationCron()函数处理这以情况的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* Check if we should connect to a MASTER */</div><div class="line">// 如果处于要必须连接主节点的状态，尝试连接</div><div class="line">if (server.repl_state == REPL_STATE_CONNECT) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Connecting to MASTER %s:%d&quot;,</div><div class="line">        server.masterhost, server.masterport);</div><div class="line">    // 以非阻塞的方式连接主节点</div><div class="line">    if (connectWithMaster() == C_OK) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;MASTER &lt;-&gt; SLAVE sync started&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>replicationCron()函数根据从节点的状态，调用connectWithMaster()非阻塞连接主节点。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 以非阻塞的方式连接主节点</div><div class="line">int connectWithMaster(void) &#123;</div><div class="line">    int fd;</div><div class="line"></div><div class="line">    // 连接主节点</div><div class="line">    fd = anetTcpNonBlockBestEffortBindConnect(NULL,</div><div class="line">        server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);</div><div class="line">    if (fd == -1) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to connect to MASTER: %s&quot;,</div><div class="line">            strerror(errno));</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 监听主节点fd的可读和可写事件的发生，并设置其处理程序为syncWithMaster</div><div class="line">    if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) == AE_ERR)</div><div class="line">    &#123;</div><div class="line">        close(fd);</div><div class="line">        serverLog(LL_WARNING,&quot;Can&apos;t create readable event for SYNC&quot;);</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 最近一次读到RDB文件内容的时间</div><div class="line">    server.repl_transfer_lastio = server.unixtime;</div><div class="line">    // 从节点和主节点的同步套接字</div><div class="line">    server.repl_transfer_s = fd;</div><div class="line">    // 处于和主节点正在连接的状态</div><div class="line">    server.repl_state = REPL_STATE_CONNECTING;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>connectWithMaster()函数执行的操作可以总结为：</p>
<ul>
<li>根据IP和port非阻塞的方式连接主节点，得到主从节点进行通信的文件描述符fd，并保存到从节点服务器server.repl_transfer_s中，并且将刚才的REPL_STATE_CONNECT状态设置为REPL_STATE_CONNECTING。</li>
<li>监听fd的可读和可写事件，并且设置事件发生的处理程序syncWithMaster()函数。<br>至此，主从网络建立就完成了。</li>
</ul>
<h3 id="2-3-发送PING命令"><a href="#2-3-发送PING命令" class="headerlink" title="2.3 发送PING命令"></a>2.3 发送PING命令</h3><p>主从建立网络时，同时注册fd的AE_READABLE|AE_WRITABLE事件，因此会触发一个AE_WRITABLE事件，调用syncWithMaster()函数，处理写事件。</p>
<p>根据当前的REPL_STATE_CONNECTING状态，从节点向主节点发送PING命令，PING命令的目的有：</p>
<ul>
<li>检测主从节点之间的网络是否可用。</li>
<li>检查主从节点当前是否接受处理命令。<br>syncWithMaster()函数中相关操作的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Send a PING to check the master is able to reply without errors. */</div><div class="line">// 如果复制的状态为REPL_STATE_CONNECTING，发送一个PING去检查主节点是否能正确回复一个PONG</div><div class="line">if (server.repl_state == REPL_STATE_CONNECTING) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Non blocking connect for SYNC fired the event.&quot;);</div><div class="line">    // 暂时取消接听fd的写事件，以便等待PONG回复时，注册可读事件</div><div class="line">    aeDeleteFileEvent(server.el,fd,AE_WRITABLE);</div><div class="line">    // 设置复制状态为等待PONG回复</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</div><div class="line">    // 发送一个PING命令</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PING&quot;,NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>发送PING命令主要的操作是：</p>
<ul>
<li>先取消监听fd的写事件，因为接下来要读主节点服务器发送过来的PONG回复，因此只监听可读事件的发生。</li>
<li>设置从节点的复制状态为REPL_STATE_RECEIVE_PONG。等待一个主节点回复一个PONG命令。</li>
<li>以写的方式调用sendSynchronousCommand()函数发送一个PING命令给主节点。<br>主节点服务器从fd会读到一个PING命令，然后会回复一个PONG命令到fd中，执行的命令就是addReply(c,shared.pong);。</li>
</ul>
<p>此时，会触发fd的可读事件，调用syncWithMaster()函数来处理，此时从节点的复制状态为REPL_STATE_RECEIVE_PONG，等待主节点回复PONG。syncWithMaster()函数中处理这一状态的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/* Receive the PONG command. */</div><div class="line">// 如果复制的状态为REPL_STATE_RECEIVE_PONG，等待接受PONG命令</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</div><div class="line">   // 从主节点读一个PONG命令sendSynchronousCommand</div><div class="line">   err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line"></div><div class="line">    // 只接受两种有效的回复。一种是 &quot;+PONG&quot;，一种是认证错误&quot;-NOAUTH&quot;。</div><div class="line">    // 旧版本的返回有&quot;-ERR operation not permitted&quot;</div><div class="line">    if (err[0] != &apos;+&apos; &amp;&amp;</div><div class="line">        strncmp(err,&quot;-NOAUTH&quot;,7) != 0 &amp;&amp;</div><div class="line">        strncmp(err,&quot;-ERR operation not permitted&quot;,28) != 0)</div><div class="line">    &#123;   // 没有收到正确的PING命令的回复</div><div class="line">        serverLog(LL_WARNING,&quot;Error reply to PING from master: &apos;%s&apos;&quot;,err);</div><div class="line">        sdsfree(err);</div><div class="line">        goto error;</div><div class="line">     &#125; else &#123;</div><div class="line">       serverLog(LL_NOTICE,&quot;Master replied to PING, replication can continue...&quot;);</div><div class="line">     &#125;</div><div class="line">     sdsfree(err);</div><div class="line">     // 已经收到PONG，更改状态设置为发送认证命令AUTH给主节点</div><div class="line">     server.repl_state = REPL_STATE_SEND_AUTH;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，以读的方式调用sendSynchronousCommand()，并将读到的”+PONG\r\n”返回到err中，如果从节点正确接收到主节点发送的PONG命令，会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_AUTH。等待进行权限的认证。</p>
<h3 id="2-4-认证权限"><a href="#2-4-认证权限" class="headerlink" title="2.4 认证权限"></a>2.4 认证权限</h3><p>权限认证会在syncWithMaster()函数继续执行，紧接着刚才的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* AUTH with the master if required. */</div><div class="line">// 如果需要，发送AUTH认证给主节点</div><div class="line">if (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</div><div class="line">   // 如果服务器设置了认证密码</div><div class="line">   if (server.masterauth) &#123;</div><div class="line">        // 写AUTH给主节点</div><div class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;AUTH&quot;,server.masterauth,NULL);</div><div class="line">        if (err) goto write_error;</div><div class="line">        // 设置状态为等待接受认证回复</div><div class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</div><div class="line">        return;</div><div class="line">    // 如果没有设置认证密码，直接设置复制状态为发送端口号给主节点</div><div class="line">    &#125; else &#123;</div><div class="line">        server.repl_state = REPL_STATE_SEND_PORT;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果从节点的服务器设置了认证密码，则会以写方式调用sendSynchronousCommand()函数，将AUTH命令和密码写到fd中，并且将从节点的复制状态设置为server.repl_state = REPL_STATE_RECEIVE_AUTH，接受AUTH的验证。</p>
<p>如果从节点服务器没有设置认证密码，就直接将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_PORT，准发发送一个端口号。</p>
<p>主节点会读取到AUTH命令，调用authCommand()函数来处理，主节点服务器会比较从节点发送过来的server.masterauth和主节点服务器保存的server.requirepass是否一致，如果一致，会回复一个”+OK\r\n”。</p>
<p>当主节点将回复写到fd时，又会触发从节点的可读事件，紧接着调用syncWithMaster()函数来处理接收AUTH认证结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Receive AUTH reply. */</div><div class="line">// 接受AUTH认证的回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</div><div class="line">    // 从主节点读回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 回复错误，认证失败</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to AUTH to MASTER: %s&quot;,err);</div><div class="line">        sdsfree(err);</div><div class="line">        goto error;</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送端口号给主节点</div><div class="line">    server.repl_state = REPL_STATE_SEND_PORT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以读方式从fd中读取一个回复，判断认证是否成功，认证成功，则会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_PORT表示要发送一个端口号给主节点。这和没有设置认证的情况结果相同。</p>
<h3 id="2-5-发送端口号"><a href="#2-5-发送端口号" class="headerlink" title="2.5 发送端口号"></a>2.5 发送端口号</h3><p>从节点在认证完权限后，会继续在syncWithMaster()函数执行，处理发送端口号的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Set the slave port, so that Master&apos;s INFO command can list the</div><div class="line"> * slave listening port correctly. */</div><div class="line">// 如果复制状态是，发送从节点端口号给主节点，主节点的INFO命令就能够列出从节点正在监听的端口号</div><div class="line">if (server.repl_state == REPL_STATE_SEND_PORT) &#123;</div><div class="line">    // 获取端口号</div><div class="line">    sds port = sdsfromlonglong(server.slave_announce_port ?</div><div class="line">        server.slave_announce_port : server.port);</div><div class="line">    // 将端口号写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;listening-port&quot;,port, NULL);</div><div class="line">    sdsfree(port);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受端口号</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发送端口号，以REPLCONF listening-port命令的方式，写到fd中。然后将复制状态设置为server.repl_state = REPL_STATE_RECEIVE_PORT，等待接受主节点的回复。</p>
<p>主节点从fd中读到REPLCONF listening-port <port>命令，调用replconfCommand()命令来处理，而replconfCommand()函数的定义就在replication.c文件中，REPLCONF命令可以设置多种不同的选项，解析到端口号后，将端口号保存从节点对应client状态的c-&gt;slave_listening_port = port中。最终回复一个”+OK\r\n”状态的回复，写在fd中。</port></p>
<p>当主节点将回复写到fd时，又会触发从节点的可读事件，紧接着调用syncWithMaster()函数来处理接受端口号，验证主节点是否正确的接收到从节点的端口号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Receive REPLCONF listening-port reply. */</div><div class="line">// 复制状态为接受端口号</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</div><div class="line">    // 从主节点读取端口号</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    /* Ignore the error if any, not all the Redis versions support</div><div class="line">     * REPLCONF listening-port. */</div><div class="line">    // 忽略所有的错误，因为不是所有的Redis版本都支持REPLCONF listening-port命令</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF listening-port: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送IP</div><div class="line">    server.repl_state = REPL_STATE_SEND_IP;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确的接收到从节点的端口号，会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_IP表示要送一个IP给主节点。</p>
<h3 id="2-6-发送-IP-地址"><a href="#2-6-发送-IP-地址" class="headerlink" title="2.6 发送 IP 地址"></a>2.6 发送 IP 地址</h3><p>从节点发送完端口号并且正确收到主节点的回复后，紧接着syncWithMaster()函数执行发送IP的代码。发送IP和发送端口号过程几乎一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送IP</div><div class="line">if (server.repl_state == REPL_STATE_SEND_IP) &#123;</div><div class="line">    // 将IP写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;ip-address&quot;,server.slave_announce_ip, NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受IP</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样是以REPLCONF ip-address命令的方式，将从节点的IP写到fd中。并且设置从节点的复制状态为server.repl_state = REPL_STATE_RECEIVE_IP，等待接受主节点的回复。然后就直接返回，等待fd可读发生。</p>
<p>主节点仍然会调用replication.c文件中实现的replconfCommand()函数来处理REPLCONF命令，解析出REPLCONF ip-address ip命令，保存从节点的ip到主节点的对应从节点的client的c-&gt;slave_ip中。然后回复”+OK\r\n”状态，写到fd中。</p>
<p>此时，从节点监听到fd触发了可读事件，会调用syncWithMaster()函数来处理，验证主节点是否正确接收到从节点的IP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Receive REPLCONF ip-address reply. */</div><div class="line">// 复制状态为接受IP回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</div><div class="line">    // 从主节点读一个IP回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 错误回复</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF ip-address: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送一个capa（能力？能否解析出RDB文件的EOF流格式）</div><div class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确接收了从节点IP，就会设置从节点的复制状态server.repl_state = REPL_STATE_SEND_CAPA表示发送从节点的能力（capability）。</p>
<h3 id="2-7-发送能力（capability）"><a href="#2-7-发送能力（capability）" class="headerlink" title="2.7 发送能力（capability）"></a>2.7 发送能力（capability）</h3><p>发送能力和发送端口和IP也是如出一辙，紧接着syncWithMaster()函数执行发送capa的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送capa，通知主节点从节点的能力</div><div class="line">if (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</div><div class="line">    // 将从节点的capa写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;capa&quot;,&quot;eof&quot;,NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受从节点的capa</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从节点将REPLCONF capa eof命令发送给主节点，写到fd中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">目前只支持一种能力，就是能够解析出RDB文件的EOF流格式。用于无盘复制的方式中。</div></pre></td></tr></table></figure></p>
<p>主节点仍然会调用replication.c文件中实现的replconfCommand()函数来处理REPLCONF命令，解析出REPLCONF capa eof命令，将eof对应的标识，按位与到主节点的对应从节点的client的c-&gt;slave_capa中。然后回复”+OK\r\n”状态，写到fd中。</p>
<p>此时，从节点监听到fd触发了可读事件，会调用syncWithMaster()函数来处理，验证主节点是否正确接收到从节点的capa。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Receive CAPA reply. */</div><div class="line">// 复制状态为接受从节点的capa回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</div><div class="line">    // 从主节点读取capa回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 错误回复</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF capa: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送PSYNC命令</div><div class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确接收了从节点capa，就会设置从节点的复制状态server.repl_state = REPL_STATE_SEND_PSYNC表示发送一个PSYNC命令</p>
<h3 id="2-8-发送PSYNC命令"><a href="#2-8-发送PSYNC命令" class="headerlink" title="2.8 发送PSYNC命令"></a>2.8 发送PSYNC命令</h3><p>从节点发送PSYNC命令给主节点，尝试进行同步主节点的数据集。同步分为两种：</p>
<ul>
<li>全量同步：第一次执行复制的场景。</li>
<li>部分同步：用于主从复制因为网络中断等原因造成数据丢失的场景。<br>因为这是第一次执行同步，因此会进行全量同步。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送PSYNC命令。尝试进行部分重同步。</div><div class="line">// 如果没有缓冲主节点的结构，slaveTryPartialResynchronization()函数将会至少尝试使用PSYNC去进行一个全同步，这样就能得到主节点的运行runid和全局复制偏移量。并且在下次重连接时可以尝试进行部分重同步。</div><div class="line">if (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</div><div class="line">    // 向主节点发送一个部分重同步命令PSYNC，参数0表示不读主节点的回复，只获取主节点的运行runid和全局复制偏移量</div><div class="line">    if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) &#123;</div><div class="line">        // 发送PSYNC出错</div><div class="line">        err = sdsnew(&quot;Write error sending the PSYNC command.&quot;);</div><div class="line">        goto write_error;</div><div class="line">    &#125;</div><div class="line">    // 设置复制状态为等待接受一个PSYNC回复</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从节点调用slaveTryPartialResynchronization()函数尝试进行重同步，注意第二个参数是0。因为slaveTryPartialResynchronization()分成两部分，一部分是写，一部分是读，因为第二个参数是0，因此执行写的一部分，发送一个PSYNC命令给主节点。只列举出写的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* Writing half */</div><div class="line">// 如果read_reply为0，则该函数往socket上会写入一个PSYNC命令</div><div class="line">if (!read_reply) &#123;</div><div class="line">    // 将repl_master_initial_offset设置为-1表示主节点的run_id和全局复制偏移量是无效的。</div><div class="line">    // 如果能使用PSYNC命令执行一个全量同步，会正确设置全复制偏移量，以便这个信息被正确传播主节点的所有从节点中</div><div class="line">    server.repl_master_initial_offset = -1;</div><div class="line"></div><div class="line">    // 主节点的缓存不为空，可以尝试进行部分重同步。PSYNC &lt;master_run_id&gt; &lt;repl_offset&gt;</div><div class="line">    if (server.cached_master) &#123;</div><div class="line">        // 保存缓存runid</div><div class="line">        psync_runid = server.cached_master-&gt;replrunid;</div><div class="line">        // 获取已经复制的偏移量</div><div class="line">        snprintf(psync_offset,sizeof(psync_offset),&quot;%lld&quot;, server.cached_master-&gt;reploff+1);</div><div class="line">        serverLog(LL_NOTICE,&quot;Trying a partial resynchronization (request %s:%s).&quot;, psync_runid, psync_offset);</div><div class="line">    // 主节点的缓存为空，发送PSYNC ? -1。请求全量同步</div><div class="line">    &#125; else &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;Partial resynchronization not possible (no cached master)&quot;);</div><div class="line">        psync_runid = &quot;?&quot;;</div><div class="line">        memcpy(psync_offset,&quot;-1&quot;,3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Issue the PSYNC command */</div><div class="line">    // 发送一个PSYNC命令给主节点</div><div class="line">    reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PSYNC&quot;,psync_runid,psync_offset,NULL);</div><div class="line">    // 写成功失败会返回一个&quot;-&quot;开头的字符串</div><div class="line">    if (reply != NULL) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to send PSYNC to master: %s&quot;,reply);</div><div class="line">        sdsfree(reply);</div><div class="line">        // 删除文件的可读事件，返回写错误PSYNC_WRITE_ERROR</div><div class="line">        aeDeleteFileEvent(server.el,fd,AE_READABLE);</div><div class="line">        return PSYNC_WRITE_ERROR;</div><div class="line">    &#125;</div><div class="line">    // 返回等待回复的标识PSYNC_WAIT_REPLY，调用者会将read_reply设置为1，然后再次调用该函数，执行下面的读部分。</div><div class="line">    return PSYNC_WAIT_REPLY;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于从节点是第一次和主节点进行同步操作，因此从节点缓存的主节点client状态erver.cached_master为空，所以就会发送一个PSYNC ? -1命令给主节点，表示进行一次全量同步。</p>
<p>主节点会接收到PSYNC ? -1命令，然后调用replication.c文件中实现的syncCommand()函数处理PSYNC命令。</p>
<p>syncCommand()函数先会判断执行的是PSYNC还是SYNC命令，如果是PSYNC命令会调用masterTryPartialResynchronization()命令执行部分同步，但是由于这是第一次执行复制操作，所以会执行失败。进而执行全量同步。</p>
<p>syncCommand()函数的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">/* SYNC and PSYNC command implemenation. */</div><div class="line">// SYNC and PSYNC 命令实现</div><div class="line">void syncCommand(client *c) &#123;</div><div class="line">    ..........//为了简洁，删除一些判断条件的代码</div><div class="line"></div><div class="line">    // 尝试执行一个部分同步PSYNC的命令，则masterTryPartialResynchronization()会回复一个 &quot;+FULLRESYNC &lt;runid&gt; &lt;offset&gt;&quot;,如果失败则执行全量同步</div><div class="line">    // 所以，从节点会如果和主节点连接断开，从节点会知道runid和offset，随后会尝试执行PSYNC</div><div class="line">    // 如果是执行PSYNC命令</div><div class="line">    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;psync&quot;)) &#123;</div><div class="line">        // 主节点尝试执行部分重同步，执行成功返回C_OK</div><div class="line">        if (masterTryPartialResynchronization(c) == C_OK) &#123;</div><div class="line">            // 可以执行PSYNC命令，则将接受PSYNC命令的个数加1</div><div class="line">            server.stat_sync_partial_ok++;</div><div class="line">            // 不需要执行后面的全量同步，直接返回</div><div class="line">            return; /* No full resync needed, return. */</div><div class="line">        // 不能执行PSYNC部分重同步，需要进行全量同步</div><div class="line">        &#125; else &#123;</div><div class="line">            char *master_runid = c-&gt;argv[1]-&gt;ptr;</div><div class="line">            // 从节点以强制全量同步为目的，所以不能执行部分重同步，因此增加PSYNC命令失败的次数</div><div class="line">            if (master_runid[0] != &apos;?&apos;) server.stat_sync_partial_err++;</div><div class="line">        &#125;</div><div class="line">    // 执行SYNC命令</div><div class="line">    &#125; else &#123;</div><div class="line">        // 设置标识，执行SYNC命令，不接受REPLCONF ACK</div><div class="line">        c-&gt;flags |= CLIENT_PRE_PSYNC;</div><div class="line">    &#125;</div><div class="line">    // 全量重同步次数加1</div><div class="line">    server.stat_sync_full++;</div><div class="line"></div><div class="line">    // 设置client状态为：从服务器节点等待BGSAVE节点的开始</div><div class="line">    c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</div><div class="line">    // 执行SYNC命令后是否关闭TCP_NODELAY</div><div class="line">    if (server.repl_disable_tcp_nodelay)</div><div class="line">        // 是的话，则启用nagle算法</div><div class="line">        anetDisableTcpNoDelay(NULL, c-&gt;fd); /* Non critical if it fails. */</div><div class="line">    // 保存主服务器传来的RDB文件的fd，设置为-1</div><div class="line">    c-&gt;repldbfd = -1;</div><div class="line">    // 设置client状态为从节点，标识client是一个从服务器</div><div class="line">    c-&gt;flags |= CLIENT_SLAVE;</div><div class="line">    // 添加到服务器从节点链表中</div><div class="line">    listAddNodeTail(server.slaves,c);</div><div class="line"></div><div class="line">    /* CASE 1: BGSAVE is in progress, with disk target. */</div><div class="line">    // 情况1. 正在执行 BGSAVE ，且是同步到磁盘上</div><div class="line">    if (server.rdb_child_pid != -1 &amp;&amp;</div><div class="line">        server.rdb_child_type == RDB_CHILD_TYPE_DISK)</div><div class="line">    &#123;</div><div class="line">        client *slave;</div><div class="line">        listNode *ln;</div><div class="line">        listIter li;</div><div class="line"></div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            slave = ln-&gt;value;</div><div class="line">            // 如果有从节点已经创建子进程执行写RDB操作，等待完成，那么退出循环</div><div class="line">            // 从节点的状态为 SLAVE_STATE_WAIT_BGSAVE_END 在情况三中被设置</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) break;</div><div class="line">        &#125;</div><div class="line">        // 对于这个从节点，我们检查它是否具有触发当前BGSAVE操作的能力</div><div class="line">        if (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</div><div class="line">            // 将slave的输出缓冲区所有内容拷贝给c的所有输出缓冲区中</div><div class="line">            copyClientOutputBuffer(c,slave);</div><div class="line">            // 设置全量重同步从节点的状态，设置部分重同步的偏移量</div><div class="line">            replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</div><div class="line">            serverLog(LL_NOTICE,&quot;Waiting for end of BGSAVE for SYNC&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Can&apos;t attach the slave to the current BGSAVE. Waiting for next BGSAVE for SYNC&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    /* CASE 2: BGSAVE is in progress, with socket target. */</div><div class="line">    // 情况2. 正在执行BGSAVE，且是无盘同步，直接写到socket中</div><div class="line">    &#125; else if (server.rdb_child_pid != -1 &amp;&amp;</div><div class="line">               server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</div><div class="line">    &#123;</div><div class="line">        // 虽然有子进程在执行写RDB，但是它直接写到socket中，所以等待下次执行BGSAVE</div><div class="line">        serverLog(LL_NOTICE,&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;);</div><div class="line"></div><div class="line">    /* CASE 3: There is no BGSAVE is progress. */</div><div class="line">    // 情况3：没有执行BGSAVE的进程</div><div class="line">    &#125; else &#123;</div><div class="line">        // 服务器支持无盘同步</div><div class="line">        if (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</div><div class="line">            // 无盘同步复制的子进程被创建在replicationCron()中，因为想等待更多的从节点可以到来而延迟</div><div class="line">            if (server.repl_diskless_sync_delay)</div><div class="line">                serverLog(LL_NOTICE,&quot;Delay next BGSAVE for diskless SYNC&quot;);</div><div class="line">        // 服务器不支持无盘复制</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果没有正在执行BGSAVE，且没有进行写AOF文件，则开始为复制执行BGSAVE，并且是将RDB文件写到磁盘上</div><div class="line">            if (server.aof_child_pid == -1) &#123;</div><div class="line">                startBgsaveForReplication(c-&gt;slave_capa);</div><div class="line">            &#125; else &#123;</div><div class="line">                serverLog(LL_NOTICE,</div><div class="line">                    &quot;No BGSAVE in progress, but an AOF rewrite is active. BGSAVE for replication delayed&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 只有一个从节点，且backlog为空，则创建一个新的backlog</div><div class="line">    if (listLength(server.slaves) == 1 &amp;&amp; server.repl_backlog == NULL)</div><div class="line">        createReplicationBacklog();</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先先明确，主节点执行处理从节点发来PSYNC命令的操作。所以主节点会将从节点视为自己的从节点客户端来操作。会将从节点的复制设置为SLAVE_STATE_WAIT_BGSAVE_START状态表示</p>
<p>主节点执行全量同步的情况有三种：</p>
<ul>
<li>主节点服务器正在执行BGSAVE命令，且将RDB文件写到磁盘上。<br>这种情况，如果有已经设置过全局重同步偏移量的从节点，可以共用输出缓冲区的数据。</li>
<li>主节点服务器正在执行BGSAVE命令，且将RDB文件写到网络socket上，无盘同步。<br>由于本次BGSAVE命令直接将RDB写到socket中，因此只能等待下一BGSAVE。</li>
<li>主节点服务器没有正在执行BGSAVE。<br>如果也没有进行AOF持久化的操作，那么开始为复制操作执行BGSAVE，生成一个写到磁盘上的RDB文件。<br>我们针对第三种情况来分析。调用了startBgsaveForReplication()来开始执行BGSAVE命令。我们贴出主要的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 开始为复制执行BGSAVE，根据配置选择磁盘或套接字作为RDB发送的目标，在开始之前确保冲洗脚本缓存</div><div class="line">// mincapa参数是SLAVE_CAPA_*按位与的结果</div><div class="line">int startBgsaveForReplication(int mincapa) &#123;</div><div class="line">    int retval;</div><div class="line">    // 是否直接写到socket</div><div class="line">    int socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line"></div><div class="line">    if (socket_target)</div><div class="line">        // 直接写到socket中</div><div class="line">        // fork一个子进程将rdb写到 状态为等待BGSAVE开始 的从节点的socket中</div><div class="line">        retval = rdbSaveToSlavesSockets();</div><div class="line">    else</div><div class="line">        // 否则后台进行RDB持久化BGSAVE操作，保存到磁盘上</div><div class="line">        retval = rdbSaveBackground(server.rdb_filename);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    // 如果是直接写到socket中，rdbSaveToSlavesSockets()已经会设置从节点为全量复制</div><div class="line">    // 否则直接写到磁盘上，执行以下代码</div><div class="line">    if (!socket_target) &#123;</div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = ln-&gt;value;</div><div class="line">            // 设置等待全量同步的从节点的状态</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</div><div class="line">                    // 设置要执行全量重同步从节点的状态</div><div class="line">                    replicationSetupSlaveForFullResync(slave,</div><div class="line">                            getPsyncInitialOffset());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>replicationSetupSlaveForFullResync()函数源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int replicationSetupSlaveForFullResync(client *slave, long long offset) &#123;</div><div class="line">    char buf[128];</div><div class="line">    int buflen;</div><div class="line"></div><div class="line">    // 设置全量重同步的偏移量</div><div class="line">    slave-&gt;psync_initial_offset = offset;</div><div class="line">    // 设置从节点复制状态，开始累计差异数据</div><div class="line">    slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END;</div><div class="line">    // 将slaveseldb设置为-1，是为了强制发送一个select命令在复制流中</div><div class="line">    server.slaveseldb = -1;</div><div class="line"></div><div class="line">    // 如果从节点的状态是CLIENT_PRE_PSYNC，则表示是Redis是2.8之前的版本，则不将这些信息发送给从节点。</div><div class="line">    // 因为在2.8之前只支持SYNC的全量复制同步，而在之后的版本提供了部分的重同步</div><div class="line">    if (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;</div><div class="line">        buflen = snprintf(buf,sizeof(buf),&quot;+FULLRESYNC %s %lld\r\n&quot;,</div><div class="line">                          server.runid,offset);</div><div class="line">        // 否则会将全量复制的信息写给从节点</div><div class="line">        if (write(slave-&gt;fd,buf,buflen) != buflen) &#123;</div><div class="line">            freeClientAsync(slave);</div><div class="line">            return C_ERR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>哇，主节点终于回复从节点的PSYNC命令了，回复了一个+FULLRESYNC，写到主从同步的fd。表示要进行全量同步啊！！！</p>
<p>此时，从节点的复制状态一定为REPL_STATE_RECEIVE_PSYNC，fd的读事件发生，调用syncWithMaster()函数进行处理。</p>
<p>处理这种情况的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 那么尝试进行第二次部分重同步，从主节点读取指令来决定执行部分重同步还是全量同步</div><div class="line">psync_result = slaveTryPartialResynchronization(fd,1);</div></pre></td></tr></table></figure></p>
<p>这次的第二个参数是1，因此会执行该函数的读部分。(因为这个函数有两个部分，上一次执行了写部分，因为第二个参数是0)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/* Reading half */</div><div class="line">// 从主节点读一个命令保存在reply中</div><div class="line">reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">if (sdslen(reply) == 0) &#123;</div><div class="line">    // 主节点为了保持连接的状态，可能会在接收到PSYNC命令后发送一个空行</div><div class="line">    sdsfree(reply);</div><div class="line">    // 所以就返回PSYNC_WAIT_REPLY，调用者会将read_reply设置为1，然后再次调用该函数。</div><div class="line">    return PSYNC_WAIT_REPLY;</div><div class="line">&#125;</div><div class="line">// 如果读到了一个命令，删除fd的可读事件</div><div class="line">aeDeleteFileEvent(server.el,fd,AE_READABLE);</div><div class="line"></div><div class="line">// 接受到的是&quot;+FULLRESYNC&quot;，表示进行一次全量同步</div><div class="line">if (!strncmp(reply,&quot;+FULLRESYNC&quot;,11)) &#123;</div><div class="line">    char *runid = NULL, *offset = NULL;</div><div class="line">    // 解析回复中的内容，将runid和复制偏移量提取出来</div><div class="line">    runid = strchr(reply,&apos; &apos;);</div><div class="line">    if (runid) &#123;</div><div class="line">        runid++;    //定位到runid的地址</div><div class="line">        offset = strchr(runid,&apos; &apos;);</div><div class="line">        if (offset) offset++;   //定位offset</div><div class="line">    &#125;</div><div class="line">    // 如果runid和offset任意为空，那么发生不期望错误</div><div class="line">    if (!runid || !offset || (offset-runid-1) != CONFIG_RUN_ID_SIZE) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Master replied with wrong +FULLRESYNC syntax.&quot;);</div><div class="line">        // 将主节点的运行ID重置为0</div><div class="line">        memset(server.repl_master_runid,0,CONFIG_RUN_ID_SIZE+1);</div><div class="line">    // runid和offset获取成功</div><div class="line">    &#125; else &#123;</div><div class="line">        // 设置服务器保存的主节点的运行ID</div><div class="line">        memcpy(server.repl_master_runid, runid, offset-runid-1);</div><div class="line">        server.repl_master_runid[CONFIG_RUN_ID_SIZE] = &apos;\0&apos;;</div><div class="line">        // 主节点的偏移量</div><div class="line">        server.repl_master_initial_offset = strtoll(offset,NULL,10);</div><div class="line">        serverLog(LL_NOTICE,&quot;Full resync from master: %s:%lld&quot;,server.repl_master_runid,          server.repl_master_initial_offset);</div><div class="line">    &#125;</div><div class="line">    // 执行全量同步，所以缓存的主节点结构没用了，将其清空</div><div class="line">    replicationDiscardCachedMaster();</div><div class="line">    sdsfree(reply);</div><div class="line">    // 返回执行的状态</div><div class="line">    return PSYNC_FULLRESYNC;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接受到的是&quot;+CONTINUE&quot;，表示进行一次部分重同步</div><div class="line">if (!strncmp(reply,&quot;+CONTINUE&quot;,9)) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Successful partial resynchronization with master.&quot;);</div><div class="line">    sdsfree(reply);</div><div class="line">    // 因为执行部分重同步，因此要使用缓存的主节点结构，所以将其设置为当前的主节点，被同步的主节点</div><div class="line">    replicationResurrectCachedMaster(fd);</div><div class="line">    // 返回执行的状态</div><div class="line">    return PSYNC_CONTINUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收到了错误，两种情况。</div><div class="line">// 1. 主节点不支持PSYNC命令，Redis版本低于2.8</div><div class="line">// 2. 从主节点读取了一个不期望的回复</div><div class="line">if (strncmp(reply,&quot;-ERR&quot;,4)) &#123;</div><div class="line">    /* If it&apos;s not an error, log the unexpected event. */</div><div class="line">    serverLog(LL_WARNING,&quot;Unexpected reply to PSYNC from master: %s&quot;, reply);</div><div class="line">&#125; else &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Master does not support PSYNC or is in error state (reply: %s)&quot;, reply);</div><div class="line">&#125;</div><div class="line">sdsfree(reply);</div><div class="line">replicationDiscardCachedMaster();</div><div class="line">// 发送不支持PSYNC命令的状态</div><div class="line">return PSYNC_NOT_SUPPORTED;</div></pre></td></tr></table></figure></p>
<p>至此，从节点监听主节点的读命令事件已经完成，所以取消监听了读事件。等到主节点开始传送数据给从节点时，从节点会新创建读事件。</p>
<p>该函数可以解析出主节点发过来的命令是哪一个，一共有三种：</p>
<ul>
<li>“+FULLRESYNC”：代表要进行一次全量复制。</li>
<li>“+CONTINUE”：代表要进行一次部分重同步。</li>
<li>“-ERR”：发生了错误。有两种可能：Redis版本过低不支持PSYNC命令和从节点读到一个错误回复。<br>我们关注第一个全量同步的操作。如果读到了主节点发来的”+FULLRESYNC”，那么会将同时发来的主节点运行ID和全局的复制偏移量保存到从节点的服务器属性中server.repl_master_runid和server.repl_master_initial_offset。然后返回PSYNC_FULLRESYNC。</li>
</ul>
<p>回到syncWithMaster函数，继续处理全量同步。由于要进行全量同步，如果当前从节点还作为其他节点的主节点，因此要断开所有从节点的连接，让他们也重新同步当前节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 执行到这里，psync_result == PSYNC_FULLRESYNC或PSYNC_NOT_SUPPORTED</div><div class="line">    // 准备一个合适临时文件用来写入和保存主节点传来的RDB文件数据</div><div class="line">    while(maxtries--) &#123;</div><div class="line">        // 设置文件的名字</div><div class="line">        snprintf(tmpfile,256,</div><div class="line">            &quot;temp-%d.%ld.rdb&quot;,(int)server.unixtime,(long int)getpid());</div><div class="line">        // 以读写，可执行权限打开临时文件</div><div class="line">        dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);</div><div class="line">        // 打开成功，跳出循环</div><div class="line">        if (dfd != -1) break;</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">    /* Setup the non blocking download of the bulk file. */</div><div class="line">    // 监听一个fd的读事件，并设置该事件的处理程序为readSyncBulkPayload</div><div class="line">    if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL)</div><div class="line">            == AE_ERR)</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_WARNING,</div><div class="line">            &quot;Can&apos;t create readable event for SYNC: %s (fd=%d)&quot;,</div><div class="line">            strerror(errno),fd);</div><div class="line">        goto error;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 复制状态为正从主节点接受RDB文件</div><div class="line">    server.repl_state = REPL_STATE_TRANSFER;</div><div class="line">    // 初始化RDB文件的大小</div><div class="line">    server.repl_transfer_size = -1;</div><div class="line">    // 已读的大小</div><div class="line">    server.repl_transfer_read = 0;</div><div class="line">    // 最近一个执行fsync的偏移量为0</div><div class="line">    server.repl_transfer_last_fsync_off = 0;</div><div class="line">    // 传输RDB文件的临时fd</div><div class="line">    server.repl_transfer_fd = dfd;</div><div class="line">    // 最近一次读到RDB文件内容的时间</div><div class="line">    server.repl_transfer_lastio = server.unixtime;</div><div class="line">    // 保存RDB文件的临时文件名</div><div class="line">    server.repl_transfer_tmpfile = zstrdup(tmpfile);</div><div class="line">    return;</div></pre></td></tr></table></figure></p>
<p> 准备好了所有，接下来就要等待主节点来发送RDB文件了。因此上面做了这三件事：</p>
<ul>
<li>打开一个临时文件，用来保存主节点发来的RDB文件数据的。</li>
<li>监听fd的读事件，等待主节点发送RDB文件数据，触发可读事件执行readSyncBulkPayload()函数，该函数就会把主节点发来的数据读到一个缓冲区中，然后将缓冲区的数据写到刚才打开的临时文件中，接着要载入到从节点的数据库中，最后同步到磁盘中。</li>
<li>设置复制操作的状态为server.repl_state = REPL_STATE_TRANSFER。并且初始化复制的信息，例如：RDB文件的大小，偏移量，等等。（具体看上面的代码）<br>主节点要发送RDB文件，但是回复完”+FULLRESYNC”就再也没有操作了。而子节点创建了监听主节点写RDB文件的事件，等待主节点来写，才调用readSyncBulkPayload()函数来处理。这又有问题了，到底主节点什么时候发送RDB文件呢？如果不是主动执行，那么一定就在周期性函数内被执行。</li>
</ul>
<p>它的调用关系如下：</p>
<p>serverCron()-&gt;backgroundSaveDoneHandler()-&gt;backgroundSaveDoneHandlerDisk()-&gt;updateSlavesWaitingBgsave()</p>
<p>updateSlavesWaitingBgsave()函数定义在replication.c中，主要操作有两步，我们简单介绍：</p>
<ul>
<li>只读打开主节点的临时RDB文件，然后设置从节点client复制状态为SLAVE_STATE_SEND_BULK。</li>
<li>立刻创建监听可写的事件，并设置sendBulkToSlave()函数为可写事件的处理程序。<br>当主节点执行周期性函数时，主节点会先清除之前监听的可写事件，然后立即监听新的可写事件，这样就会触发可写的事件，调用sendBulkToSlave()函数将RDB文件写入到fd中，触发从节点的读事件，从节点调用readSyncBulkPayload()函数，来将RDB文件的数据载入数据库中，至此，就保证了主从同步了。</li>
</ul>
<p>我们来简单介绍sendBulkToSlave()函数在写RDB文件时做了什么：</p>
<ul>
<li>将RDB文件的大小写给从节点，以协议格式的字符串表示的大小。</li>
<li>从RDB文件的repldbfd中读出RDB文件数据，然后写到主从同步的fd中。</li>
<li>写入完成后，又一次取消监听文件可写事件，等待下一次发送缓冲区数据时在监听触发，并且调用putSlaveOnline()函数将从节点client的复制状态设置为SLAVE_STATE_ONLINE。表示已经发送RDB文件完毕，发送缓存更新。</li>
</ul>
<h3 id="2-9-发送输出缓冲区数据"><a href="#2-9-发送输出缓冲区数据" class="headerlink" title="2.9 发送输出缓冲区数据"></a>2.9 发送输出缓冲区数据</h3><p>主节点发送完RDB文件后，调用putSlaveOnline()函数将从节点client的复制状态设置为SLAVE_STATE_ONLINE，表示已经发送RDB文件完毕，要发送缓存更新了。于是会新创建一个事件，监听写事件的发生，设置sendReplyToClient为可写的处理程序，而且会将从节点client当做私有数据闯入sendReplyToClient()当做发送缓冲区的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE,sendReplyToClient, slave)</div></pre></td></tr></table></figure></p>
<p>创建可写事件的时候，就会触发第一次可写，执行sendReplyToClient()，该函数还直接调用了riteToClient(fd,privdata,1)函数，于是将从节点client输出缓冲区的数据发送给了从节点服务器。</p>
<p>riteToClient()函数数据Redis网络连接库的函数，定义在network.c中，具体分析请看：Redis 网络连接库源码分析</p>
<p>这样就保证主从服务器的数据库状态一致了。</p>
<h3 id="2-10-命令传播"><a href="#2-10-命令传播" class="headerlink" title="2.10 命令传播"></a>2.10 命令传播</h3><p>主从节点在第一次全量同步之后就达到了一致，但是之后主节点如果执行了写命令，主节点的数据库状态就又可能发生变化，导致主从再次不一致。为了让主从节点回到一致状态，主机的执行命令后都需要将命令传播到从节点。</p>
<p>传播时会调用server.c中的propagate()函数，如果传播到从节点会调用replicationFeedSlaves(server.slaves,dbid,argv,argc)函数，该函数则会将执行的命令以协议的传输格式写到从节点client的输出缓冲区中，这就是为什么主节点会将从节点client的输出缓冲区发送到从节点（具体见标题2.9），也会添加到server.repl_backlog中。</p>
<p>我们来看看replicationFeedSlaves()函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">// 将参数列表中的参数发送给从服务器</div><div class="line">void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) &#123;</div><div class="line">    listNode *ln;</div><div class="line">    listIter li;</div><div class="line">    int j, len;</div><div class="line">    char llstr[LONG_STR_SIZE];</div><div class="line"></div><div class="line">    // 如果没有backlog且没有从节点服务器，直接返回</div><div class="line">    if (server.repl_backlog == NULL &amp;&amp; listLength(slaves) == 0) return;</div><div class="line"></div><div class="line">    /* We can&apos;t have slaves attached and no backlog. */</div><div class="line">    serverAssert(!(listLength(slaves) != 0 &amp;&amp; server.repl_backlog == NULL));</div><div class="line"></div><div class="line">    // 如果当前从节点使用的数据库不是目标的数据库，则要生成一个select命令</div><div class="line">    if (server.slaveseldb != dictid) &#123;</div><div class="line">        robj *selectcmd;</div><div class="line"></div><div class="line">        // 0 &lt;= id &lt; 10 ，可以使用共享的select命令对象</div><div class="line">        if (dictid &gt;= 0 &amp;&amp; dictid &lt; PROTO_SHARED_SELECT_CMDS) &#123;</div><div class="line">            selectcmd = shared.select[dictid];</div><div class="line">        // 否则自行按照协议格式构建select命令对象</div><div class="line">        &#125; else &#123;</div><div class="line">            int dictid_len;</div><div class="line"></div><div class="line">            dictid_len = ll2string(llstr,sizeof(llstr),dictid);</div><div class="line">            selectcmd = createObject(OBJ_STRING,</div><div class="line">                sdscatprintf(sdsempty(),</div><div class="line">                &quot;*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n&quot;,</div><div class="line">                dictid_len, llstr));</div><div class="line">        &#125;</div><div class="line">        // 将select 命令添加到backlog中</div><div class="line">        if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);</div><div class="line"></div><div class="line">        // 发送给从服务器</div><div class="line">        listRewind(slaves,&amp;li);</div><div class="line">        // 遍历所有的从服务器节点</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = ln-&gt;value;</div><div class="line">            // 从节点服务器状态为等待BGSAVE的开始，因此跳过回复，遍历下一个节点</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;</div><div class="line">            // 添加select命令到当前从节点的回复中</div><div class="line">            addReply(slave,selectcmd);</div><div class="line">        &#125;</div><div class="line">        // 释放临时对象</div><div class="line">        if (dictid &lt; 0 || dictid &gt;= PROTO_SHARED_SELECT_CMDS)</div><div class="line">            decrRefCount(selectcmd);</div><div class="line">    &#125;</div><div class="line">    // 设置当前从节点使用的数据库ID</div><div class="line">    server.slaveseldb = dictid;</div><div class="line"></div><div class="line">    // 将命令写到backlog中</div><div class="line">    if (server.repl_backlog) &#123;</div><div class="line">        char aux[LONG_STR_SIZE+3];</div><div class="line"></div><div class="line">        // 将参数个数构建成协议标准的字符串</div><div class="line">        // *&lt;argc&gt;\r\n</div><div class="line">        aux[0] = &apos;*&apos;;</div><div class="line">        len = ll2string(aux+1,sizeof(aux)-1,argc);</div><div class="line">        aux[len+1] = &apos;\r&apos;;</div><div class="line">        aux[len+2] = &apos;\n&apos;;</div><div class="line">        // 添加到backlog中</div><div class="line">        feedReplicationBacklog(aux,len+3);</div><div class="line"></div><div class="line">        // 遍历所有的参数</div><div class="line">        for (j = 0; j &lt; argc; j++) &#123;</div><div class="line">            // 返回参数对象的长度</div><div class="line">            long objlen = stringObjectLen(argv[j]);</div><div class="line"></div><div class="line">            // 构建成协议标准的字符串，并添加到backlog中</div><div class="line">            // $&lt;len&gt;\r\n&lt;argv&gt;\r\n</div><div class="line">            aux[0] = &apos;$&apos;;</div><div class="line">            len = ll2string(aux+1,sizeof(aux)-1,objlen);</div><div class="line">            aux[len+1] = &apos;\r&apos;;</div><div class="line">            aux[len+2] = &apos;\n&apos;;</div><div class="line">            // 添加$&lt;len&gt;\r\n</div><div class="line">            feedReplicationBacklog(aux,len+3);</div><div class="line">            // 添加参数对象&lt;argv&gt;</div><div class="line">            feedReplicationBacklogWithObject(argv[j]);</div><div class="line">            // 添加\r\n</div><div class="line">            feedReplicationBacklog(aux+len+1,2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 将命令写到每一个从节点中</div><div class="line">    listRewind(server.slaves,&amp;li);</div><div class="line">    // 遍历从节点链表</div><div class="line">    while((ln = listNext(&amp;li))) &#123;</div><div class="line">        client *slave = ln-&gt;value;</div><div class="line"></div><div class="line">        // 从节点服务器状态为等待BGSAVE的开始，因此跳过回复，遍历下一个节点</div><div class="line">        if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;</div><div class="line"></div><div class="line">        // 将命令写给正在等待初次SYNC的从节点（所以这些命令在输出缓冲区中排队，直到初始SYNC完成），或已经与主节点同步</div><div class="line">        /* Add the multi bulk length. */</div><div class="line">        // 添加回复的长度</div><div class="line">        addReplyMultiBulkLen(slave,argc);</div><div class="line"></div><div class="line">        // 将所有的参数列表添加到从节点的输出缓冲区</div><div class="line">        for (j = 0; j &lt; argc; j++)</div><div class="line">            addReplyBulk(slave,argv[j]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和AOF持久化一样，再给从节点client写命令时，会将SELECT命令强制写入，以保证命令正确读到数据库中。</p>
<p>不仅写入了从节点client的输出缓冲区，而且还会将命令记录到主节点服务器的复制积压缓冲区server.repl_backlog中，这是为了网络闪断后进行部分重同步。</p>
<h2 id="3-部分重同步实现"><a href="#3-部分重同步实现" class="headerlink" title="3. 部分重同步实现"></a>3. 部分重同步实现</h2><p>刚才剖析完全量同步，但是没有考虑特殊的情况。如果在传输RDB文件的过程中，网络发生故障，主节点和从节点的连接中断，Redis会咋么做呢？</p>
<p>Redis 2.8 版本之前会在进行一次连接然后进行全量复制，但是这样效率非常地下，之后的版本都提供了部分重同步的实现。那么我们就分析一下部分重同步的实现过程。</p>
<p>部分重同步在复制的过程中，相当于标题2.8的发送PSYNC命令的部分，其他所有的部分都要进行，他只是主节点回复从节点的命令不同，回复+CONTINUE则执行部分重同步，回复+FULLRESYNC则执行全量同步。</p>
<h3 id="3-1-心跳机制"><a href="#3-1-心跳机制" class="headerlink" title="3.1 心跳机制"></a>3.1 心跳机制</h3><p>主节点是如何发现和从节点连接中断？在主从节点建立连接后，他们之间都维护者长连接并彼此发送心跳命令。主从节点彼此都有心跳机制，各自模拟成对方的客户端进行通信。</p>
<ul>
<li>主节点默认每隔10秒发送PING命令，判断从节点的连接状态。 </li>
<li><p>文件配置项：repl-ping-salve-period，默认是10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 首先，根据当前节点发送PING命令给从节点的频率发送PING命令 </div><div class="line">// 如果当前节点是某以节点的 主节点 ，那么发送PING给从节点</div><div class="line">if ((replication_cron_loops % server.repl_ping_slave_period) == 0) &#123;</div><div class="line">    // 创建PING命令对象</div><div class="line">    ping_argv[0] = createStringObject(&quot;PING&quot;,4);</div><div class="line">    // 将PING发送给从服务器</div><div class="line">    replicationFeedSlaves(server.slaves, server.slaveseldb, ping_argv, 1);</div><div class="line">    decrRefCount(ping_argv[0]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从节点在主线程中每隔1秒发送REPLCONF ACK <offset>命令，给主节点报告自己当前复制偏移量。</offset></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 定期发送ack给主节点，旧版本的Redis除外</div><div class="line">if (server.masterhost &amp;&amp; server.master &amp;&amp; !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</div><div class="line">    // 发送一个REPLCONF ACK命令给主节点去报告关于当前处理的offset。</div><div class="line">    replicationSendAck();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在周期性函数replicationCron()，每次都要检查和主节点处于连接状态的从节点和主节点的交互时间是否超时，如果超时则会调用cancelReplicationHandshake()函数，取消和主节点的连接。等到下一个周期在和主节点重新建立连接，进行复制。</p>
<h3 id="3-2-复制积压缓冲区-backlog"><a href="#3-2-复制积压缓冲区-backlog" class="headerlink" title="3.2 复制积压缓冲区(backlog)"></a>3.2 复制积压缓冲区(backlog)</h3><p>复制积压缓冲区是一个大小为1M的循环队列。主节点在命令传播时，不仅会将命令发送给所有的从节点，还会将命令写入复制积压缓冲区中（具体请看标题2.10）。</p>
<p>也就是说，复制积压缓冲区最多可以备份1M大小的数据，如果主从节点断线时间过长，复制积压缓冲区的数据会被新数据覆盖，那么当从主从中断连接起，主节点接收到的数据超过1M大小，那么从节点就无法进行部分重同步，只能进行全量复制。</p>
<p>在标题2.8，介绍的syncCommand()命令中，调用masterTryPartialResynchronization()函数会进行尝试部分重同步，在我们之前分析的第一次全量同步时，该函数会执行失败，然后返回syncCommand()函数执行全量同步，而在进行恢复主从连接后，则会进行部分重同步，masterTryPartialResynchronization()函数代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">// 该函数从主节点接收到部分重新同步请求的角度处理PSYNC命令</div><div class="line">// 成功返回C_OK，否则返回C_ERR</div><div class="line">int masterTryPartialResynchronization(client *c) &#123;</div><div class="line">    long long psync_offset, psync_len;</div><div class="line">    char *master_runid = c-&gt;argv[1]-&gt;ptr;   //主节点的运行ID</div><div class="line">    char buf[128];</div><div class="line">    int buflen;</div><div class="line"></div><div class="line">    // 主节点的运行ID是否和从节点执行PSYNC的参数提供的运行ID相同。</div><div class="line">    // 如果运行ID发生了改变，则主节点是一个不同的实例，那么就不能进行继续执行原有的复制进程</div><div class="line">    if (strcasecmp(master_runid, server.runid)) &#123;</div><div class="line">        /* Run id &quot;?&quot; is used by slaves that want to force a full resync. */</div><div class="line">        // 如果从节点的运行ID是&quot;?&quot;，表示想要强制进行一个全量同步</div><div class="line">        if (master_runid[0] != &apos;?&apos;) &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Partial resynchronization not accepted: &quot;</div><div class="line">                &quot;Runid mismatch (Client asked for runid &apos;%s&apos;, my runid is &apos;%s&apos;)&quot;,</div><div class="line">                master_runid, server.runid);</div><div class="line">        &#125; else &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Full resync requested by slave %s&quot;,</div><div class="line">                replicationGetSlaveName(c));</div><div class="line">        &#125;</div><div class="line">        goto need_full_resync;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从参数对象中获取psync_offset</div><div class="line">    if (getLongLongFromObjectOrReply(c,c-&gt;argv[2],&amp;psync_offset,NULL) !=</div><div class="line">       C_OK) goto need_full_resync;</div><div class="line">    // 如果psync_offset小于repl_backlog_off，说明backlog所备份的数据的已经太新了，有一些数据被覆盖，则需要进行全量复制</div><div class="line">    // 如果psync_offset大于(server.repl_backlog_off + server.repl_backlog_histlen)，表示当前backlog的数据不够全，则需要进行全量复制</div><div class="line">    if (!server.repl_backlog ||</div><div class="line">        psync_offset &lt; server.repl_backlog_off ||</div><div class="line">        psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_NOTICE,</div><div class="line">            &quot;Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld).&quot;, replicationGetSlaveName(c), psync_offset);</div><div class="line">        if (psync_offset &gt; server.master_repl_offset) &#123;</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Warning: slave %s tried to PSYNC with an offset that is greater than the master replication offset.&quot;, replicationGetSlaveName(c));</div><div class="line">        &#125;</div><div class="line">        goto need_full_resync;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行到这里，则可以进行部分重同步</div><div class="line">    // 1. 设置client状态为从节点</div><div class="line">    // 2. 向从节点发送 +CONTINUE 表示接受 partial resync 被接受</div><div class="line">    // 3. 发送backlog的数据给从节点</div><div class="line"></div><div class="line">    // 设置client状态为从节点</div><div class="line">    c-&gt;flags |= CLIENT_SLAVE;</div><div class="line">    // 设置复制状态为在线，此时RDB文件传输完成，发送差异数据</div><div class="line">    c-&gt;replstate = SLAVE_STATE_ONLINE;</div><div class="line">    // 设置从节点收到ack的时间</div><div class="line">    c-&gt;repl_ack_time = server.unixtime;</div><div class="line">    // slave向master发送ack标志设置为0</div><div class="line">    c-&gt;repl_put_online_on_ack = 0;</div><div class="line">    // 将当前client加入到从节点链表中</div><div class="line">    listAddNodeTail(server.slaves,c);</div><div class="line">    // 向从节点发送 +CONTINUE</div><div class="line">    buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE\r\n&quot;);</div><div class="line">    if (write(c-&gt;fd,buf,buflen) != buflen) &#123;</div><div class="line">        freeClientAsync(c);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">    // 将backlog的数据发送从节点</div><div class="line">    psync_len = addReplyReplicationBacklog(c,psync_offset);</div><div class="line">    serverLog(LL_NOTICE,</div><div class="line">        &quot;Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.&quot;, replicationGetSlaveName(c), psync_len, psync_offset);</div><div class="line">    // 计算延迟值小于min-slaves-max-lag的从节点的个数</div><div class="line">    refreshGoodSlavesCount();</div><div class="line">    return C_OK; /* The caller can return, no full resync needed. */</div><div class="line"></div><div class="line">need_full_resync:</div><div class="line">    return C_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果可以进行部分重同步，主节点则会发送”+CONTINUE\r\n”作为从节点发送PSYNC回复（看标题2.8）。然后调用addReplyReplicationBacklog()函数，将backlog中的数据发送给从节点。于是就完成了部分重同步。</p>
<p>addReplyReplicationBacklog()函数所做的就是将backlog写到从节点的client的输出缓冲区中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/23/redis-analysis-replicate/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/23/redis-analysis-replicate/" itemprop="url">
                  Redis源码剖析和注释（十二）--- Redis 复制(replicate)源码详细解析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T18:34:50+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-复制介绍"><a href="#1-复制介绍" class="headerlink" title="1. 复制介绍"></a>1. 复制介绍</h2><p>分布式数据库为了获取更大的存储容量和更高的并发访问量，会将原来集中式数据库中的数据分散存储到多个通过网络连接的数据存储节点上。Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="2-复制的建立"><a href="#2-复制的建立" class="headerlink" title="2. 复制的建立"></a>2. 复制的建立</h2><p>建立复制的配置方式有三种。</p>
<ul>
<li>在redis.conf文件中配置slaveof <masterip> <masterport>选项，然后指定该配置文件启动Redis生效。</masterport></masterip></li>
<li>在redis-server启动命令后加上–slaveof <masterip> <masterport>启动生效。</masterport></masterip></li>
<li><p>直接使用 slaveof <masterip> <masterport>命令在从节点执行生效。<br>我们以最简单的一主一从模型，使用第2种方式建立复制。</masterport></masterip></p>
</li>
<li><p>首先先开启主节点master实例，端口8888</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --port 8888</div></pre></td></tr></table></figure>
</li>
<li><p>接着开启从节点slave实例，端口9999，并指定指定主节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis-server --port 9999 --slaveof 127.0.0.1 8888</div><div class="line">//命令行开启Redis服务器后，会打印如下日志信息，已经开启复制了</div><div class="line">Connecting to MASTER 127.0.0.1:8888</div><div class="line">MASTER &lt;-&gt; SLAVE sync started</div><div class="line">Non blocking connect for SYNC fired the event.</div><div class="line">Master replied to PING, replication can continue...</div><div class="line">Partial resynchronization not possible (no cached master)</div><div class="line">Full resync from master: 1aff09ecd70ca640e33083f8422018b29883b9d1:1</div><div class="line">MASTER &lt;-&gt; SLAVE sync: receiving 76 bytes from master</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Flushing old data</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Finished with success</div></pre></td></tr></table></figure>
</li>
<li><p>开启一个client，连接上从节点服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  ~ redis-cli -p 9999</div><div class="line">127.0.0.1:9999&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:slave                      //节点角色</div><div class="line">master_host:127.0.0.1           //主节点的IP</div><div class="line">master_port:8888                //主节点的端口</div><div class="line">master_link_status:up           //与主节点的连接状态</div><div class="line">master_last_io_seconds_ago:0    //主节点最后与从节点的通信时间间隔，单位秒</div><div class="line">master_sync_in_progress:0       //从节点是否正在全量同步主节点的RDB文件</div><div class="line">slave_repl_offset:407           //复制偏移量</div><div class="line">slave_priority:100              //从节点的优先级</div><div class="line">slave_read_only:1               //从节点是否只读</div><div class="line">connected_slaves:0              //连接从节点的个数</div><div class="line">master_repl_offset:0            //当前从节点作为其他从节点的主节点时的复制偏移量</div><div class="line">//以下四种信息为通用的配置</div><div class="line">repl_backlog_active:0           //复制缓冲区的状态</div><div class="line">repl_backlog_size:1048576       //复制缓冲区的大小</div><div class="line">repl_backlog_first_byte_offset:0//复制缓冲区起始偏移量，标识当前缓冲区可用的范围</div><div class="line">repl_backlog_histlen:0          //标识复制缓冲区已存在的有效数据长度</div><div class="line">127.0.0.1:9999&gt; KEYS *          //由于主节点的键空间为空，所以从节点的键空间也为空。</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，我们查看主节点的INFO replication 信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//通过INFO replication命令可以查看当前的复制信息</div><div class="line">127.0.0.1:6380&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:master                                                     //节点角色</div><div class="line">connected_slaves:1                                              //连接从节点的个数</div><div class="line">slave0:ip=127.0.0.1,port=9999,state=online,offset=631,lag=0     //连接从节点的信息</div><div class="line">master_repl_offset:631                                          //主节点的偏移量</div><div class="line">//以下四种信息为通用的配置  </div><div class="line">repl_backlog_active:1                                           //复制缓冲区的状态</div><div class="line">repl_backlog_size:1048576                                       //复制缓冲区的大小</div><div class="line">repl_backlog_first_byte_offset:2                                //复制缓冲区起始偏移量，标识当前缓冲区可用的范围</div><div class="line">repl_backlog_histlen:630                                        //由于主节点的键空间为空，所以从节点的键空间也为空。</div></pre></td></tr></table></figure></p>
<p>到此，一主一从模型的复制就建立成功了。我们可以在主节点建立一些新的键，然后查看从节点的键空间的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//根据端口区别主从节点</div><div class="line">127.0.0.1:8888&gt; HSET hash_key hello world</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:9999&gt; KEYS *  //从节点的键空间已经更新</div><div class="line">1) &quot;hash_key&quot;</div></pre></td></tr></table></figure></p>
<p>我们在查看从节点的INFO replication信息时，可以知道slave_read_only:1，从节点默认只能读不能写，因此执行写命令会得到如下回复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; SET key value</div><div class="line">(error) READONLY You can&apos;t write against a read only slave.</div></pre></td></tr></table></figure></p>
<p>只读模式由 redis.conf 文件中的 slave-read-only 选项控制，也可以通过 CONFIG SET命令来开启或关闭这个模式。</p>
<p>我们在查看从节点的INFO replication信息时，还发现有connected_slaves:0选项 ，说明Redis的复制拓扑结构支持单层或多层复制关系，从节点还可以作为其他从节点的主节点进行复制。</p>
<p>根据拓扑关系可以分为三种：</p>
<ul>
<li><p>一主一从<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication01.jpg" alt="replicate01"></p>
</li>
<li><p>一主多从<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication02.jpg" alt="replicate01"></p>
</li>
<li><p>树型主从结构<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication03.jpg" alt="replicate01"></p>
</li>
</ul>
<h2 id="3-复制的断开"><a href="#3-复制的断开" class="headerlink" title="3. 复制的断开"></a>3. 复制的断开</h2><p>复制断开也是在从节点执行命令slaveof no one来断开于主节点的复制关系。例如，将刚才端口为9999的从节点断开复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; SLAVEOF no one</div><div class="line">OK</div><div class="line">//从节点服务器会打印如下日志</div><div class="line">Connection with master lost.</div><div class="line">Caching the disconnected master state.</div><div class="line">Discarding previously cached master state.</div><div class="line">MASTER MODE enabled (user request from &apos;id=3 addr=127.0.0.1:40218 fd=7 name= age=2218 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=slaveof&apos;)</div><div class="line">//主节点服务器也会打印断开的信息</div><div class="line">Connection with slave 127.0.0.1:9999 lost.</div></pre></td></tr></table></figure></p>
<p>从节点服务器断开后，从节点会晋升为主节点。从日志中可以看到MASTER MODE enabled，也可以从INFO命令查看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:master     //角色发生变化</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="4-min-slaves配置选项"><a href="#4-min-slaves配置选项" class="headerlink" title="4. min-slaves配置选项"></a>4. min-slaves配置选项</h2><p>Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主节点在不安全的情况下执行写命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">min-slaves-to-write 3   //从节点数量少于3个，主节点拒绝执行写命令</div><div class="line">min-slaves-max-lag 10   //3个从节点的延迟(lag)值，大于或等于10，主节点拒绝执行写命令</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="He Lei" />
          <p class="site-author-name" itemprop="name">He Lei</p>
          <p class="site-description motion-element" itemprop="description">c/c++/python | redis | recommend algorithm | search engine</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">73</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mcgrady-forever" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wuxubj" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He Lei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
