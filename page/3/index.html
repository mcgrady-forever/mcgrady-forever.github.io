<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta property="og:type" content="website">
<meta property="og:title" content="HeLei Blog">
<meta property="og:url" content="http://hlei.io/page/3/index.html">
<meta property="og:site_name" content="HeLei Blog">
<meta property="og:description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HeLei Blog">
<meta name="twitter:description" content="c/c++/python | redis | recommend algorithm | search engine">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hlei.io/page/3/"/>





  <title> HeLei Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HeLei Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">不要因为走得太远，就忘记为什么而出发</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/07/distributed-system-raft/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/07/distributed-system-raft/" itemprop="url">
                  Raft一致性算法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-07T12:04:19+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>在分布式系统中,一致性问题(consensus problem)是指对于一组服务器，给定一组操作，我们需要一个协议使得最后它们的结果达成一致。</p>
<p>在理论计算机科学中，计算机科学家Eric Brewer之后命名为布鲁尔定理的CAP定理指出，分布式数据存储不可能同时提供以下三种保证中的两种以上：</p>
<table>
<thead>
<tr>
<th>一致性</th>
<th>可用性</th>
<th>分区容忍</th>
</tr>
</thead>
<tbody>
<tr>
<td>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</td>
<td>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</td>
<td>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</td>
</tr>
</tbody>
</table>
<p>换句话说，<strong>CAP</strong>定理指出，在存在网络分区的情况下，必须在一致性和可用性之间进行选择。请注意，CAP定理中定义的一致性与ACID 数据库事务中保证的一致性完全不同。</p>
<p>由于CAP理论告诉我们对于分布式系统，如果不想牺牲一致性，我们就只能放弃可用性，所以，数据一致性模型主要有以下几种：强一致性、弱一致性和最终一致性等，在本篇章中，我们主要讨论的算法Raft，是一种分布式系统中的强一致性的实现算法。</p>
<p>强一致性的一般实现的原理：当其中某个服务器收到客户端的一组指令时,它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令,这样的话所有的服务器会产生一致的结果,看起来就像是一台机器一样.</p>
<h2 id="Raft算法描述"><a href="#Raft算法描述" class="headerlink" title="Raft算法描述"></a>Raft算法描述</h2><p>在Raft被提出来之前，Paxos协议是第一个被证明的一致性算法，但是Paxos的论文非常难懂，导致基于Paxos的工程实践和教学都十分头疼，于是Raft在设计的过程中，就从可理解性出发，使用算法分解和减少状态等手段，目前已经应用非常广泛。</p>
<p>在Raft中，问题分解为：领导选取、日志复制、安全和成员变化。</p>
<h3 id="复制状态机（Replicated-State-Machine）"><a href="#复制状态机（Replicated-State-Machine）" class="headerlink" title="复制状态机（Replicated State Machine）"></a>复制状态机（Replicated State Machine）</h3><p><img src="/2018/03/07/distributed-system-raft/raft01.png" alt="img01"></p>
<ul>
<li><p>复制状态机通过复制日志来实现：</p>
<ul>
<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>
<li>状态机：状态机会按顺序执行这些命令</li>
<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>
</ul>
</li>
<li><p>一致性算法作用于一致性模型，一般有以下特性：</p>
<ul>
<li>safety：在非拜占庭问题下（网络延时，网络分区，丢包，重复发包以及包乱序等），结果是正确的</li>
<li>availability：在半数以上机器能正常工作时，则系统可用</li>
<li>timing-unindependent：不依赖于时钟来保证日志一致性，错误的时钟以及极端的消息时延最多会造成可用性问题</li>
</ul>
</li>
</ul>
<h3 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h3><p>每台服务器一定会处于三种状态：</p>
<ul>
<li>领导者</li>
<li>候选人</li>
<li>追随者<br><img src="/2018/03/07/distributed-system-raft/raft02.png" alt="img02"><br>追随者只响应其他服务器的请求。如果追随者没有收到任何消息，它会成为一个候选人并且开始一次选举。收到大多数服务器投票的候选人会成为新的领导人。领导人在它们宕机之前会一直保持领导人的状态。</li>
</ul>
<h3 id="任期-Term"><a href="#任期-Term" class="headerlink" title="任期(Term)"></a>任期(Term)</h3><p>Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。<br><img src="/2018/03/07/distributed-system-raft/raft03.png" alt="img03"></p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起，然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制。为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。<br>RPC有三种：</p>
<ol>
<li>RequestVote RPC：候选人在选举期间发起</li>
<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>
<li>InstallSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。</li>
</ol>
<p>超时设置：</p>
<ol>
<li>BroadcastTime: 领导者的心跳超时时间</li>
<li>Election Timeout: 追随者设置的候选超时时间</li>
<li>MTBT: 指的是单个服务器发生故障的间隔时间的平均数<br>BroadcastTime &lt;&lt; ElectionTimeout &lt;&lt; MTBF</li>
</ol>
<p>两个原则：</p>
<ol>
<li>BroadcastTime应该比ElectionTimeout小一个数量级，为的是使领导人能够持续发送心跳信息（heartbeat）来阻止追随者们开始选举；</li>
<li>ElectionTimeout也要比MTBF小几个数量级，为的是使得系统稳定运行。<br>一般BroadcastTime大约为0.5毫秒到20毫秒，ElectionTimeout一般在10ms到500ms之间。大多数服务器的MTBF都在几个月甚至更长。</li>
</ol>
<h3 id="领导人选取"><a href="#领导人选取" class="headerlink" title="领导人选取"></a>领导人选取</h3><ul>
<li>触发条件：</li>
</ul>
<ol>
<li>一般情况下，追随者接到领导者的心跳时，把ElectionTimeout清零，不会触发；</li>
<li>领导者故障，追随者的ElectionTimeout超时发生时，会变成候选者，触发领导人选取；</li>
</ol>
<ul>
<li>候选操作过程：</li>
</ul>
<p>追随者自增当前任期，转换为Candidate，对自己投票，并发起RequestVote RPC，等待下面三种情形发生；</p>
<ol>
<li>获得超过半数服务器的投票，赢得选举，成为领导者；</li>
<li>另一台服务器赢得选举，并接收到对应的心跳，成为追随者；</li>
<li>选举超时，没有任何一台服务器赢得选举，自增当前任期，重新发起选举；</li>
</ol>
<p>注意事项：</p>
<ol>
<li>服务器在一个任期内，最多能给一个候选人投票，采用先到先服务原则；</li>
<li>候选者等待投票时，可能会接收到来自其它声明为领导人的的AppendEntries RPC。如果该领导人的任期（RPC中有）比当前候选人的当前任期要大，则候选人认为该领导人合法，并转换成追随者；如果RPC中的任期小于候选人的当前任期，则候选人拒绝此次RPC，继续保持候选人状态；</li>
<li>候选人既没有赢得选举也没有输掉选举：如果许多追随者在同一时刻都成为了候选人，选票会被分散，可能没有候选人能获得大多数的选票。当这种情形发生时，每一个候选人都会超时，并且通过自增任期号和发起另一轮 RequestVote RPC 来开始新的选举。然而，如果没有其它手段来分配选票的话，这种情形可能会无限的重复下去。所以Raft使用的随机的选举超时时间（150~300ms之间），来避免这种情况发生。</li>
</ol>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p><img src="/2018/03/07/distributed-system-raft/raft04.png" alt="img04"><br>接受命令的过程：</p>
<ol>
<li>领导者接受客户端请求；</li>
<li>领导者把指令追加到日志；</li>
<li>发送AppendEntries RPC到追随者；</li>
<li>领导者收到大多数追随者的确认后，领导者Commit该日志，把日志在状态机中回放，并返回结果给客户端；</li>
</ol>
<p>提交过程：</p>
<ol>
<li>在下一个心跳阶段，领导者再次发送AppendEntries RPC给追随者，日志已经commited；</li>
<li>追随者收到Commited日志后，将日志在状态机中回放。</li>
</ol>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令，例如：一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p>
<ol>
<li><p>领导者追加日志（Append-Only)<br>领导者永远不会覆盖已经存在的日志条目；<br>日志永远只有一个流向：从领导者到追随者；</p>
</li>
<li><p>选举限制：投票阻止没有全部日志条目的服务器赢得选举<br>如果投票者的日志比候选人的新，拒绝投票请求；<br>这意味着要赢得选举，候选者的日志至少和大多数服务器的日志一样新，那么它一定包含全部的已经提交的日志条目。</p>
</li>
<li><p>永远不提交任期之前的日志条目（只提交任期内的日志条目）<br>在Raft算法中，当一个日志被安全的复制到绝大多数的机器上面，即AppendEntries RPC在绝大多数服务器正确返回了，那么这个日志就是被提交了，然后领导者会更新commit index。<br><img src="/2018/03/07/distributed-system-raft/raft05.png" alt="img05"></p>
</li>
</ol>
<p>如果允许提交任期之前的日志条目，那么在步骤c中，我们就会把之前任期为2的日志提交到其他服务器中去，并造成了大多数机器存在了日志为2的情况。所以造成了d中S5中任期为3的日志条目会覆盖掉已经提交的日志的情况。</p>
<p>Raft 从来不会通过计算复制的数目来提交之前人气的日志条目。只有领导人当前任期的日志条目才能通过计算数目来进行提交。一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配原则（Log Matching Property），之前的日志条目也都会被间接的提交。</p>
<p>论文中的这段话比较难理解，更加直观的说：由于Raft不会提交任期之前的日志条目，那么就不会从b过渡到c的情况，只能从b发生S5down机的情况下直接过渡到e，这样就产生的更新的任期，这样S5就没有机会被选为领导者了。</p>
<ol>
<li>候选者和追随者崩溃<br>候选者和追随者崩溃的情况处理要简单的多。如果这类角色崩溃了，那么后续发送给他们的 RequestVote和AppendEntries的所有RCP都会失败，Raft算法中处理这类失败就是简单的无限重试的方式。<br>　　如果这些服务器重新可用，那么这些RPC就会成功返回。如果一个服务器完成了一个RPC，但是在响应Leader前崩溃了，那么当他再次可用的时候还会收到相同的RPC请求，此时接收服务器负责检查，比如如果收到了已经包含该条日志的RPC请求，可以直接忽略这个请求，确保对系统是无害的。</li>
</ol>
<h3 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h3><p>集群成员的变更和成员的宕机与重启不同，因为前者会修改成员个数进而影响到领导者的选取和决议过程，因为在分布式系统这对于majority这个集群中成员大多数的概念是极为重要的。</p>
<p>简单的做法是，运维人员将系统临时下线，修改配置，重新上线。但是这种做法存在两个缺点：</p>
<ol>
<li>更改时集群不可用</li>
<li>人为操作失误风险<br>直接从一种配置转到新的配置是十分不安全的<br>如下图所示：<br><img src="/2018/03/07/distributed-system-raft/raft06.png" alt="img06"></li>
</ol>
<p>因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</p>
<p>两阶段方法保证安全性：<br>为了保证安全性，配置更改必须使用两阶段方法。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合。</p>
<p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程人依然响应服务器请求。</p>
<p>一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定。领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。当C-old,new日志条目被提交以后，领导人在使用相同的策略提交C-new，如下图所示，C-old 和 C-new 没有任何机会同时做出单方面的决定，这就保证了安全性。<br><img src="/2018/03/07/distributed-system-raft/raft07.png" alt="img07"></p>
<p>一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的条目，实线表示最后被提交的日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old,new 的大多数和 C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在 C-new 和 C-old 可以同时做出决定的时间点。</p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>日志会随着系统的不断运行会无限制的增长，这会给存储带来压力，几乎所有的分布式系统(Chubby、ZooKeeper)都采用快照的方式进行日志压缩，做完快照之后快照会在稳定持久存储中保存，而快照之前的日志和快照就可以丢弃掉。</p>
<p>Raft的具体做法如下图所示：<br><img src="/2018/03/07/distributed-system-raft/raft08.png" alt="img08"><br>与Raft其它操作Leader-Based不同，snapshot是由各个节点独立生成的。除了日志压缩这一个作用之外，snapshot还可以用于同步状态：slow-follower以及new-server，Raft使用InstallSnapshot RPC完成该过程，不再赘述。</p>
<p>Client交互<br>Client只向领导者发送请求；<br>Client开始会向追随者发送请求，追随者拒绝Client的请求，并重定向到领导者；<br>Client请求失败，会超时重新发送请求；<br>Raft算法要求Client的请求线性化，防止请求被多次执行。有两个解决方案：</p>
<p>Raft算法提出要求每个请求有个唯一标识；<br>Raft的请求保持幂等性；</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/28/os-memory-management/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/28/os-memory-management/" itemprop="url">
                  内存管理比较:ptmalloc & tcmalloc & jemalloc
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-28T18:02:10+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>系统的物理内存是有限的，而对内存的需求是变化的, 程序的动态性越强，内存管理就越重要，选择合适的内存管理算法会带来明显的性能提升。<br>比如nginx， 它在每个连接accept后会malloc一块内存，作为整个连接生命周期内的内存池。 当HTTP请求到达的时候，又会malloc一块当前请求阶段的内存池, 因此对malloc的分配速度有一定的依赖关系。(而apache的内存池是有父子关系的，请求阶段的内存池会和连接阶段的使用相同的分配器，如果连接内存池释放则请求阶段的子内存池也会自动释放)。</p>
<p>内存管理可以分为三个层次，自底向上分别是：</p>
<ol>
<li>操作系统内核的内存管理</li>
<li>glibc层使用系统调用维护的内存管理算法</li>
<li>应用程序从glibc动态分配内存后，根据应用程序本身的程序特性进行优化， 比如使用引用计数std::shared_ptr，apache的内存池方式等等。<br>当然应用程序也可以直接使用系统调用从内核分配内存，自己根据程序特性来维护内存，但是会大大增加开发成本。</li>
</ol>
<p>一个优秀的通用内存分配器应具有以下特性:</p>
<ul>
<li>额外的空间损耗尽量少</li>
<li>分配速度尽可能快</li>
<li>尽量避免内存碎片</li>
<li>缓存本地化友好</li>
<li>通用性，兼容性，可移植性，易调试</li>
</ul>
<p>目前大部分服务端程序使用glibc提供的malloc/free系列函数，而glibc使用的ptmalloc2在性能上远远弱后于google的tcmalloc和facebook的jemalloc。 而且后两者只需要使用LD_PRELOAD环境变量启动程序即可，甚至并不需要重新编译。</p>
<h2 id="glibc-ptmalloc2"><a href="#glibc-ptmalloc2" class="headerlink" title="glibc ptmalloc2"></a>glibc ptmalloc2</h2><h3 id="ptmalloc原理"><a href="#ptmalloc原理" class="headerlink" title="ptmalloc原理"></a>ptmalloc原理</h3><h4 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h4><p><img src="/2018/02/28/os-memory-management/os_mem_manage01.png" alt="os-mem01"></p>
<p>上图是 x86_64 下 Linux 进程的默认地址空间, 对 heap 的操作, 操作系统提供了brk()系统调用，设置了Heap的上边界； 对 mmap 映射区域的操作,操作系 统 供了 mmap()和 munmap()函数。<br>因为系统调用的代价很高，不可能每次申请内存都从内核分配空间，尤其是对于小内存分配。 而且因为mmap的区域容易被munmap释放，所以一般大内存采用mmap()，小内存使用brk()。</p>
<h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h4><ul>
<li>Ptmalloc2有一个主分配区(main arena)， 有多个非主分配区。 非主分配区只能使用mmap向操作系统批发申请HEAP_MAX_SIZE（64位系统为64MB）大小的虚拟内存。 当某个线程调用malloc的时候，会先查看线程私有变量中是否已经存在一个分配区，如果存在则尝试加锁，如果加锁失败则遍历arena链表试图获取一个没加锁的arena， 如果依然获取不到则创建一个新的非主分配区。</li>
<li>free()的时候也要获取锁。分配小块内存容易产生碎片，ptmalloc在整理合并的时候也要对arena做加锁操作。在线程多的时候，锁的开销就会增大。</li>
</ul>
<h4 id="ptmalloc内存管理"><a href="#ptmalloc内存管理" class="headerlink" title="ptmalloc内存管理"></a>ptmalloc内存管理</h4><p>用户请求分配的内存在ptmalloc中使用chunk表示， 每个chunk至少需要8个字节额外的开销。 用户free掉的内存不会马上归还操作系统，ptmalloc会统一管理heap和mmap区域的空闲chunk，避免了频繁的系统调用。<br>ptmalloc 将相似大小的 chunk 用双向链表链接起来, 这样的一个链表被称为一个 bin。Ptmalloc 一共 维护了 128 个 bin,并使用一个数组来存储这些 bin(如下图所示)。<br><img src="/2018/02/28/os-memory-management/os_mem_manage02.png" alt="os-mem02"><br>数组中的第一个为 unsorted bin, 数组中从 2 开始编号的前 64 个 bin 称为 small bins, 同一个small bin中的chunk具有相同的大小。small bins后面的bin被称作large bins。</p>
<ul>
<li>当free一个chunk并放入bin的时候， ptmalloc 还会检查它前后的 chunk 是否也是空闲的, 如果是的话,ptmalloc会首先把它们合并为一个大的 chunk, 然后将合并后的 chunk 放到 unstored bin 中。 另外ptmalloc 为了提高分配的速度,会把一些小的(不大于64B) chunk先放到一个叫做 fast bins 的容器内。</li>
<li>在fast bins和bins都不能满足需求后，ptmalloc会设法在一个叫做top chunk的空间分配内存。 对于非主分配区会预先通过mmap分配一大块内存作为top chunk， 当bins和fast bins都不能满足分配需要的时候, ptmalloc会设法在top chunk中分出一块内存给用户, 如果top chunk本身不够大, 分配程序会重新mmap分配一块内存chunk, 并将 top chunk 迁移到新的chunk上，并用单链表链接起来。如果free()的chunk恰好 与 top chunk 相邻,那么这两个 chunk 就会合并成新的 top chunk，如果top chunk大小大于某个阈值才还给操作系统。主分配区类似，不过通过sbrk()分配和调整top chunk的大小，只有heap顶部连续内存空闲超过阈值的时候才能回收内存。</li>
<li>需要分配的 chunk 足够大,而且 fast bins 和 bins 都不能满足要求,甚至 top chunk 本身也不能满足分配需求时,ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。</li>
</ul>
<h4 id="ptmalloc分配流程"><a href="#ptmalloc分配流程" class="headerlink" title="ptmalloc分配流程"></a>ptmalloc分配流程</h4><p><img src="/2018/02/28/os-memory-management/os_mem_manage03.png" alt="os-mem03"></p>
<h4 id="ptmalloc的缺陷"><a href="#ptmalloc的缺陷" class="headerlink" title="ptmalloc的缺陷"></a>ptmalloc的缺陷</h4><ul>
<li>后分配的内存先释放,因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放。</li>
<li>多线程锁开销大， 需要避免多线程频繁分配释放。</li>
<li>内存从thread的areana中分配， 内存不能从一个arena移动到另一个arena， 就是说如果多线程使用内存不均衡，容易导致内存的浪费。 比如说线程1使用了300M内存，完成任务后glibc没有释放给操作系统，线程2开始创建了一个新的arena， 但是线程1的300M却不能用了。</li>
<li>每个chunk至少8字节的开销很大</li>
<li>不定期分配长生命周期的内存容易造成内存碎片，不利于回收。 64位系统最好分配32M以上内存，这是使用mmap的阈值。</li>
</ul>
<h2 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a>tcmalloc</h2><p>tcmalloc是Google开源的一个内存管理库， 作为glibc malloc的替代品。目前已经在chrome、safari等知名软件中运用。<br>根据官方测试报告，ptmalloc在一台2.8GHz的P4机器上（对于小对象）执行一次malloc及free大约需要300纳秒。而TCMalloc的版本同样的操作大约只需要50纳秒。</p>
<h3 id="小对象分配"><a href="#小对象分配" class="headerlink" title="小对象分配"></a>小对象分配</h3><p>tcmalloc为每个线程分配了一个线程本地ThreadCache，小内存从ThreadCache分配，此外还有个中央堆（CentralCache），ThreadCache不够用的时候，会从CentralCache中获取空间放到ThreadCache中。<br>小对象（&lt;=32K）从ThreadCache分配，大对象从CentralCache分配。大对象分配的空间都是4k页面对齐的，多个pages也能切割成多个小对象划分到ThreadCache中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage04.png" alt="os-mem04"><br>小对象有将近170个不同的大小分类(class)，每个class有个该大小内存块的FreeList单链表，分配的时候先找到best fit的class，然后无锁的获取该链表首元素返回。如果链表中无空间了，则到CentralCache中划分几个页面并切割成该class的大小，放入链表中。</p>
<h3 id="CentralCache分配管理"><a href="#CentralCache分配管理" class="headerlink" title="CentralCache分配管理"></a>CentralCache分配管理</h3><ul>
<li>大对象(&gt;32K)先4k对齐后，从CentralCache中分配。 CentralCache维护的PageHeap如下图所示， 数组中第256个元素是所有大于255个页面都挂到该链表中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage05.png" alt="os-mem05"></li>
<li>当best fit的页面链表中没有空闲空间时，则一直往更大的页面空间则，如果所有256个链表遍历后依然没有成功分配。 则使用sbrk, mmap, /dev/mem从系统中分配。</li>
<li>tcmalloc PageHeap管理的连续的页面被称为span.<br>如果span未分配， 则span是PageHeap中的一个链表元素<br>如果span已经分配，它可能是返回给应用程序的大对象， 或者已经被切割成多小对象，该小对象的size-class会被记录在span中</li>
<li>在32位系统中，使用一个中央数组(central array)映射了页面和span对应关系， 数组索引号是页面号，数组元素是页面所在的span。 在64位系统中，使用一个3-level radix tree记录了该映射关系。</li>
</ul>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><ul>
<li>当一个object free的时候，会根据地址对齐计算所在的页面号，然后通过central array找到对应的span。</li>
<li>如果是小对象，span会告诉我们他的size class，然后把该对象插入当前线程的ThreadCache中。如果此时ThreadCache超过一个预算的值（默认2MB），则会使用垃圾回收机制把未使用的object从ThreadCache移动到CentralCache的central free lists中。</li>
<li>如果是大对象，span会告诉我们对象锁在的页面号范围。 假设这个范围是[p,q]， 先查找页面p-1和q+1所在的span，如果这些临近的span也是free的，则合并到[p,q]所在的span， 然后把这个span回收到PageHeap中。</li>
<li>CentralCache的central free lists类似ThreadCache的FreeList，不过它增加了一级结构，先根据size-class关联到spans的集合， 然后是对应span的object链表。如果span的链表中所有object已经free， 则span回收到PageHeap中。</li>
</ul>
<h3 id="tcmalloc的改进"><a href="#tcmalloc的改进" class="headerlink" title="tcmalloc的改进"></a>tcmalloc的改进</h3><ul>
<li>ThreadCache会阶段性的回收内存到CentralCache里。 解决了ptmalloc2中arena之间不能迁移的问题。</li>
<li>Tcmalloc占用更少的额外空间。例如，分配N个8字节对象可能要使用大约8N * 1.01字节的空间。即，多用百分之一的空间。Ptmalloc2使用最少8字节描述一个chunk。</li>
<li>更快。小对象几乎无锁， &gt;32KB的对象从CentralCache中分配使用自旋锁。 并且&gt;32KB对象都是页面对齐分配，多线程的时候应尽量避免频繁分配，否则也会造成自旋锁的竞争和页面对齐造成的浪费。</li>
</ul>
<h2 id="Jemalloc"><a href="#Jemalloc" class="headerlink" title="Jemalloc"></a>Jemalloc</h2><p>jemalloc是facebook推出的， 最早的时候是freebsd的libc malloc实现。 目前在firefox、facebook服务器各种组件中大量使用。</p>
<h3 id="jemalloc原理"><a href="#jemalloc原理" class="headerlink" title="jemalloc原理"></a>jemalloc原理</h3><ul>
<li>与tcmalloc类似，每个线程同样在&lt;32KB的时候无锁使用线程本地cache。</li>
<li>Jemalloc在64bits系统上使用下面的size-class分类：<ul>
<li>Small: [8], [16, 32, 48, …, 128], [192, 256, 320, …, 512], [768, 1024, 1280, …, 3840]</li>
<li>Large: [4 KiB, 8 KiB, 12 KiB, …, 4072 KiB] </li>
<li>Huge: [4 MiB, 8 MiB, 12 MiB, …]</li>
</ul>
</li>
<li>small/large对象查找metadata需要常量时间， huge对象通过全局红黑树在对数时间内查找。</li>
<li>虚拟内存被逻辑上分割成chunks（默认是4MB，1024个4k页），应用线程通过round-robin算法在第一次malloc的时候分配arena， 每个arena都是相互独立的，维护自己的chunks， chunk切割pages到small/large对象。free()的内存总是返回到所属的arena中，而不管是哪个线程调用free()。<br><img src="/2018/02/28/os-memory-management/os_mem_manage06.png" alt="os-mem06"><br>上图可以看到每个arena管理的arena chunk结构， 开始的header主要是维护了一个page map（1024个页面关联的对象状态）， header下方就是它的页面空间。 Small对象被分到一起， metadata信息存放在起始位置。 large chunk相互独立，它的metadata信息存放在chunk header map中。<ul>
<li>通过arena分配的时候需要对arena bin（每个small size-class一个，细粒度）加锁，或arena本身加锁。<br>并且线程cache对象也会通过垃圾回收指数退让算法返回到arena中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage07.png" alt="os-mem07"></li>
</ul>
</li>
</ul>
<h3 id="jemalloc的优化"><a href="#jemalloc的优化" class="headerlink" title="jemalloc的优化"></a>jemalloc的优化</h3><ul>
<li>Jmalloc小对象也根据size-class，但是它使用了低地址优先的策略，来降低内存碎片化。</li>
<li>Jemalloc大概需要2%的额外开销。（tcmalloc 1%， ptmalloc最少8B）</li>
<li>Jemalloc和tcmalloc类似的线程本地缓存，避免锁的竞争</li>
<li>相对未使用的页面，优先使用dirty page，提升缓存命中。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>jemalloc <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919" target="_blank" rel="external">https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919</a></li>
<li>tcmalloc <a href="https://yq.aliyun.com/articles/6045" target="_blank" rel="external">https://yq.aliyun.com/articles/6045</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/27/mysql-index-analysis/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/27/mysql-index-analysis/" itemprop="url">
                  MySQL索引原理剖析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-27T22:52:45+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p>
<p>文章主要内容分为三个部分。</p>
<ul>
<li>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</li>
<li>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</li>
<li>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。</li>
</ul>
<h2 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h2><h3 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是一种数据结构。</p>
<p>数据库查询是数据库的主要功能之一，最基本的查询算法是顺序查找（linear search）时间复杂度为O(n)，显然在数据量很大时效率很低。优化的查找算法如二分查找（binary search）、二叉树查找（binary tree search）等，虽然查找效率提高了。但是各自对检索的数据都有要求：二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织）。所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</p>
<p>看一个例子：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index01.png" alt="pic01"></p>
<p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
<h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h3><p>关于B树和B+树请参考关于B树的一些总结，这篇文章介绍的比较详细，同时容易理解。</p>
<p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<ol>
<li>d&gt;=2，即B-Tree的度；</li>
<li>h为B-Tree的高；</li>
<li>每个非叶子结点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d；</li>
<li>每个叶子结点至少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶结点的指针均为NULL；</li>
<li>所有叶结点都在同一层，深度等于树高h；</li>
<li>key和指针相互间隔，结点两端是指针；</li>
<li>一个结点中的key从左至右非递减排列；</li>
<li>如果某个指针在结点node最左边且不为null，则其指向结点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</li>
<li>如果某个指针在结点node最右边且不为null，则其指向结点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</li>
<li>如果某个指针在结点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向结点的所有key小于v(keyi+1)且大于v(keyi)。<br>图2是一个d=2的B-Tree示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index02.png" alt="pic02"></li>
</ol>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">BTree_Search(node, key) &#123;</div><div class="line">    if(node == null) return null;</div><div class="line">    foreach(node.key)</div><div class="line">    &#123;</div><div class="line">        if(node.key[i] == key) return node.data[i];</div><div class="line">            if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</div><div class="line">    &#125;</div><div class="line">    return BTree_Search(point[i+1]-&gt;node);</div><div class="line">&#125;</div><div class="line">data = BTree_Search(root, my_key);</div></pre></td></tr></table></figure></p>
<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找结点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<ul>
<li>每个结点的指针上限为2d而不是2d+1。</li>
<li>内结点不存储data，只存储key；叶子结点不存储指针。<br>图3是一个简单的B+Tree示意。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index03.png" alt="pic03"></li>
</ul>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶结点和内结点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个结点的域和上限是一致的，所以在实现中B-Tree往往对每个结点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<h4 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h4><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index04.png" alt="pic04"><br>如图4所示，在B+Tree的每个叶子结点增加一个指向相邻叶子结点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着结点和指针顺序遍历就可以一次性访问到所有数据结点，极大提到了区间查询效率。</p>
<p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p>
<h4 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h4><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h4 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h4><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index05.png" alt="pic05"><br>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h4 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h4><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>图6是磁盘的整体结构示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index06.png" alt="pic06"><br>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p>
<p>图7是磁盘结构的示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index07.png" alt="pic07"><br>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>从使用磁盘I/O次数评价索引结构的优劣性：根据B-Tree的定义，可知检索一次最多需要访问h个结点。数据库系统的设计者巧妙的利用了磁盘预读原理，将一个结点的大小设为等于一个页面，这样每个结点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根结点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出读d是非常大的数字，通常超过100，因此h非常小。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树结构，h明显要深得多。由于逻辑上很近的结点（父子结点）物理上可能离得很远，无法利用局部性原理。所以即使红黑树的I/O渐进复杂度也为O(h)，但是查找效率明显比B-Tree差得多。</p>
<p>B+Tree更适合外存索引，是和内结点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于结点内key和data的大小：dmax=floor(pagesize/(keysize+datasize+pointsize))。</p>
<p>floor表示向下取整。由于B+Tree内结点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>
<h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎(MySQL数据库MyISAM和InnoDB存储引擎的比较)的索引实现方式。</p>
<h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶结点的data域存放的是数据记录的地址。下面是MyISAM索引的原理图：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index08.png" alt="pic08"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index09.png" alt="pic09"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做<em>“非聚集”</em>的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶结点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index10.png" alt="pic10"><br>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶结点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index11.png" alt="pic11"><br>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h2 id="聚簇索引-amp-非聚簇索引"><a href="#聚簇索引-amp-非聚簇索引" class="headerlink" title="聚簇索引 &amp; 非聚簇索引"></a>聚簇索引 &amp; 非聚簇索引</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。</li>
<li>非聚簇索引，叶级页指向表中的记录，记录的物理顺序与逻辑顺序没有必然的联系</li>
</ul>
<p>在mysql数据库中，myisam引擎和innodb引擎使用的索引类型不同，myisam对应的是非聚簇索引，而innodb对应的是聚簇索引。聚簇索引也叫复合索引、聚集索引等等。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在聚簇索引中，数据会被按照顺序整理排列，当使用where进行顺序、范围、大小检索时，会大大加速检索效率。非聚簇索引在存储时不会对数据进行排序，相对产生的数据文件体积也比较大。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/26/redis-analysis-sentinel01/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/26/redis-analysis-sentinel01/" itemprop="url">
                  redis-analysis-sentinel01
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-26T03:23:37+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/23/redis-analysis-replicatesource/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/23/redis-analysis-replicatesource/" itemprop="url">
                  Redis源码剖析和注释（二十二）--- Redis 复制(replicate)源码详细解析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T20:08:12+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-复制的介绍"><a href="#1-复制的介绍" class="headerlink" title="1. 复制的介绍"></a>1. 复制的介绍</h2><p>Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="2-复制的实现"><a href="#2-复制的实现" class="headerlink" title="2. 复制的实现"></a>2. 复制的实现</h2><h3 id="2-1-主从关系的建立"><a href="#2-1-主从关系的建立" class="headerlink" title="2.1 主从关系的建立"></a>2.1 主从关系的建立</h3><p>复制的建立方法有三种。</p>
<ol>
<li>在redis.conf文件中配置slaveof <masterip> <masterport>选项，然后指定该配置文件启动Redis生效。</masterport></masterip></li>
<li>在redis-server启动命令后加上–slaveof <masterip> <masterport>启动生效。</masterport></masterip></li>
<li>直接使用 slaveof <masterip> <masterport>命令在从节点执行生效。<br>无论是通过哪一种方式来建立主从复制，都是从节点来执行slaveof命令，那么从节点执行了这个命令到底做了什么，我们上源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// SLAVEOF host port命令实现</div><div class="line">void slaveofCommand(client *c) &#123;</div><div class="line">    // 如果当前处于集群模式，不能进行复制操作</div><div class="line">    if (server.cluster_enabled) &#123;</div><div class="line">        addReplyError(c,&quot;SLAVEOF not allowed in cluster mode.&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // SLAVEOF NO ONE命令使得这个从节点关闭复制功能，并从从节点转变回主节点，原来同步所得的数据集不会被丢弃。</div><div class="line">    if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;no&quot;) &amp;&amp;</div><div class="line">        !strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;one&quot;)) &#123;</div><div class="line">        // 如果保存了主节点IP</div><div class="line">        if (server.masterhost) &#123;</div><div class="line">            // 取消复制操作，设置服务器为主服务器</div><div class="line">            replicationUnsetMaster();</div><div class="line">            // 获取client的每种信息，并以sds形式返回，并打印到日志中</div><div class="line">            sds client = catClientInfoString(sdsempty(),c);</div><div class="line">            serverLog(LL_NOTICE,&quot;MASTER MODE enabled (user request from &apos;%s&apos;)&quot;,</div><div class="line">                client);</div><div class="line">            sdsfree(client);</div><div class="line">        &#125;</div><div class="line">    // SLAVEOF host port</div><div class="line">    &#125; else &#123;</div><div class="line">        long port;</div><div class="line"></div><div class="line">        // 获取端口号</div><div class="line">        if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;port, NULL) != C_OK))</div><div class="line">            return;</div><div class="line"></div><div class="line">        // 如果已存在从属于masterhost主节点且命令参数指定的主节点和masterhost相等，端口也相等，直接返回</div><div class="line">        if (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[1]-&gt;ptr)</div><div class="line">            &amp;&amp; server.masterport == port) &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.&quot;);</div><div class="line">            addReplySds(c,sdsnew(&quot;+OK Already connected to specified master\r\n&quot;));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 第一次执行设置端口和ip，或者是重新设置端口和IP</div><div class="line">        // 设置服务器复制操作的主节点IP和端口</div><div class="line">        replicationSetMaster(c-&gt;argv[1]-&gt;ptr, port);</div><div class="line">        // 获取client的每种信息，并以sds形式返回，并打印到日志中</div><div class="line">        sds client = catClientInfoString(sdsempty(),c);</div><div class="line">        serverLog(LL_NOTICE,&quot;SLAVE OF %s:%d enabled (user request from &apos;%s&apos;)&quot;,</div><div class="line">            server.masterhost, server.masterport, client);</div><div class="line">        sdsfree(client);</div><div class="line">    &#125;</div><div class="line">    // 回复ok</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</masterport></masterip></li>
</ol>
<p>当从节点的client执行SLAVEOF命令后，该命令会被构建成Redis协议格式，发送给从节点服务器，然后节点服务器会调用slaveofCommand()函数执行该命令。</p>
<p>而SLAVEOF命令做的操作并不多，主要以下三步：</p>
<ul>
<li>判断当前环境是否在集群模式下，因为集群模式下不行执行该命令。</li>
<li>是否执行的是SLAVEOF NO ONE命令，该命令会断开主从的关系，设置当前节点为主节点服务器。</li>
<li>设置从节点所属主节点的IP和port。调用了replicationSetMaster()函数。</li>
</ul>
<p>SLAVEOF命令能做的只有这么多，我们来具体看下replicationSetMaster()函数的代码，看看它做了哪些与复制相关的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 设置复制操作的主节点IP和端口</div><div class="line">void replicationSetMaster(char *ip, int port) &#123;</div><div class="line">    // 按需清除原来的主节点信息</div><div class="line">    sdsfree(server.masterhost);</div><div class="line">    // 设置ip和端口</div><div class="line">    server.masterhost = sdsnew(ip);</div><div class="line">    server.masterport = port;</div><div class="line">    // 如果有其他的主节点，在释放</div><div class="line">    // 例如服务器1是服务器2的主节点，现在服务器2要同步服务器3，服务器3要成为服务器2的主节点，因此要释放服务器1</div><div class="line">    if (server.master) freeClient(server.master);</div><div class="line">    // 解除所有客户端的阻塞状态</div><div class="line">    disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */</div><div class="line">    // 关闭所有从节点服务器的连接，强制从节点服务器进行重新同步操作</div><div class="line">    disconnectSlaves(); /* Force our slaves to resync with us as well. */</div><div class="line">    // 释放主节点结构的缓存，不会执行部分重同步PSYNC</div><div class="line">    replicationDiscardCachedMaster(); /* Don&apos;t try a PSYNC. */</div><div class="line">    // 释放复制积压缓冲区</div><div class="line">    freeReplicationBacklog(); /* Don&apos;t allow our chained slaves to PSYNC. */</div><div class="line">    // 取消执行复制操作</div><div class="line">    cancelReplicationHandshake();</div><div class="line">    // 设置复制必须重新连接主节点的状态</div><div class="line">    server.repl_state = REPL_STATE_CONNECT;</div><div class="line">    // 初始化复制的偏移量</div><div class="line">    server.master_repl_offset = 0;</div><div class="line">    // 清零连接断开的时长</div><div class="line">    server.repl_down_since = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由代码知，replicationSetMaster()函数执行操作的也很简单，总结为两步：</p>
<ul>
<li>清理之前所属的主节点的信息。</li>
<li>设置新的主节点IP和port等。<br>因为，当前从节点有可能之前从属于另外的一个主节点服务器，因此要清理所有关于之前主节点的缓存、关闭旧的连接等等。然后设置该从节点的新主节点，设置了IP和port，还设置了以下状态：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 设置复制必须重新连接主节点的状态</div><div class="line">server.repl_state = REPL_STATE_CONNECT;</div><div class="line">// 初始化全局复制的偏移量</div><div class="line">server.master_repl_offset = 0;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后，就没有然后了，然后就会执行复制操作吗？这也没有什么关于复制的操作执行了，那么复制操作是怎么开始的呢？</p>
<h3 id="2-2-主从网络连接建立"><a href="#2-2-主从网络连接建立" class="headerlink" title="2.2 主从网络连接建立"></a>2.2 主从网络连接建立</h3><p>slaveof命令是一个异步命令，执行命令时，从节点保存主节点的信息，确立主从关系后就会立即返回，后续的复制流程在节点内部异步执行。那么，如何触发复制的执行呢？</p>
<p>周期性执行的函数：replicationCron()函数，该函数被服务器的时间事件的回调函数serverCron()所调用，而serverCron()函数在Redis服务器初始化时，被设置为时间事件的处理函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// void initServer(void) Redis服务器初始化</div><div class="line">aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL)</div></pre></td></tr></table></figure></p>
<p>replicationCron()函数执行频率为1秒一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 节选自serverCron函数</div><div class="line">// 周期性执行复制的任务</div><div class="line">run_with_period(1000) replicationCron();</div></pre></td></tr></table></figure></p>
<p>主从关系建立后，从节点服务器的server.repl_state被设置为REPL_STATE_CONNECT，而replicationCron()函数会被每秒执行一次，该函数会发现我（从节点）现在有主节点了，而且我要的状态是要连接主节点（REPL_STATE_CONNECT）。</p>
<p>replicationCron()函数处理这以情况的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* Check if we should connect to a MASTER */</div><div class="line">// 如果处于要必须连接主节点的状态，尝试连接</div><div class="line">if (server.repl_state == REPL_STATE_CONNECT) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Connecting to MASTER %s:%d&quot;,</div><div class="line">        server.masterhost, server.masterport);</div><div class="line">    // 以非阻塞的方式连接主节点</div><div class="line">    if (connectWithMaster() == C_OK) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;MASTER &lt;-&gt; SLAVE sync started&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>replicationCron()函数根据从节点的状态，调用connectWithMaster()非阻塞连接主节点。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 以非阻塞的方式连接主节点</div><div class="line">int connectWithMaster(void) &#123;</div><div class="line">    int fd;</div><div class="line"></div><div class="line">    // 连接主节点</div><div class="line">    fd = anetTcpNonBlockBestEffortBindConnect(NULL,</div><div class="line">        server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);</div><div class="line">    if (fd == -1) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to connect to MASTER: %s&quot;,</div><div class="line">            strerror(errno));</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 监听主节点fd的可读和可写事件的发生，并设置其处理程序为syncWithMaster</div><div class="line">    if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) == AE_ERR)</div><div class="line">    &#123;</div><div class="line">        close(fd);</div><div class="line">        serverLog(LL_WARNING,&quot;Can&apos;t create readable event for SYNC&quot;);</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 最近一次读到RDB文件内容的时间</div><div class="line">    server.repl_transfer_lastio = server.unixtime;</div><div class="line">    // 从节点和主节点的同步套接字</div><div class="line">    server.repl_transfer_s = fd;</div><div class="line">    // 处于和主节点正在连接的状态</div><div class="line">    server.repl_state = REPL_STATE_CONNECTING;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>connectWithMaster()函数执行的操作可以总结为：</p>
<ul>
<li>根据IP和port非阻塞的方式连接主节点，得到主从节点进行通信的文件描述符fd，并保存到从节点服务器server.repl_transfer_s中，并且将刚才的REPL_STATE_CONNECT状态设置为REPL_STATE_CONNECTING。</li>
<li>监听fd的可读和可写事件，并且设置事件发生的处理程序syncWithMaster()函数。<br>至此，主从网络建立就完成了。</li>
</ul>
<h3 id="2-3-发送PING命令"><a href="#2-3-发送PING命令" class="headerlink" title="2.3 发送PING命令"></a>2.3 发送PING命令</h3><p>主从建立网络时，同时注册fd的AE_READABLE|AE_WRITABLE事件，因此会触发一个AE_WRITABLE事件，调用syncWithMaster()函数，处理写事件。</p>
<p>根据当前的REPL_STATE_CONNECTING状态，从节点向主节点发送PING命令，PING命令的目的有：</p>
<ul>
<li>检测主从节点之间的网络是否可用。</li>
<li>检查主从节点当前是否接受处理命令。<br>syncWithMaster()函数中相关操作的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Send a PING to check the master is able to reply without errors. */</div><div class="line">// 如果复制的状态为REPL_STATE_CONNECTING，发送一个PING去检查主节点是否能正确回复一个PONG</div><div class="line">if (server.repl_state == REPL_STATE_CONNECTING) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Non blocking connect for SYNC fired the event.&quot;);</div><div class="line">    // 暂时取消接听fd的写事件，以便等待PONG回复时，注册可读事件</div><div class="line">    aeDeleteFileEvent(server.el,fd,AE_WRITABLE);</div><div class="line">    // 设置复制状态为等待PONG回复</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</div><div class="line">    // 发送一个PING命令</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PING&quot;,NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>发送PING命令主要的操作是：</p>
<ul>
<li>先取消监听fd的写事件，因为接下来要读主节点服务器发送过来的PONG回复，因此只监听可读事件的发生。</li>
<li>设置从节点的复制状态为REPL_STATE_RECEIVE_PONG。等待一个主节点回复一个PONG命令。</li>
<li>以写的方式调用sendSynchronousCommand()函数发送一个PING命令给主节点。<br>主节点服务器从fd会读到一个PING命令，然后会回复一个PONG命令到fd中，执行的命令就是addReply(c,shared.pong);。</li>
</ul>
<p>此时，会触发fd的可读事件，调用syncWithMaster()函数来处理，此时从节点的复制状态为REPL_STATE_RECEIVE_PONG，等待主节点回复PONG。syncWithMaster()函数中处理这一状态的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/* Receive the PONG command. */</div><div class="line">// 如果复制的状态为REPL_STATE_RECEIVE_PONG，等待接受PONG命令</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</div><div class="line">   // 从主节点读一个PONG命令sendSynchronousCommand</div><div class="line">   err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line"></div><div class="line">    // 只接受两种有效的回复。一种是 &quot;+PONG&quot;，一种是认证错误&quot;-NOAUTH&quot;。</div><div class="line">    // 旧版本的返回有&quot;-ERR operation not permitted&quot;</div><div class="line">    if (err[0] != &apos;+&apos; &amp;&amp;</div><div class="line">        strncmp(err,&quot;-NOAUTH&quot;,7) != 0 &amp;&amp;</div><div class="line">        strncmp(err,&quot;-ERR operation not permitted&quot;,28) != 0)</div><div class="line">    &#123;   // 没有收到正确的PING命令的回复</div><div class="line">        serverLog(LL_WARNING,&quot;Error reply to PING from master: &apos;%s&apos;&quot;,err);</div><div class="line">        sdsfree(err);</div><div class="line">        goto error;</div><div class="line">     &#125; else &#123;</div><div class="line">       serverLog(LL_NOTICE,&quot;Master replied to PING, replication can continue...&quot;);</div><div class="line">     &#125;</div><div class="line">     sdsfree(err);</div><div class="line">     // 已经收到PONG，更改状态设置为发送认证命令AUTH给主节点</div><div class="line">     server.repl_state = REPL_STATE_SEND_AUTH;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，以读的方式调用sendSynchronousCommand()，并将读到的”+PONG\r\n”返回到err中，如果从节点正确接收到主节点发送的PONG命令，会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_AUTH。等待进行权限的认证。</p>
<h3 id="2-4-认证权限"><a href="#2-4-认证权限" class="headerlink" title="2.4 认证权限"></a>2.4 认证权限</h3><p>权限认证会在syncWithMaster()函数继续执行，紧接着刚才的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* AUTH with the master if required. */</div><div class="line">// 如果需要，发送AUTH认证给主节点</div><div class="line">if (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</div><div class="line">   // 如果服务器设置了认证密码</div><div class="line">   if (server.masterauth) &#123;</div><div class="line">        // 写AUTH给主节点</div><div class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;AUTH&quot;,server.masterauth,NULL);</div><div class="line">        if (err) goto write_error;</div><div class="line">        // 设置状态为等待接受认证回复</div><div class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</div><div class="line">        return;</div><div class="line">    // 如果没有设置认证密码，直接设置复制状态为发送端口号给主节点</div><div class="line">    &#125; else &#123;</div><div class="line">        server.repl_state = REPL_STATE_SEND_PORT;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果从节点的服务器设置了认证密码，则会以写方式调用sendSynchronousCommand()函数，将AUTH命令和密码写到fd中，并且将从节点的复制状态设置为server.repl_state = REPL_STATE_RECEIVE_AUTH，接受AUTH的验证。</p>
<p>如果从节点服务器没有设置认证密码，就直接将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_PORT，准发发送一个端口号。</p>
<p>主节点会读取到AUTH命令，调用authCommand()函数来处理，主节点服务器会比较从节点发送过来的server.masterauth和主节点服务器保存的server.requirepass是否一致，如果一致，会回复一个”+OK\r\n”。</p>
<p>当主节点将回复写到fd时，又会触发从节点的可读事件，紧接着调用syncWithMaster()函数来处理接收AUTH认证结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Receive AUTH reply. */</div><div class="line">// 接受AUTH认证的回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</div><div class="line">    // 从主节点读回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 回复错误，认证失败</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to AUTH to MASTER: %s&quot;,err);</div><div class="line">        sdsfree(err);</div><div class="line">        goto error;</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送端口号给主节点</div><div class="line">    server.repl_state = REPL_STATE_SEND_PORT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以读方式从fd中读取一个回复，判断认证是否成功，认证成功，则会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_PORT表示要发送一个端口号给主节点。这和没有设置认证的情况结果相同。</p>
<h3 id="2-5-发送端口号"><a href="#2-5-发送端口号" class="headerlink" title="2.5 发送端口号"></a>2.5 发送端口号</h3><p>从节点在认证完权限后，会继续在syncWithMaster()函数执行，处理发送端口号的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Set the slave port, so that Master&apos;s INFO command can list the</div><div class="line"> * slave listening port correctly. */</div><div class="line">// 如果复制状态是，发送从节点端口号给主节点，主节点的INFO命令就能够列出从节点正在监听的端口号</div><div class="line">if (server.repl_state == REPL_STATE_SEND_PORT) &#123;</div><div class="line">    // 获取端口号</div><div class="line">    sds port = sdsfromlonglong(server.slave_announce_port ?</div><div class="line">        server.slave_announce_port : server.port);</div><div class="line">    // 将端口号写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;listening-port&quot;,port, NULL);</div><div class="line">    sdsfree(port);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受端口号</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发送端口号，以REPLCONF listening-port命令的方式，写到fd中。然后将复制状态设置为server.repl_state = REPL_STATE_RECEIVE_PORT，等待接受主节点的回复。</p>
<p>主节点从fd中读到REPLCONF listening-port <port>命令，调用replconfCommand()命令来处理，而replconfCommand()函数的定义就在replication.c文件中，REPLCONF命令可以设置多种不同的选项，解析到端口号后，将端口号保存从节点对应client状态的c-&gt;slave_listening_port = port中。最终回复一个”+OK\r\n”状态的回复，写在fd中。</port></p>
<p>当主节点将回复写到fd时，又会触发从节点的可读事件，紧接着调用syncWithMaster()函数来处理接受端口号，验证主节点是否正确的接收到从节点的端口号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Receive REPLCONF listening-port reply. */</div><div class="line">// 复制状态为接受端口号</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</div><div class="line">    // 从主节点读取端口号</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    /* Ignore the error if any, not all the Redis versions support</div><div class="line">     * REPLCONF listening-port. */</div><div class="line">    // 忽略所有的错误，因为不是所有的Redis版本都支持REPLCONF listening-port命令</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF listening-port: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送IP</div><div class="line">    server.repl_state = REPL_STATE_SEND_IP;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确的接收到从节点的端口号，会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_IP表示要送一个IP给主节点。</p>
<h3 id="2-6-发送-IP-地址"><a href="#2-6-发送-IP-地址" class="headerlink" title="2.6 发送 IP 地址"></a>2.6 发送 IP 地址</h3><p>从节点发送完端口号并且正确收到主节点的回复后，紧接着syncWithMaster()函数执行发送IP的代码。发送IP和发送端口号过程几乎一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送IP</div><div class="line">if (server.repl_state == REPL_STATE_SEND_IP) &#123;</div><div class="line">    // 将IP写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;ip-address&quot;,server.slave_announce_ip, NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受IP</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样是以REPLCONF ip-address命令的方式，将从节点的IP写到fd中。并且设置从节点的复制状态为server.repl_state = REPL_STATE_RECEIVE_IP，等待接受主节点的回复。然后就直接返回，等待fd可读发生。</p>
<p>主节点仍然会调用replication.c文件中实现的replconfCommand()函数来处理REPLCONF命令，解析出REPLCONF ip-address ip命令，保存从节点的ip到主节点的对应从节点的client的c-&gt;slave_ip中。然后回复”+OK\r\n”状态，写到fd中。</p>
<p>此时，从节点监听到fd触发了可读事件，会调用syncWithMaster()函数来处理，验证主节点是否正确接收到从节点的IP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Receive REPLCONF ip-address reply. */</div><div class="line">// 复制状态为接受IP回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</div><div class="line">    // 从主节点读一个IP回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 错误回复</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF ip-address: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送一个capa（能力？能否解析出RDB文件的EOF流格式）</div><div class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确接收了从节点IP，就会设置从节点的复制状态server.repl_state = REPL_STATE_SEND_CAPA表示发送从节点的能力（capability）。</p>
<h3 id="2-7-发送能力（capability）"><a href="#2-7-发送能力（capability）" class="headerlink" title="2.7 发送能力（capability）"></a>2.7 发送能力（capability）</h3><p>发送能力和发送端口和IP也是如出一辙，紧接着syncWithMaster()函数执行发送capa的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送capa，通知主节点从节点的能力</div><div class="line">if (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</div><div class="line">    // 将从节点的capa写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;capa&quot;,&quot;eof&quot;,NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受从节点的capa</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从节点将REPLCONF capa eof命令发送给主节点，写到fd中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">目前只支持一种能力，就是能够解析出RDB文件的EOF流格式。用于无盘复制的方式中。</div></pre></td></tr></table></figure></p>
<p>主节点仍然会调用replication.c文件中实现的replconfCommand()函数来处理REPLCONF命令，解析出REPLCONF capa eof命令，将eof对应的标识，按位与到主节点的对应从节点的client的c-&gt;slave_capa中。然后回复”+OK\r\n”状态，写到fd中。</p>
<p>此时，从节点监听到fd触发了可读事件，会调用syncWithMaster()函数来处理，验证主节点是否正确接收到从节点的capa。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Receive CAPA reply. */</div><div class="line">// 复制状态为接受从节点的capa回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</div><div class="line">    // 从主节点读取capa回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 错误回复</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF capa: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送PSYNC命令</div><div class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确接收了从节点capa，就会设置从节点的复制状态server.repl_state = REPL_STATE_SEND_PSYNC表示发送一个PSYNC命令</p>
<h3 id="2-8-发送PSYNC命令"><a href="#2-8-发送PSYNC命令" class="headerlink" title="2.8 发送PSYNC命令"></a>2.8 发送PSYNC命令</h3><p>从节点发送PSYNC命令给主节点，尝试进行同步主节点的数据集。同步分为两种：</p>
<ul>
<li>全量同步：第一次执行复制的场景。</li>
<li>部分同步：用于主从复制因为网络中断等原因造成数据丢失的场景。<br>因为这是第一次执行同步，因此会进行全量同步。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送PSYNC命令。尝试进行部分重同步。</div><div class="line">// 如果没有缓冲主节点的结构，slaveTryPartialResynchronization()函数将会至少尝试使用PSYNC去进行一个全同步，这样就能得到主节点的运行runid和全局复制偏移量。并且在下次重连接时可以尝试进行部分重同步。</div><div class="line">if (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</div><div class="line">    // 向主节点发送一个部分重同步命令PSYNC，参数0表示不读主节点的回复，只获取主节点的运行runid和全局复制偏移量</div><div class="line">    if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) &#123;</div><div class="line">        // 发送PSYNC出错</div><div class="line">        err = sdsnew(&quot;Write error sending the PSYNC command.&quot;);</div><div class="line">        goto write_error;</div><div class="line">    &#125;</div><div class="line">    // 设置复制状态为等待接受一个PSYNC回复</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从节点调用slaveTryPartialResynchronization()函数尝试进行重同步，注意第二个参数是0。因为slaveTryPartialResynchronization()分成两部分，一部分是写，一部分是读，因为第二个参数是0，因此执行写的一部分，发送一个PSYNC命令给主节点。只列举出写的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* Writing half */</div><div class="line">// 如果read_reply为0，则该函数往socket上会写入一个PSYNC命令</div><div class="line">if (!read_reply) &#123;</div><div class="line">    // 将repl_master_initial_offset设置为-1表示主节点的run_id和全局复制偏移量是无效的。</div><div class="line">    // 如果能使用PSYNC命令执行一个全量同步，会正确设置全复制偏移量，以便这个信息被正确传播主节点的所有从节点中</div><div class="line">    server.repl_master_initial_offset = -1;</div><div class="line"></div><div class="line">    // 主节点的缓存不为空，可以尝试进行部分重同步。PSYNC &lt;master_run_id&gt; &lt;repl_offset&gt;</div><div class="line">    if (server.cached_master) &#123;</div><div class="line">        // 保存缓存runid</div><div class="line">        psync_runid = server.cached_master-&gt;replrunid;</div><div class="line">        // 获取已经复制的偏移量</div><div class="line">        snprintf(psync_offset,sizeof(psync_offset),&quot;%lld&quot;, server.cached_master-&gt;reploff+1);</div><div class="line">        serverLog(LL_NOTICE,&quot;Trying a partial resynchronization (request %s:%s).&quot;, psync_runid, psync_offset);</div><div class="line">    // 主节点的缓存为空，发送PSYNC ? -1。请求全量同步</div><div class="line">    &#125; else &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;Partial resynchronization not possible (no cached master)&quot;);</div><div class="line">        psync_runid = &quot;?&quot;;</div><div class="line">        memcpy(psync_offset,&quot;-1&quot;,3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Issue the PSYNC command */</div><div class="line">    // 发送一个PSYNC命令给主节点</div><div class="line">    reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PSYNC&quot;,psync_runid,psync_offset,NULL);</div><div class="line">    // 写成功失败会返回一个&quot;-&quot;开头的字符串</div><div class="line">    if (reply != NULL) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to send PSYNC to master: %s&quot;,reply);</div><div class="line">        sdsfree(reply);</div><div class="line">        // 删除文件的可读事件，返回写错误PSYNC_WRITE_ERROR</div><div class="line">        aeDeleteFileEvent(server.el,fd,AE_READABLE);</div><div class="line">        return PSYNC_WRITE_ERROR;</div><div class="line">    &#125;</div><div class="line">    // 返回等待回复的标识PSYNC_WAIT_REPLY，调用者会将read_reply设置为1，然后再次调用该函数，执行下面的读部分。</div><div class="line">    return PSYNC_WAIT_REPLY;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于从节点是第一次和主节点进行同步操作，因此从节点缓存的主节点client状态erver.cached_master为空，所以就会发送一个PSYNC ? -1命令给主节点，表示进行一次全量同步。</p>
<p>主节点会接收到PSYNC ? -1命令，然后调用replication.c文件中实现的syncCommand()函数处理PSYNC命令。</p>
<p>syncCommand()函数先会判断执行的是PSYNC还是SYNC命令，如果是PSYNC命令会调用masterTryPartialResynchronization()命令执行部分同步，但是由于这是第一次执行复制操作，所以会执行失败。进而执行全量同步。</p>
<p>syncCommand()函数的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">/* SYNC and PSYNC command implemenation. */</div><div class="line">// SYNC and PSYNC 命令实现</div><div class="line">void syncCommand(client *c) &#123;</div><div class="line">    ..........//为了简洁，删除一些判断条件的代码</div><div class="line"></div><div class="line">    // 尝试执行一个部分同步PSYNC的命令，则masterTryPartialResynchronization()会回复一个 &quot;+FULLRESYNC &lt;runid&gt; &lt;offset&gt;&quot;,如果失败则执行全量同步</div><div class="line">    // 所以，从节点会如果和主节点连接断开，从节点会知道runid和offset，随后会尝试执行PSYNC</div><div class="line">    // 如果是执行PSYNC命令</div><div class="line">    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;psync&quot;)) &#123;</div><div class="line">        // 主节点尝试执行部分重同步，执行成功返回C_OK</div><div class="line">        if (masterTryPartialResynchronization(c) == C_OK) &#123;</div><div class="line">            // 可以执行PSYNC命令，则将接受PSYNC命令的个数加1</div><div class="line">            server.stat_sync_partial_ok++;</div><div class="line">            // 不需要执行后面的全量同步，直接返回</div><div class="line">            return; /* No full resync needed, return. */</div><div class="line">        // 不能执行PSYNC部分重同步，需要进行全量同步</div><div class="line">        &#125; else &#123;</div><div class="line">            char *master_runid = c-&gt;argv[1]-&gt;ptr;</div><div class="line">            // 从节点以强制全量同步为目的，所以不能执行部分重同步，因此增加PSYNC命令失败的次数</div><div class="line">            if (master_runid[0] != &apos;?&apos;) server.stat_sync_partial_err++;</div><div class="line">        &#125;</div><div class="line">    // 执行SYNC命令</div><div class="line">    &#125; else &#123;</div><div class="line">        // 设置标识，执行SYNC命令，不接受REPLCONF ACK</div><div class="line">        c-&gt;flags |= CLIENT_PRE_PSYNC;</div><div class="line">    &#125;</div><div class="line">    // 全量重同步次数加1</div><div class="line">    server.stat_sync_full++;</div><div class="line"></div><div class="line">    // 设置client状态为：从服务器节点等待BGSAVE节点的开始</div><div class="line">    c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</div><div class="line">    // 执行SYNC命令后是否关闭TCP_NODELAY</div><div class="line">    if (server.repl_disable_tcp_nodelay)</div><div class="line">        // 是的话，则启用nagle算法</div><div class="line">        anetDisableTcpNoDelay(NULL, c-&gt;fd); /* Non critical if it fails. */</div><div class="line">    // 保存主服务器传来的RDB文件的fd，设置为-1</div><div class="line">    c-&gt;repldbfd = -1;</div><div class="line">    // 设置client状态为从节点，标识client是一个从服务器</div><div class="line">    c-&gt;flags |= CLIENT_SLAVE;</div><div class="line">    // 添加到服务器从节点链表中</div><div class="line">    listAddNodeTail(server.slaves,c);</div><div class="line"></div><div class="line">    /* CASE 1: BGSAVE is in progress, with disk target. */</div><div class="line">    // 情况1. 正在执行 BGSAVE ，且是同步到磁盘上</div><div class="line">    if (server.rdb_child_pid != -1 &amp;&amp;</div><div class="line">        server.rdb_child_type == RDB_CHILD_TYPE_DISK)</div><div class="line">    &#123;</div><div class="line">        client *slave;</div><div class="line">        listNode *ln;</div><div class="line">        listIter li;</div><div class="line"></div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            slave = ln-&gt;value;</div><div class="line">            // 如果有从节点已经创建子进程执行写RDB操作，等待完成，那么退出循环</div><div class="line">            // 从节点的状态为 SLAVE_STATE_WAIT_BGSAVE_END 在情况三中被设置</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) break;</div><div class="line">        &#125;</div><div class="line">        // 对于这个从节点，我们检查它是否具有触发当前BGSAVE操作的能力</div><div class="line">        if (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</div><div class="line">            // 将slave的输出缓冲区所有内容拷贝给c的所有输出缓冲区中</div><div class="line">            copyClientOutputBuffer(c,slave);</div><div class="line">            // 设置全量重同步从节点的状态，设置部分重同步的偏移量</div><div class="line">            replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</div><div class="line">            serverLog(LL_NOTICE,&quot;Waiting for end of BGSAVE for SYNC&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Can&apos;t attach the slave to the current BGSAVE. Waiting for next BGSAVE for SYNC&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    /* CASE 2: BGSAVE is in progress, with socket target. */</div><div class="line">    // 情况2. 正在执行BGSAVE，且是无盘同步，直接写到socket中</div><div class="line">    &#125; else if (server.rdb_child_pid != -1 &amp;&amp;</div><div class="line">               server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</div><div class="line">    &#123;</div><div class="line">        // 虽然有子进程在执行写RDB，但是它直接写到socket中，所以等待下次执行BGSAVE</div><div class="line">        serverLog(LL_NOTICE,&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;);</div><div class="line"></div><div class="line">    /* CASE 3: There is no BGSAVE is progress. */</div><div class="line">    // 情况3：没有执行BGSAVE的进程</div><div class="line">    &#125; else &#123;</div><div class="line">        // 服务器支持无盘同步</div><div class="line">        if (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</div><div class="line">            // 无盘同步复制的子进程被创建在replicationCron()中，因为想等待更多的从节点可以到来而延迟</div><div class="line">            if (server.repl_diskless_sync_delay)</div><div class="line">                serverLog(LL_NOTICE,&quot;Delay next BGSAVE for diskless SYNC&quot;);</div><div class="line">        // 服务器不支持无盘复制</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果没有正在执行BGSAVE，且没有进行写AOF文件，则开始为复制执行BGSAVE，并且是将RDB文件写到磁盘上</div><div class="line">            if (server.aof_child_pid == -1) &#123;</div><div class="line">                startBgsaveForReplication(c-&gt;slave_capa);</div><div class="line">            &#125; else &#123;</div><div class="line">                serverLog(LL_NOTICE,</div><div class="line">                    &quot;No BGSAVE in progress, but an AOF rewrite is active. BGSAVE for replication delayed&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 只有一个从节点，且backlog为空，则创建一个新的backlog</div><div class="line">    if (listLength(server.slaves) == 1 &amp;&amp; server.repl_backlog == NULL)</div><div class="line">        createReplicationBacklog();</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先先明确，主节点执行处理从节点发来PSYNC命令的操作。所以主节点会将从节点视为自己的从节点客户端来操作。会将从节点的复制设置为SLAVE_STATE_WAIT_BGSAVE_START状态表示</p>
<p>主节点执行全量同步的情况有三种：</p>
<ul>
<li>主节点服务器正在执行BGSAVE命令，且将RDB文件写到磁盘上。<br>这种情况，如果有已经设置过全局重同步偏移量的从节点，可以共用输出缓冲区的数据。</li>
<li>主节点服务器正在执行BGSAVE命令，且将RDB文件写到网络socket上，无盘同步。<br>由于本次BGSAVE命令直接将RDB写到socket中，因此只能等待下一BGSAVE。</li>
<li>主节点服务器没有正在执行BGSAVE。<br>如果也没有进行AOF持久化的操作，那么开始为复制操作执行BGSAVE，生成一个写到磁盘上的RDB文件。<br>我们针对第三种情况来分析。调用了startBgsaveForReplication()来开始执行BGSAVE命令。我们贴出主要的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 开始为复制执行BGSAVE，根据配置选择磁盘或套接字作为RDB发送的目标，在开始之前确保冲洗脚本缓存</div><div class="line">// mincapa参数是SLAVE_CAPA_*按位与的结果</div><div class="line">int startBgsaveForReplication(int mincapa) &#123;</div><div class="line">    int retval;</div><div class="line">    // 是否直接写到socket</div><div class="line">    int socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line"></div><div class="line">    if (socket_target)</div><div class="line">        // 直接写到socket中</div><div class="line">        // fork一个子进程将rdb写到 状态为等待BGSAVE开始 的从节点的socket中</div><div class="line">        retval = rdbSaveToSlavesSockets();</div><div class="line">    else</div><div class="line">        // 否则后台进行RDB持久化BGSAVE操作，保存到磁盘上</div><div class="line">        retval = rdbSaveBackground(server.rdb_filename);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    // 如果是直接写到socket中，rdbSaveToSlavesSockets()已经会设置从节点为全量复制</div><div class="line">    // 否则直接写到磁盘上，执行以下代码</div><div class="line">    if (!socket_target) &#123;</div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = ln-&gt;value;</div><div class="line">            // 设置等待全量同步的从节点的状态</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</div><div class="line">                    // 设置要执行全量重同步从节点的状态</div><div class="line">                    replicationSetupSlaveForFullResync(slave,</div><div class="line">                            getPsyncInitialOffset());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>replicationSetupSlaveForFullResync()函数源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int replicationSetupSlaveForFullResync(client *slave, long long offset) &#123;</div><div class="line">    char buf[128];</div><div class="line">    int buflen;</div><div class="line"></div><div class="line">    // 设置全量重同步的偏移量</div><div class="line">    slave-&gt;psync_initial_offset = offset;</div><div class="line">    // 设置从节点复制状态，开始累计差异数据</div><div class="line">    slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END;</div><div class="line">    // 将slaveseldb设置为-1，是为了强制发送一个select命令在复制流中</div><div class="line">    server.slaveseldb = -1;</div><div class="line"></div><div class="line">    // 如果从节点的状态是CLIENT_PRE_PSYNC，则表示是Redis是2.8之前的版本，则不将这些信息发送给从节点。</div><div class="line">    // 因为在2.8之前只支持SYNC的全量复制同步，而在之后的版本提供了部分的重同步</div><div class="line">    if (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;</div><div class="line">        buflen = snprintf(buf,sizeof(buf),&quot;+FULLRESYNC %s %lld\r\n&quot;,</div><div class="line">                          server.runid,offset);</div><div class="line">        // 否则会将全量复制的信息写给从节点</div><div class="line">        if (write(slave-&gt;fd,buf,buflen) != buflen) &#123;</div><div class="line">            freeClientAsync(slave);</div><div class="line">            return C_ERR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>哇，主节点终于回复从节点的PSYNC命令了，回复了一个+FULLRESYNC，写到主从同步的fd。表示要进行全量同步啊！！！</p>
<p>此时，从节点的复制状态一定为REPL_STATE_RECEIVE_PSYNC，fd的读事件发生，调用syncWithMaster()函数进行处理。</p>
<p>处理这种情况的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 那么尝试进行第二次部分重同步，从主节点读取指令来决定执行部分重同步还是全量同步</div><div class="line">psync_result = slaveTryPartialResynchronization(fd,1);</div></pre></td></tr></table></figure></p>
<p>这次的第二个参数是1，因此会执行该函数的读部分。(因为这个函数有两个部分，上一次执行了写部分，因为第二个参数是0)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/* Reading half */</div><div class="line">// 从主节点读一个命令保存在reply中</div><div class="line">reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">if (sdslen(reply) == 0) &#123;</div><div class="line">    // 主节点为了保持连接的状态，可能会在接收到PSYNC命令后发送一个空行</div><div class="line">    sdsfree(reply);</div><div class="line">    // 所以就返回PSYNC_WAIT_REPLY，调用者会将read_reply设置为1，然后再次调用该函数。</div><div class="line">    return PSYNC_WAIT_REPLY;</div><div class="line">&#125;</div><div class="line">// 如果读到了一个命令，删除fd的可读事件</div><div class="line">aeDeleteFileEvent(server.el,fd,AE_READABLE);</div><div class="line"></div><div class="line">// 接受到的是&quot;+FULLRESYNC&quot;，表示进行一次全量同步</div><div class="line">if (!strncmp(reply,&quot;+FULLRESYNC&quot;,11)) &#123;</div><div class="line">    char *runid = NULL, *offset = NULL;</div><div class="line">    // 解析回复中的内容，将runid和复制偏移量提取出来</div><div class="line">    runid = strchr(reply,&apos; &apos;);</div><div class="line">    if (runid) &#123;</div><div class="line">        runid++;    //定位到runid的地址</div><div class="line">        offset = strchr(runid,&apos; &apos;);</div><div class="line">        if (offset) offset++;   //定位offset</div><div class="line">    &#125;</div><div class="line">    // 如果runid和offset任意为空，那么发生不期望错误</div><div class="line">    if (!runid || !offset || (offset-runid-1) != CONFIG_RUN_ID_SIZE) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Master replied with wrong +FULLRESYNC syntax.&quot;);</div><div class="line">        // 将主节点的运行ID重置为0</div><div class="line">        memset(server.repl_master_runid,0,CONFIG_RUN_ID_SIZE+1);</div><div class="line">    // runid和offset获取成功</div><div class="line">    &#125; else &#123;</div><div class="line">        // 设置服务器保存的主节点的运行ID</div><div class="line">        memcpy(server.repl_master_runid, runid, offset-runid-1);</div><div class="line">        server.repl_master_runid[CONFIG_RUN_ID_SIZE] = &apos;\0&apos;;</div><div class="line">        // 主节点的偏移量</div><div class="line">        server.repl_master_initial_offset = strtoll(offset,NULL,10);</div><div class="line">        serverLog(LL_NOTICE,&quot;Full resync from master: %s:%lld&quot;,server.repl_master_runid,          server.repl_master_initial_offset);</div><div class="line">    &#125;</div><div class="line">    // 执行全量同步，所以缓存的主节点结构没用了，将其清空</div><div class="line">    replicationDiscardCachedMaster();</div><div class="line">    sdsfree(reply);</div><div class="line">    // 返回执行的状态</div><div class="line">    return PSYNC_FULLRESYNC;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接受到的是&quot;+CONTINUE&quot;，表示进行一次部分重同步</div><div class="line">if (!strncmp(reply,&quot;+CONTINUE&quot;,9)) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Successful partial resynchronization with master.&quot;);</div><div class="line">    sdsfree(reply);</div><div class="line">    // 因为执行部分重同步，因此要使用缓存的主节点结构，所以将其设置为当前的主节点，被同步的主节点</div><div class="line">    replicationResurrectCachedMaster(fd);</div><div class="line">    // 返回执行的状态</div><div class="line">    return PSYNC_CONTINUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收到了错误，两种情况。</div><div class="line">// 1. 主节点不支持PSYNC命令，Redis版本低于2.8</div><div class="line">// 2. 从主节点读取了一个不期望的回复</div><div class="line">if (strncmp(reply,&quot;-ERR&quot;,4)) &#123;</div><div class="line">    /* If it&apos;s not an error, log the unexpected event. */</div><div class="line">    serverLog(LL_WARNING,&quot;Unexpected reply to PSYNC from master: %s&quot;, reply);</div><div class="line">&#125; else &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Master does not support PSYNC or is in error state (reply: %s)&quot;, reply);</div><div class="line">&#125;</div><div class="line">sdsfree(reply);</div><div class="line">replicationDiscardCachedMaster();</div><div class="line">// 发送不支持PSYNC命令的状态</div><div class="line">return PSYNC_NOT_SUPPORTED;</div></pre></td></tr></table></figure></p>
<p>至此，从节点监听主节点的读命令事件已经完成，所以取消监听了读事件。等到主节点开始传送数据给从节点时，从节点会新创建读事件。</p>
<p>该函数可以解析出主节点发过来的命令是哪一个，一共有三种：</p>
<ul>
<li>“+FULLRESYNC”：代表要进行一次全量复制。</li>
<li>“+CONTINUE”：代表要进行一次部分重同步。</li>
<li>“-ERR”：发生了错误。有两种可能：Redis版本过低不支持PSYNC命令和从节点读到一个错误回复。<br>我们关注第一个全量同步的操作。如果读到了主节点发来的”+FULLRESYNC”，那么会将同时发来的主节点运行ID和全局的复制偏移量保存到从节点的服务器属性中server.repl_master_runid和server.repl_master_initial_offset。然后返回PSYNC_FULLRESYNC。</li>
</ul>
<p>回到syncWithMaster函数，继续处理全量同步。由于要进行全量同步，如果当前从节点还作为其他节点的主节点，因此要断开所有从节点的连接，让他们也重新同步当前节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 执行到这里，psync_result == PSYNC_FULLRESYNC或PSYNC_NOT_SUPPORTED</div><div class="line">    // 准备一个合适临时文件用来写入和保存主节点传来的RDB文件数据</div><div class="line">    while(maxtries--) &#123;</div><div class="line">        // 设置文件的名字</div><div class="line">        snprintf(tmpfile,256,</div><div class="line">            &quot;temp-%d.%ld.rdb&quot;,(int)server.unixtime,(long int)getpid());</div><div class="line">        // 以读写，可执行权限打开临时文件</div><div class="line">        dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);</div><div class="line">        // 打开成功，跳出循环</div><div class="line">        if (dfd != -1) break;</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">    /* Setup the non blocking download of the bulk file. */</div><div class="line">    // 监听一个fd的读事件，并设置该事件的处理程序为readSyncBulkPayload</div><div class="line">    if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL)</div><div class="line">            == AE_ERR)</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_WARNING,</div><div class="line">            &quot;Can&apos;t create readable event for SYNC: %s (fd=%d)&quot;,</div><div class="line">            strerror(errno),fd);</div><div class="line">        goto error;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 复制状态为正从主节点接受RDB文件</div><div class="line">    server.repl_state = REPL_STATE_TRANSFER;</div><div class="line">    // 初始化RDB文件的大小</div><div class="line">    server.repl_transfer_size = -1;</div><div class="line">    // 已读的大小</div><div class="line">    server.repl_transfer_read = 0;</div><div class="line">    // 最近一个执行fsync的偏移量为0</div><div class="line">    server.repl_transfer_last_fsync_off = 0;</div><div class="line">    // 传输RDB文件的临时fd</div><div class="line">    server.repl_transfer_fd = dfd;</div><div class="line">    // 最近一次读到RDB文件内容的时间</div><div class="line">    server.repl_transfer_lastio = server.unixtime;</div><div class="line">    // 保存RDB文件的临时文件名</div><div class="line">    server.repl_transfer_tmpfile = zstrdup(tmpfile);</div><div class="line">    return;</div></pre></td></tr></table></figure></p>
<p> 准备好了所有，接下来就要等待主节点来发送RDB文件了。因此上面做了这三件事：</p>
<ul>
<li>打开一个临时文件，用来保存主节点发来的RDB文件数据的。</li>
<li>监听fd的读事件，等待主节点发送RDB文件数据，触发可读事件执行readSyncBulkPayload()函数，该函数就会把主节点发来的数据读到一个缓冲区中，然后将缓冲区的数据写到刚才打开的临时文件中，接着要载入到从节点的数据库中，最后同步到磁盘中。</li>
<li>设置复制操作的状态为server.repl_state = REPL_STATE_TRANSFER。并且初始化复制的信息，例如：RDB文件的大小，偏移量，等等。（具体看上面的代码）<br>主节点要发送RDB文件，但是回复完”+FULLRESYNC”就再也没有操作了。而子节点创建了监听主节点写RDB文件的事件，等待主节点来写，才调用readSyncBulkPayload()函数来处理。这又有问题了，到底主节点什么时候发送RDB文件呢？如果不是主动执行，那么一定就在周期性函数内被执行。</li>
</ul>
<p>它的调用关系如下：</p>
<p>serverCron()-&gt;backgroundSaveDoneHandler()-&gt;backgroundSaveDoneHandlerDisk()-&gt;updateSlavesWaitingBgsave()</p>
<p>updateSlavesWaitingBgsave()函数定义在replication.c中，主要操作有两步，我们简单介绍：</p>
<ul>
<li>只读打开主节点的临时RDB文件，然后设置从节点client复制状态为SLAVE_STATE_SEND_BULK。</li>
<li>立刻创建监听可写的事件，并设置sendBulkToSlave()函数为可写事件的处理程序。<br>当主节点执行周期性函数时，主节点会先清除之前监听的可写事件，然后立即监听新的可写事件，这样就会触发可写的事件，调用sendBulkToSlave()函数将RDB文件写入到fd中，触发从节点的读事件，从节点调用readSyncBulkPayload()函数，来将RDB文件的数据载入数据库中，至此，就保证了主从同步了。</li>
</ul>
<p>我们来简单介绍sendBulkToSlave()函数在写RDB文件时做了什么：</p>
<ul>
<li>将RDB文件的大小写给从节点，以协议格式的字符串表示的大小。</li>
<li>从RDB文件的repldbfd中读出RDB文件数据，然后写到主从同步的fd中。</li>
<li>写入完成后，又一次取消监听文件可写事件，等待下一次发送缓冲区数据时在监听触发，并且调用putSlaveOnline()函数将从节点client的复制状态设置为SLAVE_STATE_ONLINE。表示已经发送RDB文件完毕，发送缓存更新。</li>
</ul>
<h3 id="2-9-发送输出缓冲区数据"><a href="#2-9-发送输出缓冲区数据" class="headerlink" title="2.9 发送输出缓冲区数据"></a>2.9 发送输出缓冲区数据</h3><p>主节点发送完RDB文件后，调用putSlaveOnline()函数将从节点client的复制状态设置为SLAVE_STATE_ONLINE，表示已经发送RDB文件完毕，要发送缓存更新了。于是会新创建一个事件，监听写事件的发生，设置sendReplyToClient为可写的处理程序，而且会将从节点client当做私有数据闯入sendReplyToClient()当做发送缓冲区的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE,sendReplyToClient, slave)</div></pre></td></tr></table></figure></p>
<p>创建可写事件的时候，就会触发第一次可写，执行sendReplyToClient()，该函数还直接调用了riteToClient(fd,privdata,1)函数，于是将从节点client输出缓冲区的数据发送给了从节点服务器。</p>
<p>riteToClient()函数数据Redis网络连接库的函数，定义在network.c中，具体分析请看：Redis 网络连接库源码分析</p>
<p>这样就保证主从服务器的数据库状态一致了。</p>
<h3 id="2-10-命令传播"><a href="#2-10-命令传播" class="headerlink" title="2.10 命令传播"></a>2.10 命令传播</h3><p>主从节点在第一次全量同步之后就达到了一致，但是之后主节点如果执行了写命令，主节点的数据库状态就又可能发生变化，导致主从再次不一致。为了让主从节点回到一致状态，主机的执行命令后都需要将命令传播到从节点。</p>
<p>传播时会调用server.c中的propagate()函数，如果传播到从节点会调用replicationFeedSlaves(server.slaves,dbid,argv,argc)函数，该函数则会将执行的命令以协议的传输格式写到从节点client的输出缓冲区中，这就是为什么主节点会将从节点client的输出缓冲区发送到从节点（具体见标题2.9），也会添加到server.repl_backlog中。</p>
<p>我们来看看replicationFeedSlaves()函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">// 将参数列表中的参数发送给从服务器</div><div class="line">void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) &#123;</div><div class="line">    listNode *ln;</div><div class="line">    listIter li;</div><div class="line">    int j, len;</div><div class="line">    char llstr[LONG_STR_SIZE];</div><div class="line"></div><div class="line">    // 如果没有backlog且没有从节点服务器，直接返回</div><div class="line">    if (server.repl_backlog == NULL &amp;&amp; listLength(slaves) == 0) return;</div><div class="line"></div><div class="line">    /* We can&apos;t have slaves attached and no backlog. */</div><div class="line">    serverAssert(!(listLength(slaves) != 0 &amp;&amp; server.repl_backlog == NULL));</div><div class="line"></div><div class="line">    // 如果当前从节点使用的数据库不是目标的数据库，则要生成一个select命令</div><div class="line">    if (server.slaveseldb != dictid) &#123;</div><div class="line">        robj *selectcmd;</div><div class="line"></div><div class="line">        // 0 &lt;= id &lt; 10 ，可以使用共享的select命令对象</div><div class="line">        if (dictid &gt;= 0 &amp;&amp; dictid &lt; PROTO_SHARED_SELECT_CMDS) &#123;</div><div class="line">            selectcmd = shared.select[dictid];</div><div class="line">        // 否则自行按照协议格式构建select命令对象</div><div class="line">        &#125; else &#123;</div><div class="line">            int dictid_len;</div><div class="line"></div><div class="line">            dictid_len = ll2string(llstr,sizeof(llstr),dictid);</div><div class="line">            selectcmd = createObject(OBJ_STRING,</div><div class="line">                sdscatprintf(sdsempty(),</div><div class="line">                &quot;*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n&quot;,</div><div class="line">                dictid_len, llstr));</div><div class="line">        &#125;</div><div class="line">        // 将select 命令添加到backlog中</div><div class="line">        if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);</div><div class="line"></div><div class="line">        // 发送给从服务器</div><div class="line">        listRewind(slaves,&amp;li);</div><div class="line">        // 遍历所有的从服务器节点</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = ln-&gt;value;</div><div class="line">            // 从节点服务器状态为等待BGSAVE的开始，因此跳过回复，遍历下一个节点</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;</div><div class="line">            // 添加select命令到当前从节点的回复中</div><div class="line">            addReply(slave,selectcmd);</div><div class="line">        &#125;</div><div class="line">        // 释放临时对象</div><div class="line">        if (dictid &lt; 0 || dictid &gt;= PROTO_SHARED_SELECT_CMDS)</div><div class="line">            decrRefCount(selectcmd);</div><div class="line">    &#125;</div><div class="line">    // 设置当前从节点使用的数据库ID</div><div class="line">    server.slaveseldb = dictid;</div><div class="line"></div><div class="line">    // 将命令写到backlog中</div><div class="line">    if (server.repl_backlog) &#123;</div><div class="line">        char aux[LONG_STR_SIZE+3];</div><div class="line"></div><div class="line">        // 将参数个数构建成协议标准的字符串</div><div class="line">        // *&lt;argc&gt;\r\n</div><div class="line">        aux[0] = &apos;*&apos;;</div><div class="line">        len = ll2string(aux+1,sizeof(aux)-1,argc);</div><div class="line">        aux[len+1] = &apos;\r&apos;;</div><div class="line">        aux[len+2] = &apos;\n&apos;;</div><div class="line">        // 添加到backlog中</div><div class="line">        feedReplicationBacklog(aux,len+3);</div><div class="line"></div><div class="line">        // 遍历所有的参数</div><div class="line">        for (j = 0; j &lt; argc; j++) &#123;</div><div class="line">            // 返回参数对象的长度</div><div class="line">            long objlen = stringObjectLen(argv[j]);</div><div class="line"></div><div class="line">            // 构建成协议标准的字符串，并添加到backlog中</div><div class="line">            // $&lt;len&gt;\r\n&lt;argv&gt;\r\n</div><div class="line">            aux[0] = &apos;$&apos;;</div><div class="line">            len = ll2string(aux+1,sizeof(aux)-1,objlen);</div><div class="line">            aux[len+1] = &apos;\r&apos;;</div><div class="line">            aux[len+2] = &apos;\n&apos;;</div><div class="line">            // 添加$&lt;len&gt;\r\n</div><div class="line">            feedReplicationBacklog(aux,len+3);</div><div class="line">            // 添加参数对象&lt;argv&gt;</div><div class="line">            feedReplicationBacklogWithObject(argv[j]);</div><div class="line">            // 添加\r\n</div><div class="line">            feedReplicationBacklog(aux+len+1,2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 将命令写到每一个从节点中</div><div class="line">    listRewind(server.slaves,&amp;li);</div><div class="line">    // 遍历从节点链表</div><div class="line">    while((ln = listNext(&amp;li))) &#123;</div><div class="line">        client *slave = ln-&gt;value;</div><div class="line"></div><div class="line">        // 从节点服务器状态为等待BGSAVE的开始，因此跳过回复，遍历下一个节点</div><div class="line">        if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;</div><div class="line"></div><div class="line">        // 将命令写给正在等待初次SYNC的从节点（所以这些命令在输出缓冲区中排队，直到初始SYNC完成），或已经与主节点同步</div><div class="line">        /* Add the multi bulk length. */</div><div class="line">        // 添加回复的长度</div><div class="line">        addReplyMultiBulkLen(slave,argc);</div><div class="line"></div><div class="line">        // 将所有的参数列表添加到从节点的输出缓冲区</div><div class="line">        for (j = 0; j &lt; argc; j++)</div><div class="line">            addReplyBulk(slave,argv[j]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和AOF持久化一样，再给从节点client写命令时，会将SELECT命令强制写入，以保证命令正确读到数据库中。</p>
<p>不仅写入了从节点client的输出缓冲区，而且还会将命令记录到主节点服务器的复制积压缓冲区server.repl_backlog中，这是为了网络闪断后进行部分重同步。</p>
<h2 id="3-部分重同步实现"><a href="#3-部分重同步实现" class="headerlink" title="3. 部分重同步实现"></a>3. 部分重同步实现</h2><p>刚才剖析完全量同步，但是没有考虑特殊的情况。如果在传输RDB文件的过程中，网络发生故障，主节点和从节点的连接中断，Redis会咋么做呢？</p>
<p>Redis 2.8 版本之前会在进行一次连接然后进行全量复制，但是这样效率非常地下，之后的版本都提供了部分重同步的实现。那么我们就分析一下部分重同步的实现过程。</p>
<p>部分重同步在复制的过程中，相当于标题2.8的发送PSYNC命令的部分，其他所有的部分都要进行，他只是主节点回复从节点的命令不同，回复+CONTINUE则执行部分重同步，回复+FULLRESYNC则执行全量同步。</p>
<h3 id="3-1-心跳机制"><a href="#3-1-心跳机制" class="headerlink" title="3.1 心跳机制"></a>3.1 心跳机制</h3><p>主节点是如何发现和从节点连接中断？在主从节点建立连接后，他们之间都维护者长连接并彼此发送心跳命令。主从节点彼此都有心跳机制，各自模拟成对方的客户端进行通信。</p>
<ul>
<li>主节点默认每隔10秒发送PING命令，判断从节点的连接状态。 </li>
<li><p>文件配置项：repl-ping-salve-period，默认是10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 首先，根据当前节点发送PING命令给从节点的频率发送PING命令 </div><div class="line">// 如果当前节点是某以节点的 主节点 ，那么发送PING给从节点</div><div class="line">if ((replication_cron_loops % server.repl_ping_slave_period) == 0) &#123;</div><div class="line">    // 创建PING命令对象</div><div class="line">    ping_argv[0] = createStringObject(&quot;PING&quot;,4);</div><div class="line">    // 将PING发送给从服务器</div><div class="line">    replicationFeedSlaves(server.slaves, server.slaveseldb, ping_argv, 1);</div><div class="line">    decrRefCount(ping_argv[0]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从节点在主线程中每隔1秒发送REPLCONF ACK <offset>命令，给主节点报告自己当前复制偏移量。</offset></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 定期发送ack给主节点，旧版本的Redis除外</div><div class="line">if (server.masterhost &amp;&amp; server.master &amp;&amp; !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</div><div class="line">    // 发送一个REPLCONF ACK命令给主节点去报告关于当前处理的offset。</div><div class="line">    replicationSendAck();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在周期性函数replicationCron()，每次都要检查和主节点处于连接状态的从节点和主节点的交互时间是否超时，如果超时则会调用cancelReplicationHandshake()函数，取消和主节点的连接。等到下一个周期在和主节点重新建立连接，进行复制。</p>
<h3 id="3-2-复制积压缓冲区-backlog"><a href="#3-2-复制积压缓冲区-backlog" class="headerlink" title="3.2 复制积压缓冲区(backlog)"></a>3.2 复制积压缓冲区(backlog)</h3><p>复制积压缓冲区是一个大小为1M的循环队列。主节点在命令传播时，不仅会将命令发送给所有的从节点，还会将命令写入复制积压缓冲区中（具体请看标题2.10）。</p>
<p>也就是说，复制积压缓冲区最多可以备份1M大小的数据，如果主从节点断线时间过长，复制积压缓冲区的数据会被新数据覆盖，那么当从主从中断连接起，主节点接收到的数据超过1M大小，那么从节点就无法进行部分重同步，只能进行全量复制。</p>
<p>在标题2.8，介绍的syncCommand()命令中，调用masterTryPartialResynchronization()函数会进行尝试部分重同步，在我们之前分析的第一次全量同步时，该函数会执行失败，然后返回syncCommand()函数执行全量同步，而在进行恢复主从连接后，则会进行部分重同步，masterTryPartialResynchronization()函数代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">// 该函数从主节点接收到部分重新同步请求的角度处理PSYNC命令</div><div class="line">// 成功返回C_OK，否则返回C_ERR</div><div class="line">int masterTryPartialResynchronization(client *c) &#123;</div><div class="line">    long long psync_offset, psync_len;</div><div class="line">    char *master_runid = c-&gt;argv[1]-&gt;ptr;   //主节点的运行ID</div><div class="line">    char buf[128];</div><div class="line">    int buflen;</div><div class="line"></div><div class="line">    // 主节点的运行ID是否和从节点执行PSYNC的参数提供的运行ID相同。</div><div class="line">    // 如果运行ID发生了改变，则主节点是一个不同的实例，那么就不能进行继续执行原有的复制进程</div><div class="line">    if (strcasecmp(master_runid, server.runid)) &#123;</div><div class="line">        /* Run id &quot;?&quot; is used by slaves that want to force a full resync. */</div><div class="line">        // 如果从节点的运行ID是&quot;?&quot;，表示想要强制进行一个全量同步</div><div class="line">        if (master_runid[0] != &apos;?&apos;) &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Partial resynchronization not accepted: &quot;</div><div class="line">                &quot;Runid mismatch (Client asked for runid &apos;%s&apos;, my runid is &apos;%s&apos;)&quot;,</div><div class="line">                master_runid, server.runid);</div><div class="line">        &#125; else &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Full resync requested by slave %s&quot;,</div><div class="line">                replicationGetSlaveName(c));</div><div class="line">        &#125;</div><div class="line">        goto need_full_resync;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从参数对象中获取psync_offset</div><div class="line">    if (getLongLongFromObjectOrReply(c,c-&gt;argv[2],&amp;psync_offset,NULL) !=</div><div class="line">       C_OK) goto need_full_resync;</div><div class="line">    // 如果psync_offset小于repl_backlog_off，说明backlog所备份的数据的已经太新了，有一些数据被覆盖，则需要进行全量复制</div><div class="line">    // 如果psync_offset大于(server.repl_backlog_off + server.repl_backlog_histlen)，表示当前backlog的数据不够全，则需要进行全量复制</div><div class="line">    if (!server.repl_backlog ||</div><div class="line">        psync_offset &lt; server.repl_backlog_off ||</div><div class="line">        psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_NOTICE,</div><div class="line">            &quot;Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld).&quot;, replicationGetSlaveName(c), psync_offset);</div><div class="line">        if (psync_offset &gt; server.master_repl_offset) &#123;</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Warning: slave %s tried to PSYNC with an offset that is greater than the master replication offset.&quot;, replicationGetSlaveName(c));</div><div class="line">        &#125;</div><div class="line">        goto need_full_resync;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行到这里，则可以进行部分重同步</div><div class="line">    // 1. 设置client状态为从节点</div><div class="line">    // 2. 向从节点发送 +CONTINUE 表示接受 partial resync 被接受</div><div class="line">    // 3. 发送backlog的数据给从节点</div><div class="line"></div><div class="line">    // 设置client状态为从节点</div><div class="line">    c-&gt;flags |= CLIENT_SLAVE;</div><div class="line">    // 设置复制状态为在线，此时RDB文件传输完成，发送差异数据</div><div class="line">    c-&gt;replstate = SLAVE_STATE_ONLINE;</div><div class="line">    // 设置从节点收到ack的时间</div><div class="line">    c-&gt;repl_ack_time = server.unixtime;</div><div class="line">    // slave向master发送ack标志设置为0</div><div class="line">    c-&gt;repl_put_online_on_ack = 0;</div><div class="line">    // 将当前client加入到从节点链表中</div><div class="line">    listAddNodeTail(server.slaves,c);</div><div class="line">    // 向从节点发送 +CONTINUE</div><div class="line">    buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE\r\n&quot;);</div><div class="line">    if (write(c-&gt;fd,buf,buflen) != buflen) &#123;</div><div class="line">        freeClientAsync(c);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">    // 将backlog的数据发送从节点</div><div class="line">    psync_len = addReplyReplicationBacklog(c,psync_offset);</div><div class="line">    serverLog(LL_NOTICE,</div><div class="line">        &quot;Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.&quot;, replicationGetSlaveName(c), psync_len, psync_offset);</div><div class="line">    // 计算延迟值小于min-slaves-max-lag的从节点的个数</div><div class="line">    refreshGoodSlavesCount();</div><div class="line">    return C_OK; /* The caller can return, no full resync needed. */</div><div class="line"></div><div class="line">need_full_resync:</div><div class="line">    return C_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果可以进行部分重同步，主节点则会发送”+CONTINUE\r\n”作为从节点发送PSYNC回复（看标题2.8）。然后调用addReplyReplicationBacklog()函数，将backlog中的数据发送给从节点。于是就完成了部分重同步。</p>
<p>addReplyReplicationBacklog()函数所做的就是将backlog写到从节点的client的输出缓冲区中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/23/redis-analysis-replicate/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/23/redis-analysis-replicate/" itemprop="url">
                  Redis源码剖析和注释（十二）--- Redis 复制(replicate)源码详细解析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T18:34:50+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-复制介绍"><a href="#1-复制介绍" class="headerlink" title="1. 复制介绍"></a>1. 复制介绍</h2><p>分布式数据库为了获取更大的存储容量和更高的并发访问量，会将原来集中式数据库中的数据分散存储到多个通过网络连接的数据存储节点上。Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="2-复制的建立"><a href="#2-复制的建立" class="headerlink" title="2. 复制的建立"></a>2. 复制的建立</h2><p>建立复制的配置方式有三种。</p>
<ul>
<li>在redis.conf文件中配置slaveof <masterip> <masterport>选项，然后指定该配置文件启动Redis生效。</masterport></masterip></li>
<li>在redis-server启动命令后加上–slaveof <masterip> <masterport>启动生效。</masterport></masterip></li>
<li><p>直接使用 slaveof <masterip> <masterport>命令在从节点执行生效。<br>我们以最简单的一主一从模型，使用第2种方式建立复制。</masterport></masterip></p>
</li>
<li><p>首先先开启主节点master实例，端口8888</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --port 8888</div></pre></td></tr></table></figure>
</li>
<li><p>接着开启从节点slave实例，端口9999，并指定指定主节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis-server --port 9999 --slaveof 127.0.0.1 8888</div><div class="line">//命令行开启Redis服务器后，会打印如下日志信息，已经开启复制了</div><div class="line">Connecting to MASTER 127.0.0.1:8888</div><div class="line">MASTER &lt;-&gt; SLAVE sync started</div><div class="line">Non blocking connect for SYNC fired the event.</div><div class="line">Master replied to PING, replication can continue...</div><div class="line">Partial resynchronization not possible (no cached master)</div><div class="line">Full resync from master: 1aff09ecd70ca640e33083f8422018b29883b9d1:1</div><div class="line">MASTER &lt;-&gt; SLAVE sync: receiving 76 bytes from master</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Flushing old data</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Finished with success</div></pre></td></tr></table></figure>
</li>
<li><p>开启一个client，连接上从节点服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  ~ redis-cli -p 9999</div><div class="line">127.0.0.1:9999&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:slave                      //节点角色</div><div class="line">master_host:127.0.0.1           //主节点的IP</div><div class="line">master_port:8888                //主节点的端口</div><div class="line">master_link_status:up           //与主节点的连接状态</div><div class="line">master_last_io_seconds_ago:0    //主节点最后与从节点的通信时间间隔，单位秒</div><div class="line">master_sync_in_progress:0       //从节点是否正在全量同步主节点的RDB文件</div><div class="line">slave_repl_offset:407           //复制偏移量</div><div class="line">slave_priority:100              //从节点的优先级</div><div class="line">slave_read_only:1               //从节点是否只读</div><div class="line">connected_slaves:0              //连接从节点的个数</div><div class="line">master_repl_offset:0            //当前从节点作为其他从节点的主节点时的复制偏移量</div><div class="line">//以下四种信息为通用的配置</div><div class="line">repl_backlog_active:0           //复制缓冲区的状态</div><div class="line">repl_backlog_size:1048576       //复制缓冲区的大小</div><div class="line">repl_backlog_first_byte_offset:0//复制缓冲区起始偏移量，标识当前缓冲区可用的范围</div><div class="line">repl_backlog_histlen:0          //标识复制缓冲区已存在的有效数据长度</div><div class="line">127.0.0.1:9999&gt; KEYS *          //由于主节点的键空间为空，所以从节点的键空间也为空。</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，我们查看主节点的INFO replication 信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//通过INFO replication命令可以查看当前的复制信息</div><div class="line">127.0.0.1:6380&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:master                                                     //节点角色</div><div class="line">connected_slaves:1                                              //连接从节点的个数</div><div class="line">slave0:ip=127.0.0.1,port=9999,state=online,offset=631,lag=0     //连接从节点的信息</div><div class="line">master_repl_offset:631                                          //主节点的偏移量</div><div class="line">//以下四种信息为通用的配置  </div><div class="line">repl_backlog_active:1                                           //复制缓冲区的状态</div><div class="line">repl_backlog_size:1048576                                       //复制缓冲区的大小</div><div class="line">repl_backlog_first_byte_offset:2                                //复制缓冲区起始偏移量，标识当前缓冲区可用的范围</div><div class="line">repl_backlog_histlen:630                                        //由于主节点的键空间为空，所以从节点的键空间也为空。</div></pre></td></tr></table></figure></p>
<p>到此，一主一从模型的复制就建立成功了。我们可以在主节点建立一些新的键，然后查看从节点的键空间的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//根据端口区别主从节点</div><div class="line">127.0.0.1:8888&gt; HSET hash_key hello world</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:9999&gt; KEYS *  //从节点的键空间已经更新</div><div class="line">1) &quot;hash_key&quot;</div></pre></td></tr></table></figure></p>
<p>我们在查看从节点的INFO replication信息时，可以知道slave_read_only:1，从节点默认只能读不能写，因此执行写命令会得到如下回复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; SET key value</div><div class="line">(error) READONLY You can&apos;t write against a read only slave.</div></pre></td></tr></table></figure></p>
<p>只读模式由 redis.conf 文件中的 slave-read-only 选项控制，也可以通过 CONFIG SET命令来开启或关闭这个模式。</p>
<p>我们在查看从节点的INFO replication信息时，还发现有connected_slaves:0选项 ，说明Redis的复制拓扑结构支持单层或多层复制关系，从节点还可以作为其他从节点的主节点进行复制。</p>
<p>根据拓扑关系可以分为三种：</p>
<ul>
<li><p>一主一从<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication01.jpg" alt="replicate01"></p>
</li>
<li><p>一主多从<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication02.jpg" alt="replicate01"></p>
</li>
<li><p>树型主从结构<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication03.jpg" alt="replicate01"></p>
</li>
</ul>
<h2 id="3-复制的断开"><a href="#3-复制的断开" class="headerlink" title="3. 复制的断开"></a>3. 复制的断开</h2><p>复制断开也是在从节点执行命令slaveof no one来断开于主节点的复制关系。例如，将刚才端口为9999的从节点断开复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; SLAVEOF no one</div><div class="line">OK</div><div class="line">//从节点服务器会打印如下日志</div><div class="line">Connection with master lost.</div><div class="line">Caching the disconnected master state.</div><div class="line">Discarding previously cached master state.</div><div class="line">MASTER MODE enabled (user request from &apos;id=3 addr=127.0.0.1:40218 fd=7 name= age=2218 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=slaveof&apos;)</div><div class="line">//主节点服务器也会打印断开的信息</div><div class="line">Connection with slave 127.0.0.1:9999 lost.</div></pre></td></tr></table></figure></p>
<p>从节点服务器断开后，从节点会晋升为主节点。从日志中可以看到MASTER MODE enabled，也可以从INFO命令查看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:master     //角色发生变化</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="4-min-slaves配置选项"><a href="#4-min-slaves配置选项" class="headerlink" title="4. min-slaves配置选项"></a>4. min-slaves配置选项</h2><p>Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主节点在不安全的情况下执行写命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">min-slaves-to-write 3   //从节点数量少于3个，主节点拒绝执行写命令</div><div class="line">min-slaves-max-lag 10   //3个从节点的延迟(lag)值，大于或等于10，主节点拒绝执行写命令</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/10/redis-analysis-t-string/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/10/redis-analysis-t-string/" itemprop="url">
                  Redis源码剖析和注释（九）--- 字符串命令的实现(t_string)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T22:52:18+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-字符串命令介绍"><a href="#1-字符串命令介绍" class="headerlink" title="1. 字符串命令介绍"></a>1. 字符串命令介绍</h2><table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET key value：设置指定 key 的值</td>
</tr>
<tr>
<td>2</td>
<td>GET key： 获取指定 key 的值。</td>
</tr>
<tr>
<td>3</td>
<td>GETRANGE key start end： 返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>4</td>
<td>GETSET key value：将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td>5</td>
<td>GETBIT key offset：对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>6</td>
<td>MGET key1 [key2..]：获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td>7</td>
<td>SETBIT key offset value：对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>8</td>
<td>SETEX key seconds value：将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td>9</td>
<td>SETNX key value：只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td>10</td>
<td>SETRANGE key offset value：用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td>11</td>
<td>STRLEN key：返回 key 所储存的字符串值的长度。</td>
</tr>
<tr>
<td>12</td>
<td>MSET key value [key value …]：同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td>13</td>
<td>MSETNX key value [key value …]：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td>14</td>
<td>PSETEX key milliseconds value：这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td>15</td>
<td>INCR key：将 key 中储存的数字值增一。</td>
</tr>
<tr>
<td>16</td>
<td>INCRBY key increment将 key： 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td>17</td>
<td>INCRBYFLOAT key increment：将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td>18</td>
<td>DECR key：将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td>19</td>
<td>DECRBY key decrementkey： 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td>20</td>
<td>APPEND key value：如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</td>
</tr>
</tbody>
</table>
<h2 id="2-字符串命令的实现"><a href="#2-字符串命令的实现" class="headerlink" title="2. 字符串命令的实现"></a>2. 字符串命令的实现</h2><p>字符串命令底层数据结构为 简单动态字符串SDS 。对于字符串命令，无论是命令本身还是参数，都是作为成一个对象对待的。关于redis的对象系统，请参考文章：redis对象系统源码剖析和注释。</p>
<p>在redis的对象系统中，字符串对象的底层实现类型有如下三种：</p>
<table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串实现的字符串对象</td>
</tr>
</tbody>
</table>
<p>因此，一个字符串对象的结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，字符串对象应该为 OBJ_STRING</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，分别为OBJ_STRING、OBJ_ENCODING_INT或OBJ_ENCODING_EMBSTR</div><div class="line">    unsigned encoding:4;</div><div class="line">    //暂且不关心该成员</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<p>我们假设一个key的值为”Hello World” ，因此它的空间结构如图所示：<br>[url01]</p>
<h2 id="3-字符串命令源码注释"><a href="#3-字符串命令源码注释" class="headerlink" title="3. 字符串命令源码注释"></a>3. 字符串命令源码注释</h2><p>这里列出几个重要的命令。</p>
<h3 id="3-1-SET-一类命令的最底层实现"><a href="#3-1-SET-一类命令的最底层实现" class="headerlink" title="3.1 SET 一类命令的最底层实现"></a>3.1 SET 一类命令的最底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#define OBJ_SET_NO_FLAGS 0</div><div class="line">#define OBJ_SET_NX (1&lt;&lt;0)     /* Set if key not exists. */          //在key不存在的情况下才会设置</div><div class="line">#define OBJ_SET_XX (1&lt;&lt;1)     /* Set if key exists. */              //在key存在的情况下才会设置</div><div class="line">#define OBJ_SET_EX (1&lt;&lt;2)     /* Set if time in seconds is given */ //以秒(s)为单位设置键的key过期时间</div><div class="line">#define OBJ_SET_PX (1&lt;&lt;3)     /* Set if time in ms in given */      //以毫秒(ms)为单位设置键的key过期时间</div><div class="line"></div><div class="line">//setGenericCommand()函数是以下命令: SET, SETEX, PSETEX, SETNX.的最底层实现</div><div class="line">//flags 可以是NX或XX，由上面的宏提供</div><div class="line">//expire 定义key的过期时间，格式由unit指定</div><div class="line">//ok_reply和abort_reply保存着回复client的内容，NX和XX也会改变回复</div><div class="line">//如果ok_reply为空，则使用 &quot;+OK&quot;</div><div class="line">//如果abort_reply为空，则使用 &quot;$-1&quot;</div><div class="line">void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) &#123;</div><div class="line">    long long milliseconds = 0; /* initialized to avoid any harmness warning */ //初始化，避免错误</div><div class="line"></div><div class="line">    //如果定义了key的过期时间</div><div class="line">    if (expire) &#123;</div><div class="line">        //从expire对象中取出值，保存在milliseconds中，如果出错发送默认的信息给client</div><div class="line">        if (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) != C_OK)</div><div class="line">            return;</div><div class="line">        // 如果过期时间小于等于0，则发送错误信息给client</div><div class="line">        if (milliseconds &lt;= 0) &#123;</div><div class="line">            addReplyErrorFormat(c,&quot;invalid expire time in %s&quot;,c-&gt;cmd-&gt;name);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //如果unit的单位是秒，则需要转换为毫秒保存</div><div class="line">        if (unit == UNIT_SECONDS) milliseconds *= 1000;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //lookupKeyWrite函数是为执行写操作而取出key的值对象</div><div class="line">    //如果设置了NX(不存在)，并且在数据库中 找到 该key，或者</div><div class="line">    //设置了XX(存在)，并且在数据库中 没有找到 该key</div><div class="line">    //回复abort_reply给client</div><div class="line">    if ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != NULL) ||</div><div class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == NULL))</div><div class="line">    &#123;</div><div class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //在当前db设置键为key的值为val</div><div class="line">    setKey(c-&gt;db,key,val);</div><div class="line"></div><div class="line">    //设置数据库为脏(dirty)，服务器每次修改一个key后，都会对脏键(dirty)增1</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //设置key的过期时间</div><div class="line">    //mstime()返回毫秒为单位的格林威治时间</div><div class="line">    if (expire) setExpire(c-&gt;db,key,mstime()+milliseconds);</div><div class="line"></div><div class="line">    //发送&quot;set&quot;事件的通知，用于发布订阅模式，通知客户端接受发生的事件</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;set&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //发送&quot;expire&quot;事件通知</div><div class="line">    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</div><div class="line">        &quot;expire&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //设置成功，则向客户端发送ok_reply</div><div class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-GET-一类命令的最底层实现"><a href="#3-2-GET-一类命令的最底层实现" class="headerlink" title="3.2 GET 一类命令的最底层实现"></a>3.2 GET 一类命令的最底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GET 命令的底层实现</div><div class="line">int getGenericCommand(client *c) &#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    //lookupKeyReadOrReply函数是为执行读操作而返回key的值对象，找到返回该对象，找不到会发送信息给client</div><div class="line">    //如果key不存在直接，返回0表示GET命令执行成功</div><div class="line">    if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.nullbulk)) == NULL)</div><div class="line">        return C_OK;</div><div class="line"></div><div class="line">    //如果key的值的编码类型不是字符串对象</div><div class="line">    if (o-&gt;type != OBJ_STRING) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);    //返回类型错误的信息给client，返回-1表示GET命令执行失败</div><div class="line">        return C_ERR;</div><div class="line">    &#125; else &#123;</div><div class="line">        addReplyBulk(c,o);  //返回之前找到的对象作为回复给client，返回0表示GET命令执行成功</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-DECR-和-INCR-底层实现"><a href="#3-3-DECR-和-INCR-底层实现" class="headerlink" title="3.3 DECR 和 INCR 底层实现"></a>3.3 DECR 和 INCR 底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">// DECR key</div><div class="line">// INCR key</div><div class="line">//INCR和DECR命令的底层实现</div><div class="line">void incrDecrCommand(client *c, long long incr) &#123;</div><div class="line">    long long value, oldvalue;</div><div class="line">    robj *o, *new;</div><div class="line"></div><div class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);   //以写操作获取key的value对象</div><div class="line"></div><div class="line">    //找到了value对象但是value对象不是字符串类型，直接返回</div><div class="line">    if (o != NULL &amp;&amp; checkType(c,o,OBJ_STRING)) return;</div><div class="line"></div><div class="line">    //将字符串类型的value转换为longlong类型保存在value中</div><div class="line">    if (getLongLongFromObjectOrReply(c,o,&amp;value,NULL) != C_OK) return;</div><div class="line"></div><div class="line">    oldvalue = value;   //备份旧的value</div><div class="line"></div><div class="line">    //如果incr超出longlong类型所能表示的范围，发送错误信息</div><div class="line">    if ((incr &lt; 0 &amp;&amp; oldvalue &lt; 0 &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</div><div class="line">        (incr &gt; 0 &amp;&amp; oldvalue &gt; 0 &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</div><div class="line">        addReplyError(c,&quot;increment or decrement would overflow&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    value += incr;  //计算新的value值</div><div class="line"></div><div class="line">    //value对象目前非共享，编码为整型类型，且新value值不在共享范围，且value处于long类型所表示的范围内</div><div class="line">    if (o &amp;&amp; o-&gt;refcount == 1 &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</div><div class="line">        (value &lt; 0 || value &gt;= OBJ_SHARED_INTEGERS) &amp;&amp;</div><div class="line">        value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX)</div><div class="line">    &#123;</div><div class="line">        new = o;</div><div class="line">        o-&gt;ptr = (void*)((long)value);  //设置vlaue对象的值</div><div class="line">    &#125; else &#123;</div><div class="line">        //当不满足以上任意条件，则新创建一个字符串对象</div><div class="line">        new = createStringObjectFromLongLong(value);</div><div class="line"></div><div class="line">        //如果之前的value对象存在</div><div class="line">        if (o) &#123;</div><div class="line">            dbOverwrite(c-&gt;db,c-&gt;argv[1],new);  //用new对象去重写key的值</div><div class="line">        &#125; else &#123;</div><div class="line">            dbAdd(c-&gt;db,c-&gt;argv[1],new);        //如果之前的value不存在，将key和new组成新的key-value对</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);    //当数据库的键被改动，则会调用该函数发送信号</div><div class="line">    //发送&quot;incrby&quot;事件通知</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;incrby&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    //设置脏键</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //回复信息给client</div><div class="line">    addReply(c,shared.colon);</div><div class="line">    addReply(c,new);</div><div class="line">    addReply(c,shared.crlf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-APPEND-实现"><a href="#4-APPEND-实现" class="headerlink" title=".4 APPEND 实现"></a>.4 APPEND 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// APPEND key value</div><div class="line">// APPEND命令的实现</div><div class="line">void appendCommand(client *c) &#123;</div><div class="line">    size_t totlen;</div><div class="line">    robj *o, *append;</div><div class="line"></div><div class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);   //以写操作获取key的value对象</div><div class="line"></div><div class="line">    //如果没有获取到vlaue，则要创建一个</div><div class="line">    if (o == NULL) &#123;</div><div class="line">        /* Create the key */</div><div class="line">        c-&gt;argv[2] = tryObjectEncoding(c-&gt;argv[2]); //对参数value进行优化编码</div><div class="line">        dbAdd(c-&gt;db,c-&gt;argv[1],c-&gt;argv[2]); //将key和value组成新的key-value对</div><div class="line">        incrRefCount(c-&gt;argv[2]);           //增加value的引用计数</div><div class="line">        totlen = stringObjectLen(c-&gt;argv[2]);   //返回vlaue的长度</div><div class="line">    &#125; else &#123;    //获取到value</div><div class="line">        /* Key exists, check type */</div><div class="line">        if (checkType(c,o,OBJ_STRING))  //如果value不是字符串类型的对象直接返回</div><div class="line">            return;</div><div class="line"></div><div class="line">        /* &quot;append&quot; is an argument, so always an sds */</div><div class="line">        //获得追加的值对象</div><div class="line">        append = c-&gt;argv[2];</div><div class="line">        //计算追加后的长度</div><div class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</div><div class="line">        //如果追加后的长度超出范围，则返回</div><div class="line">        if (checkStringLength(c,totlen) != C_OK)</div><div class="line">            return;</div><div class="line"></div><div class="line">        /* Append the value */</div><div class="line">        //因为要根据value修改key的值，因此如果key原来的值是共享的，需要解除共享，新创建一个值对象与key组对</div><div class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);</div><div class="line">        //将vlaue对象的值后面追加上append的值</div><div class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</div><div class="line">        //计算出追加后值的长度</div><div class="line">        totlen = sdslen(o-&gt;ptr);</div><div class="line">    &#125;</div><div class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);//当数据库的键被改动，则会调用该函数发送信号</div><div class="line">    //发送&quot;append&quot;事件通知</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;append&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    //设置脏键</div><div class="line">    server.dirty++;</div><div class="line">    //发送追加后value的长度给client</div><div class="line">    addReplyLongLong(c,totlen);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/10/redis-analysis-redisobject/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/10/redis-analysis-redisobject/" itemprop="url">
                  Redis源码剖析和注释（八）--- redis对象(redisObject)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T18:39:02+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>redis中基于双端链表、简单动态字符串(sds)、字典、跳跃表、整数集合、压缩列表、快速列表等等数据结构实现了一个对象系统，并且实现了5种不同的对象，每种对象都使用了至少一种前面的数据结构，优化对象在不同场合下的使用效率。</p>
<h2 id="2-对象的系统的实现"><a href="#2-对象的系统的实现" class="headerlink" title="2. 对象的系统的实现"></a>2. 对象的系统的实现</h2><h3 id="2-1-对象的结构"><a href="#2-1-对象的结构" class="headerlink" title="2.1 对象的结构"></a>2.1 对象的结构</h3><p>对象结构robj功能：</p>
<ul>
<li>为5种不同的对象类型提供同一的表示形式。</li>
<li>为不同的对象适用于不同的场景，支持同一种对象类型采用多种的数据结构方式。</li>
<li>支持引用计数，实现对象共享机制。</li>
<li>记录对象的访问时间，便于删除对象。</li>
</ul>
<p>对象结构定义在redis 3.2版本的server.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#define LRU_BITS 24</div><div class="line">#define LRU_CLOCK_MAX ((1&lt;&lt;LRU_BITS)-1) /* Max value of obj-&gt;lru */</div><div class="line">#define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */</div><div class="line"></div><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，占4bits，共5种类型</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，占4bits，共10种类型</div><div class="line">    unsigned encoding:4;</div><div class="line"></div><div class="line">    //least recently used</div><div class="line">    //实用LRU算法计算相对server.lruclock的LRU时间</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line"></div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line"></div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div><div class="line"></div><div class="line">//type的占5种类型：</div><div class="line">/* Object types */</div><div class="line">#define OBJ_STRING 0    //字符串对象</div><div class="line">#define OBJ_LIST 1      //列表对象</div><div class="line">#define OBJ_SET 2       //集合对象</div><div class="line">#define OBJ_ZSET 3      //有序集合对象</div><div class="line">#define OBJ_HASH 4      //哈希对象</div><div class="line"></div><div class="line">/* Objects encoding. Some kind of objects like Strings and Hashes can be</div><div class="line"> * internally represented in multiple ways. The &apos;encoding&apos; field of the object</div><div class="line"> * is set to one of this fields for this object. */</div><div class="line">// encoding 的10种类型</div><div class="line">#define OBJ_ENCODING_RAW 0     /* Raw representation */     //原始表示方式，字符串对象是简单动态字符串</div><div class="line">#define OBJ_ENCODING_INT 1     /* Encoded as integer */         //long类型的整数</div><div class="line">#define OBJ_ENCODING_HT 2      /* Encoded as hash table */      //字典</div><div class="line">#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */          //不在使用</div><div class="line">#define OBJ_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */  //双端链表,不在使用</div><div class="line">#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */         //压缩列表</div><div class="line">#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */          //整数集合</div><div class="line">#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */      //跳跃表和字典</div><div class="line">#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */   //embstr编码的简单动态字符串</div><div class="line">#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */   //由压缩列表组成</div></pre></td></tr></table></figure></p>
<h3 id="2-2-字符串对象的底层实现类型"><a href="#2-2-字符串对象的底层实现类型" class="headerlink" title="2.2 字符串对象的底层实现类型"></a>2.2 字符串对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串实现的字符串对象</td>
</tr>
</tbody>
</table>
<h3 id="2-3-列表对象的底层实现类型"><a href="#2-3-列表对象的底层实现类型" class="headerlink" title="2.3 列表对象的底层实现类型"></a>2.3 列表对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>快速列表实现的列表对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的列表对象</td>
</tr>
</tbody>
</table>
<h3 id="2-4-集合对象的底层实现类型"><a href="#2-4-集合对象的底层实现类型" class="headerlink" title="2.4 集合对象的底层实现类型"></a>2.4 集合对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典实现的集合对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合实现的集合对象</td>
</tr>
</tbody>
</table>
<h3 id="2-5-哈希对象的底层实现类型"><a href="#2-5-哈希对象的底层实现类型" class="headerlink" title="2.5 哈希对象的底层实现类型"></a>2.5 哈希对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的哈希对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典实现的哈希对象</td>
</tr>
</tbody>
</table>
<h3 id="2-6-有序集合对象的底层实现类型"><a href="#2-6-有序集合对象的底层实现类型" class="headerlink" title="2.6 有序集合对象的底层实现类型"></a>2.6 有序集合对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳跃表和字典实现的有序集合对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的有序集合对象</td>
</tr>
</tbody>
</table>
<h2 id="3-对象系统的重要操作"><a href="#3-对象系统的重要操作" class="headerlink" title="3. 对象系统的重要操作"></a>3. 对象系统的重要操作</h2><h3 id="3-1创建一个字符串对象"><a href="#3-1创建一个字符串对象" class="headerlink" title="3.1创建一个字符串对象"></a>3.1创建一个字符串对象</h3><ul>
<li><p>编码为OBJ_ENCODING_RAW</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">robj *createObject(int type, void *ptr) &#123;   //创建一个对象</div><div class="line">    robj *o = zmalloc(sizeof(*o));          //分配空间</div><div class="line">    o-&gt;type = type;                         //设置对象类型</div><div class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;         //设置编码方式为OBJ_ENCODING_RAW</div><div class="line">    o-&gt;ptr = ptr;                           //设置</div><div class="line">    o-&gt;refcount = 1;                        //引用计数为1</div><div class="line"></div><div class="line">    /* Set the LRU to the current lruclock (minutes resolution). */</div><div class="line">    o-&gt;lru = LRU_CLOCK();                   //计算设置当前LRU时间</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编码为OBJ_ENCODING_EMBSTR</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is</div><div class="line"> * an object where the sds string is actually an unmodifiable string</div><div class="line"> * allocated in the same chunk as the object itself. */</div><div class="line">//创建一个embstr编码的字符串对象</div><div class="line">robj *createEmbeddedStringObject(const char *ptr, size_t len) &#123;</div><div class="line">    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);   //分配空间</div><div class="line">    struct sdshdr8 *sh = (void*)(o+1);  //o+1刚好就是struct sdshdr8的地址</div><div class="line"></div><div class="line">    o-&gt;type = OBJ_STRING;               //类型为字符串对象</div><div class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;  //设置编码类型OBJ_ENCODING_EMBSTR</div><div class="line">    o-&gt;ptr = sh+1;                      //指向分配的sds对象，分配的len+1的空间首地址</div><div class="line">    o-&gt;refcount = 1;                    //设置引用计数</div><div class="line">    o-&gt;lru = LRU_CLOCK();               //计算设置当前LRU时间</div><div class="line"></div><div class="line">    sh-&gt;len = len;                      //设置字符串长度</div><div class="line">    sh-&gt;alloc = len;                    //设置最大容量</div><div class="line">    sh-&gt;flags = SDS_TYPE_8;             //设置sds的类型</div><div class="line">    if (ptr) &#123;                          //如果传了字符串参数</div><div class="line">        memcpy(sh-&gt;buf,ptr,len);        //将传进来的ptr保存到对象中</div><div class="line">        sh-&gt;buf[len] = &apos;\0&apos;;            //结束符标志</div><div class="line">    &#125; else &#123;</div><div class="line">        memset(sh-&gt;buf,0,len+1);        //否则将对象的空间初始化为0</div><div class="line">    &#125;</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>两种字符串对象编码方式的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* Create a string object with EMBSTR encoding if it is smaller than</div><div class="line"> * REIDS_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is</div><div class="line"> * used.</div><div class="line"> *</div><div class="line"> * The current limit of 39 is chosen so that the biggest string object</div><div class="line"> * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */</div><div class="line"></div><div class="line">//sdshdr8的大小为3个字节，加上1个结束符共4个字节</div><div class="line">//redisObject的大小为16个字节</div><div class="line">//redis使用jemalloc内存分配器，且jemalloc会分配8，16，32，64等字节的内存</div><div class="line">//一个embstr固定的大小为16+3+1 = 20个字节，因此一个最大的embstr字符串为64-20 = 44字节</div><div class="line">#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</div><div class="line"></div><div class="line">// 创建字符串对象，根据长度使用不同的编码类型</div><div class="line">// createRawStringObject和createEmbeddedStringObject的区别是：</div><div class="line">// createRawStringObject是当字符串长度大于44字节时，robj结构和sdshdr结构在内存上是分开的</div><div class="line">// createEmbeddedStringObject是当字符串长度小于等于44字节时，robj结构和sdshdr结构在内存上是连续的</div><div class="line">robj *createStringObject(const char *ptr, size_t len) &#123;</div><div class="line">    if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</div><div class="line">        return createEmbeddedStringObject(ptr,len);</div><div class="line">    else</div><div class="line">        return createRawStringObject(ptr,len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-字符串对象编码的优化"><a href="#3-2-字符串对象编码的优化" class="headerlink" title="3.2 字符串对象编码的优化"></a>3.2 字符串对象编码的优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">/* Try to encode a string object in order to save space */</div><div class="line">//尝试优化字符串对象的编码方式以节约空间</div><div class="line">robj *tryObjectEncoding(robj *o) &#123;</div><div class="line">    long value;</div><div class="line">    sds s = o-&gt;ptr;</div><div class="line">    size_t len;</div><div class="line"></div><div class="line">    /* Make sure this is a string object, the only type we encode</div><div class="line">     * in this function. Other types use encoded memory efficient</div><div class="line">     * representations but are handled by the commands implementing</div><div class="line">     * the type. */</div><div class="line">    serverAssertWithInfo(NULL,o,o-&gt;type == OBJ_STRING);</div><div class="line"></div><div class="line">    /* We try some specialized encoding only for objects that are</div><div class="line">     * RAW or EMBSTR encoded, in other words objects that are still</div><div class="line">     * in represented by an actually array of chars. */</div><div class="line">    //如果字符串对象的编码类型为RAW或EMBSTR时，才对其重新编码</div><div class="line">    if (!sdsEncodedObject(o)) return o;</div><div class="line"></div><div class="line">    /* It&apos;s not safe to encode shared objects: shared objects can be shared</div><div class="line">     * everywhere in the &quot;object space&quot; of Redis and may end in places where</div><div class="line">     * they are not handled. We handle them only as values in the keyspace. */</div><div class="line">    //如果refcount大于1，则说明对象的ptr指向的值是共享的，不对共享对象进行编码</div><div class="line">     if (o-&gt;refcount &gt; 1) return o;</div><div class="line"></div><div class="line">    /* Check if we can represent this string as a long integer.</div><div class="line">     * Note that we are sure that a string larger than 20 chars is not</div><div class="line">     * representable as a 32 nor 64 bit integer. */</div><div class="line">    len = sdslen(s);            //获得字符串s的长度</div><div class="line"></div><div class="line">    //如果len小于等于20，表示符合long long可以表示的范围，且可以转换为long类型的字符串进行编码</div><div class="line">    if (len &lt;= 20 &amp;&amp; string2l(s,len,&amp;value)) &#123;</div><div class="line">        /* This object is encodable as a long. Try to use a shared object.</div><div class="line">         * Note that we avoid using shared integers when maxmemory is used</div><div class="line">         * because every object needs to have a private LRU field for the LRU</div><div class="line">         * algorithm to work well. */</div><div class="line">        if ((server.maxmemory == 0 ||</div><div class="line">             (server.maxmemory_policy != MAXMEMORY_VOLATILE_LRU &amp;&amp;</div><div class="line">              server.maxmemory_policy != MAXMEMORY_ALLKEYS_LRU)) &amp;&amp;</div><div class="line">            value &gt;= 0 &amp;&amp;</div><div class="line">            value &lt; OBJ_SHARED_INTEGERS)    //如果value处于共享整数的范围内</div><div class="line">        &#123;</div><div class="line">            decrRefCount(o);                //原对象的引用计数减1，释放对象</div><div class="line">            incrRefCount(shared.integers[value]); //增加共享对象的引用计数</div><div class="line">            return shared.integers[value];      //返回一个编码为整数的字符串对象</div><div class="line">        &#125; else &#123;        //如果不处于共享整数的范围</div><div class="line">            if (o-&gt;encoding == OBJ_ENCODING_RAW) sdsfree(o-&gt;ptr);   //释放编码为OBJ_ENCODING_RAW的对象</div><div class="line">            o-&gt;encoding = OBJ_ENCODING_INT;     //转换为OBJ_ENCODING_INT编码</div><div class="line">            o-&gt;ptr = (void*) value;             //指针ptr指向value对象</div><div class="line">            return o;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If the string is small and is still RAW encoded,</div><div class="line">     * try the EMBSTR encoding which is more efficient.</div><div class="line">     * In this representation the object and the SDS string are allocated</div><div class="line">     * in the same chunk of memory to save space and cache misses. */</div><div class="line">    //如果len小于44，44是最大的编码为EMBSTR类型的字符串对象长度</div><div class="line">    if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123;</div><div class="line">        robj *emb;</div><div class="line"></div><div class="line">        if (o-&gt;encoding == OBJ_ENCODING_EMBSTR) return o;   //将RAW对象转换为OBJ_ENCODING_EMBSTR编码类型</div><div class="line">        emb = createEmbeddedStringObject(s,sdslen(s)); //创建一个编码类型为OBJ_ENCODING_EMBSTR的字符串对象</div><div class="line">        decrRefCount(o);    //释放之前的对象</div><div class="line">        return emb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* We can&apos;t encode the object...</div><div class="line">     *</div><div class="line">     * Do the last try, and at least optimize the SDS string inside</div><div class="line">     * the string object to require little space, in case there</div><div class="line">     * is more than 10% of free space at the end of the SDS string.</div><div class="line">     *</div><div class="line">     * We do that only for relatively large strings as this branch</div><div class="line">     * is only entered if the length of the string is greater than</div><div class="line">     * OBJ_ENCODING_EMBSTR_SIZE_LIMIT. */</div><div class="line">    //无法进行编码，但是如果s的未使用的空间大于使用空间的10分之1</div><div class="line">    if (o-&gt;encoding == OBJ_ENCODING_RAW &amp;&amp;</div><div class="line">        sdsavail(s) &gt; len/10)</div><div class="line">    &#123;</div><div class="line">        o-&gt;ptr = sdsRemoveFreeSpace(o-&gt;ptr);    //释放所有的未使用空间</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Return the original object. */</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-引用计数管理对象"><a href="#3-3-引用计数管理对象" class="headerlink" title="3.3 引用计数管理对象"></a>3.3 引用计数管理对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//引用计数加1</div><div class="line">void incrRefCount(robj *o) &#123;</div><div class="line">    o-&gt;refcount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//引用计数减1</div><div class="line">void decrRefCount(robj *o) &#123;</div><div class="line">    if (o-&gt;refcount &lt;= 0) serverPanic(&quot;decrRefCount against refcount &lt;= 0&quot;);</div><div class="line"></div><div class="line">    //当引用对象等于1时，在操作引用计数减1，直接释放对象的ptr和对象空间</div><div class="line">    if (o-&gt;refcount == 1) &#123;</div><div class="line">        switch(o-&gt;type) &#123;</div><div class="line">        case OBJ_STRING: freeStringObject(o); break;</div><div class="line">        case OBJ_LIST: freeListObject(o); break;</div><div class="line">        case OBJ_SET: freeSetObject(o); break;</div><div class="line">        case OBJ_ZSET: freeZsetObject(o); break;</div><div class="line">        case OBJ_HASH: freeHashObject(o); break;</div><div class="line">        default: serverPanic(&quot;Unknown object type&quot;); break;</div><div class="line">        &#125;</div><div class="line">        zfree(o);</div><div class="line">    &#125; else &#123;</div><div class="line">        o-&gt;refcount--;  //否则减1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-对象的复制，创建的对象非共享"><a href="#3-4-对象的复制，创建的对象非共享" class="headerlink" title="3.4 对象的复制，创建的对象非共享"></a>3.4 对象的复制，创建的对象非共享</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//返回 复制的o对象的副本的地址，且创建的对象非共享</div><div class="line">robj *dupStringObject(robj *o) &#123;</div><div class="line">    robj *d;</div><div class="line"></div><div class="line">    serverAssert(o-&gt;type == OBJ_STRING);    //一定是OBJ_STRING类型</div><div class="line"></div><div class="line">    switch(o-&gt;encoding) &#123;                   //根据不同的编码类型</div><div class="line">    case OBJ_ENCODING_RAW:</div><div class="line">        return createRawStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));        //创建的对象非共享</div><div class="line">    case OBJ_ENCODING_EMBSTR:</div><div class="line">        return createEmbeddedStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));   //创建的对象非共享</div><div class="line">    case OBJ_ENCODING_INT:                  //整数编码类型</div><div class="line">        d = createObject(OBJ_STRING, NULL); //即使是共享整数范围内的整数，创建的对象也是非共享的</div><div class="line">        d-&gt;encoding = OBJ_ENCODING_INT;</div><div class="line">        d-&gt;ptr = o-&gt;ptr;</div><div class="line">        return d;</div><div class="line">    default:</div><div class="line">        serverPanic(&quot;Wrong encoding.&quot;);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-5-对象的解码操作"><a href="#3-5-对象的解码操作" class="headerlink" title="3.5 对象的解码操作"></a>3.5 对象的解码操作</h3><p>将保存的整数值解码成字符串对象返回回来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/* Get a decoded version of an encoded object (returned as a new object).</div><div class="line"> * If the object is already raw-encoded just increment the ref count. */</div><div class="line">//将对象是整型的解码为字符串并返回，如果是字符串编码则直接返回输入对象，只需增加引用计数</div><div class="line">robj *getDecodedObject(robj *o) &#123;</div><div class="line">    robj *dec;</div><div class="line"></div><div class="line">    if (sdsEncodedObject(o)) &#123;  //如果是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR类型的对象</div><div class="line">        incrRefCount(o);        //增加引用计数，返回一个共享的对象</div><div class="line">        return o;</div><div class="line">    &#125;</div><div class="line">    if (o-&gt;type == OBJ_STRING &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT) &#123; //如果是整数对象</div><div class="line">        char buf[32];</div><div class="line"></div><div class="line">        ll2string(buf,32,(long)o-&gt;ptr); //将整数转换为字符串</div><div class="line">        dec = createStringObject(buf,strlen(buf));  //创建一个字符串对象</div><div class="line">        return dec;</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown encoding type&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/10/redis-analysis-standalone/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/10/redis-analysis-standalone/" itemprop="url">
                  Redis源码剖析和注释（二十一）--- 单机服务器实现
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T18:39:02+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Redis-服务器"><a href="#1-Redis-服务器" class="headerlink" title="1. Redis 服务器"></a>1. Redis 服务器</h2><p>Redis服务器负责与客户端建立网络连接，处理发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并且通过一系列资源管理措施来维持服务器自身的正常运转。本次主要剖析server.c文件，本文主要介绍Redis服务器的一下几个实现：</p>
<ul>
<li>命令的执行过程</li>
<li>Redis服务器的周期性任务</li>
<li>maxmemory的策略</li>
<li>Redis服务器的main函数</li>
</ul>
<h2 id="2-命令的执行过程"><a href="#2-命令的执行过程" class="headerlink" title="2. 命令的执行过程"></a>2. 命令的执行过程</h2><p>Redis一个命令的完整执行过程如下：</p>
<ul>
<li>客户端发送命令请求</li>
<li>服务器接收命令请求</li>
<li>服务器执行命令请求</li>
<li>将回复发送给客户端<br>关于命令接收与命令回复，在Redis 网络连接库剖析一文已经详细剖析过，本篇主要针对第三步，也就是服务器执行命令的过程进行剖析。</li>
</ul>
<p>服务器在接收到命令后，会将命令以对象的形式保存在服务器client的参数列表robj **argv中，因此服务器执行命令请求时，服务器已经读入了一套命令参数保存在参数列表中。执行命令的过程对应的函数是processCommand()，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div></pre></td><td class="code"><pre><div class="line">// 如果client没有被关闭则返回C_OK，调用者可以继续执行其他的操作，否则返回C_ERR，表示client被销毁</div><div class="line">int processCommand(client *c) &#123;</div><div class="line">    // 如果是 quit 命令，则单独处理</div><div class="line">    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;quit&quot;)) &#123;</div><div class="line">        addReply(c,shared.ok);</div><div class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;   //设置client的状态为回复后立即关闭，返回C_ERR</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从数据库的字典中查找该命令</div><div class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</div><div class="line">    // 不存在的命令</div><div class="line">    if (!c-&gt;cmd) &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReplyErrorFormat(c,&quot;unknown command &apos;%s&apos;&quot;,</div><div class="line">            (char*)c-&gt;argv[0]-&gt;ptr);</div><div class="line">        return C_OK;</div><div class="line">    // 参数数量不匹配</div><div class="line">    &#125; else if ((c-&gt;cmd-&gt;arity &gt; 0 &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</div><div class="line">               (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReplyErrorFormat(c,&quot;wrong number of arguments for &apos;%s&apos; command&quot;,</div><div class="line">            c-&gt;cmd-&gt;name);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if the user is authenticated */</div><div class="line">    // 如果服务器设置了密码，但是没有认证成功</div><div class="line">    if (server.requirepass &amp;&amp; !c-&gt;authenticated &amp;&amp; c-&gt;cmd-&gt;proc != authCommand)</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReply(c,shared.noautherr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果开启了集群模式，则执行集群的重定向操作，下面的两种情况例外：</div><div class="line">    /*</div><div class="line">        1. 命令的发送是主节点服务器</div><div class="line">        2. 命令没有key</div><div class="line">    */</div><div class="line">    if (server.cluster_enabled &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</div><div class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0 &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != execCommand))</div><div class="line">    &#123;</div><div class="line">        int hashslot;</div><div class="line">        int error_code;</div><div class="line">        // 从集群中返回一个能够执行命令的节点</div><div class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</div><div class="line">                                        &amp;hashslot,&amp;error_code);</div><div class="line">        // 返回的节点不合格</div><div class="line">        if (n == NULL || n != server.cluster-&gt;myself) &#123;</div><div class="line">            // 如果是执行事务的命令，则取消事务</div><div class="line">            if (c-&gt;cmd-&gt;proc == execCommand) &#123;</div><div class="line">                discardTransaction(c);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 将事务状态设置为失败</div><div class="line">                flagTransaction(c);</div><div class="line">            &#125;</div><div class="line">            // 执行client的重定向操作</div><div class="line">            clusterRedirectClient(c,n,hashslot,error_code);</div><div class="line">            return C_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器有最大内存的限制</div><div class="line">    if (server.maxmemory) &#123;</div><div class="line">        // 按需释放一部分内存</div><div class="line">        int retval = freeMemoryIfNeeded();</div><div class="line">        // freeMemoryIfNeeded()函数之后需要冲洗从节点的输出缓冲区，这可能导致被释放的从节点是一个活跃的client</div><div class="line">        // 如果当前的client被释放，返回C_ERR</div><div class="line">        if (server.current_client == NULL) return C_ERR;</div><div class="line"></div><div class="line">        // 如果命令会耗费大量的内存但是释放内存失败</div><div class="line">        if ((c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM) &amp;&amp; retval == C_ERR) &#123;</div><div class="line">            // 将事务状态设置为失败</div><div class="line">            flagTransaction(c);</div><div class="line">            addReply(c, shared.oomerr);</div><div class="line">            return C_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果 BGSAVE 命令执行错误而且服务器是一个主节点，那么不接受写命令</div><div class="line">    if (((server.stop_writes_on_bgsave_err &amp;&amp;</div><div class="line">          server.saveparamslen &gt; 0 &amp;&amp;</div><div class="line">          server.lastbgsave_status == C_ERR) ||</div><div class="line">          server.aof_last_write_status == C_ERR) &amp;&amp;</div><div class="line">        server.masterhost == NULL &amp;&amp;</div><div class="line">        (c-&gt;cmd-&gt;flags &amp; CMD_WRITE ||</div><div class="line">         c-&gt;cmd-&gt;proc == pingCommand))</div><div class="line">    &#123;</div><div class="line">        // 将事务状态设置为失败</div><div class="line">        flagTransaction(c);</div><div class="line">        // 如果上一次执行AOF成功回复BGSAVE错误回复</div><div class="line">        if (server.aof_last_write_status == C_OK)</div><div class="line">            addReply(c, shared.bgsaveerr);</div><div class="line">        else</div><div class="line">            addReplySds(c,</div><div class="line">                sdscatprintf(sdsempty(),</div><div class="line">                &quot;-MISCONF Errors writing to the AOF file: %s\r\n&quot;,</div><div class="line">                strerror(server.aof_last_write_errno)));</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有足够的良好的从节点而且用户配置了 min-slaves-to-write，那么不接受写命令</div><div class="line">    if (server.masterhost == NULL &amp;&amp;</div><div class="line">        server.repl_min_slaves_to_write &amp;&amp;</div><div class="line">        server.repl_min_slaves_max_lag &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;flags &amp; CMD_WRITE &amp;&amp;</div><div class="line">        server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</div><div class="line">    &#123;</div><div class="line">        // 将事务状态设置为失败</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.noreplicaserr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果这是一个只读的从节点服务器，则不接受写命令</div><div class="line">    if (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;flags &amp; CMD_WRITE)</div><div class="line">    &#123;</div><div class="line">        addReply(c, shared.roslaveerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果处于发布订阅模式，但是执行的不是发布订阅命令，返回</div><div class="line">    if (c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != punsubscribeCommand) &#123;</div><div class="line">        addReplyError(c,&quot;only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context&quot;);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果是从节点且和主节点断开了连接，不允许从服务器带有过期数据，返回</div><div class="line">    if (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</div><div class="line">        server.repl_serve_stale_data == 0 &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;flags &amp; CMD_STALE))</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.masterdownerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器处于载入状态，如果命令不是CMD_LOADING标识，则不执行，返回</div><div class="line">    if (server.loading &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING)) &#123;</div><div class="line">        addReply(c, shared.loadingerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果lua脚本超时，限制执行一部分命令，如shutdown、scriptCommand</div><div class="line">    if (server.lua_timedout &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</div><div class="line">          c-&gt;argc == 2 &amp;&amp;</div><div class="line">          tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == &apos;n&apos;) &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</div><div class="line">          c-&gt;argc == 2 &amp;&amp;</div><div class="line">          tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == &apos;k&apos;))</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.slowscripterr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行命令</div><div class="line">    // client处于事务环境中，但是执行命令不是exec、discard、multi和watch</div><div class="line">    if (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</div><div class="line">    &#123;</div><div class="line">        // 除了上述的四个命令，其他的命令添加到事务队列中</div><div class="line">        queueMultiCommand(c);</div><div class="line">        addReply(c,shared.queued);</div><div class="line">    // 执行普通的命令</div><div class="line">    &#125; else &#123;</div><div class="line">        call(c,CMD_CALL_FULL);</div><div class="line">        // 保存写全局的复制偏移量</div><div class="line">        c-&gt;woff = server.master_repl_offset;</div><div class="line">        // 如果因为BLPOP而阻塞的命令已经准备好，则处理client的阻塞状态</div><div class="line">        if (listLength(server.ready_keys))</div><div class="line">            handleClientsBlockedOnLists();</div><div class="line">    &#125;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们总结出执行命令的大致过程：</p>
<ul>
<li>查找命令。对应的代码是：c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</li>
<li>执行命令前的准备。对应这些判断语句。</li>
<li>执行命令。对应代码是：call(c,CMD_CALL_FULL);</li>
</ul>
<p>我们就大致就这三个过程详细解释。</p>
<h3 id="2-1-查找命令"><a href="#2-1-查找命令" class="headerlink" title="2.1 查找命令"></a>2.1 查找命令</h3><p>lookupCommand()函数是对dictFetchValue(server.commands, name);的封装。而这个函数的意思是：从server.commands字典中查找name命令。这个保存命令表的字典，键是命令的名称，值是命令表的地址。因此我们介绍服务器初始化时的一个操作，就是创建一张命令表。命令表代码简化表示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct redisCommand redisCommandTable[] = &#123;</div><div class="line">    &#123;&quot;get&quot;,getCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0&#125;,</div><div class="line">    &#123;&quot;set&quot;,setCommand,-3,&quot;wm&quot;,0,NULL,1,1,1,0,0&#125;,</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们只展示了命令表的两条，可以通过COMMAND COUNT命令查看命令的个数。虽然只有两条，但是可以说明问题。</p>
<p>首先命令表是就是一个数组，数组的每个成员都是一个struct redisCommand结构体，对每个数组成员都进行了初始化。我们一次对每个值进行分析：以GET命令为例子。</p>
<ul>
<li>char *name：命令的名字。对应 “get”。</li>
<li>redisCommandProc *proc：命令实现的函数。对应 getCommand。</li>
<li>int arity：参数个数，-N表示大于等于N。对应2。</li>
<li>char *sflags：命令的属性，用以下字符作为标识。对应”rF”。 <ul>
<li>w：写入命令，会修改数据库。</li>
<li>r：读取命令，不会修改数据库。</li>
<li>m：一旦执行会增加内存使用，如果内存短缺则不被允许执行。</li>
<li>a：管理员命令，例如：SAVE or SHUTDOWN。</li>
<li>p：发布订阅有关的命令。</li>
<li>f：强制进行复制的命令，无视服务器的脏键。</li>
<li>s：不能在脚本中执行的命令。</li>
<li>R：随机命令。相同的键有相同的参数，在相同的数据库中，可能会有不同的结果。</li>
<li>S：如果在脚本中调用，那么会对这个命令的输出进行一次排序。</li>
<li>l：当载入数据库时，允许执行该命令。</li>
<li>t：从节点服务器持有过期数据时，允许执行的命令。</li>
<li>M：不能在 MONITOR 下自动传播的命令。</li>
<li>k：为该命令执行一个隐式的ASKING，所以在集群模式下，如果槽被标记为’importing’，那这个命令会被接收。<br>*F：快速执行的命令。时间复杂度为O(1) or O(log(N))的命令只要内核调度为Redis分配时间片，那么就不应该在执行时被延迟。</li>
</ul>
</li>
<li>int flags：sflags的二进制标识形式，可以通过位运算进行组合。对应0。</li>
<li>redisGetKeysProc *getkeys_proc：从命令中获取键的参数，是一个可选的功能，一般用于三个字段不够执行键的参数的情况。对应NULL。</li>
<li>int firstkey：第一个参数是 key。对应1。</li>
<li>int lastkey：最后一个参数是 key。对应1。</li>
<li>int keystep：从第一个 key 到最后一个 key 的步长。MSET 的步长是 2 因为：key,val,key,val,…。对应1。</li>
<li>long long microseconds：记录执行命令的耗费总时长。对应0。</li>
<li>long long calls：记录命令被执行的总次数。对应0。<br>当从命令表中找到命令后，会将找到的命令的地址，返回给struct redisCommand <em>cmd, </em>lastcmd;这两个指针保存起来。到此查找命令的操作就完成。</li>
</ul>
<h2 id="2-2-执行命令前的准备"><a href="#2-2-执行命令前的准备" class="headerlink" title="2.2 执行命令前的准备"></a>2.2 执行命令前的准备</h2><p>此时，命令已经在命令表中查找到，并且保存在了对应的指针中。但是真正执行前，还进行了许多的情况的判断。我们简单列举几种。</p>
<ul>
<li>首先就是判断命令的参数是否匹配。</li>
<li>检查服务器的认证是否通过。</li>
<li>集群模式下的判断。</li>
<li>服务器最大内存限制是否通过。</li>
<li>某些情况下，不接受写命令。</li>
<li>发布订阅模式。</li>
<li>是否是lua脚本中的命令。<br>等等……<br>所以，命令执行的过程还是很复杂的，简单总结一句：命令不易，何况人生。</li>
</ul>
<p>2.3 执行命令<br>执行命令调用了call(c,CMD_CALL_FULL)函数，该函数是执行命令的核心。但是不用想，这个函数一定是对回调函数c-&gt;cmd-&gt;proc(c)的封装，因为proc指向命令的实现函数。我们贴出该函数的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">void call(client *c, int flags) &#123;</div><div class="line">    long long dirty, start, duration;</div><div class="line">    int client_old_flags = c-&gt;flags;    //备份client的flags</div><div class="line"></div><div class="line">    // 将命令发送给 MONITOR</div><div class="line">    if (listLength(server.monitors) &amp;&amp;</div><div class="line">        !server.loading &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</div><div class="line">    &#123;</div><div class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清除一些需要按照命令需求设置的标志，以防干扰</div><div class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line">    // 初始化Redis操作数组，用来追加命令的传播</div><div class="line">    redisOpArrayInit(&amp;server.also_propagate);</div><div class="line"></div><div class="line">    /* Call the command. */</div><div class="line">    // 备份脏键数</div><div class="line">    dirty = server.dirty;</div><div class="line">    // 获取执行命令的开始时间</div><div class="line">    start = ustime();</div><div class="line">    // 执行命令</div><div class="line">    c-&gt;cmd-&gt;proc(c);</div><div class="line">    // 命令的执行时间</div><div class="line">    duration = ustime()-start;</div><div class="line">    // 命令修改的键的个数</div><div class="line">    dirty = server.dirty-dirty;</div><div class="line">    if (dirty &lt; 0) dirty = 0;</div><div class="line"></div><div class="line">    // 当执行 EVAL 命令时正在加载AOF，而且不希望Lua调用的命令进入slowlog或填充统计信息</div><div class="line">    if (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</div><div class="line">        flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);  //取消慢查询和记录统计信息的标志</div><div class="line"></div><div class="line">    // 如果函数调用者是Lua脚本，且命令的flags或客户端的flags指定了强制传播，我们要强制EVAL调用者传播脚本</div><div class="line">    if (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) &#123;</div><div class="line">        // 如果指定了强制将命令传播到从节点</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_REPL)</div><div class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;  //强制执行lua脚本的client要传播命令到从节点</div><div class="line">        // 如果指定了强制将节点传播到AOF中</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_AOF)</div><div class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;   //强制执行lua脚本的client要传播命令到AOF文件</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 命令的flags指定了慢查询标志，要将总的统计信息推入慢查询日志中</div><div class="line">    if (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; c-&gt;cmd-&gt;proc != execCommand) &#123;</div><div class="line">        char *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</div><div class="line">                              &quot;fast-command&quot; : &quot;command&quot;;</div><div class="line">        // 记录将延迟事件和延迟时间关联到延迟诊断的字典中</div><div class="line">        latencyAddSampleIfNeeded(latency_event,duration/1000);</div><div class="line">        // 将总的统计信息推入慢查询日志中</div><div class="line">        slowlogPushEntryIfNeeded(c-&gt;argv,c-&gt;argc,duration);</div><div class="line">    &#125;</div><div class="line">    // 命令的flags指定了CMD_CALL_STATS，更新命令的统计信息</div><div class="line">    if (flags &amp; CMD_CALL_STATS) &#123;</div><div class="line">        c-&gt;lastcmd-&gt;microseconds += duration;</div><div class="line">        c-&gt;lastcmd-&gt;calls++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器或追加到AOF中</div><div class="line">    if (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</div><div class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</div><div class="line">    &#123;</div><div class="line">        // 保存传播的标志，初始化为空</div><div class="line">        int propagate_flags = PROPAGATE_NONE;</div><div class="line"></div><div class="line">        // 如果命令修改了数据库中的键，则要传播到AOF和从节点中</div><div class="line">        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</div><div class="line"></div><div class="line">        // 如果client设置了强制AOF和复制的标志，则设置传播的标志</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</div><div class="line"></div><div class="line">        // 如果client的flags设置了CLIENT_PREVENT_REPL/AOF_PROP，表示阻止命令的传播到从节点或AOF，则取消传播对应标志</div><div class="line">        if (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</div><div class="line">            !(flags &amp; CMD_CALL_PROPAGATE_REPL))</div><div class="line">                propagate_flags &amp;= ~PROPAGATE_REPL;</div><div class="line">        if (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</div><div class="line">            !(flags &amp; CMD_CALL_PROPAGATE_AOF))</div><div class="line">                propagate_flags &amp;= ~PROPAGATE_AOF;</div><div class="line"></div><div class="line">        // 如果至少设置了一种传播，则执行相应传播命令操作</div><div class="line">        if (propagate_flags != PROPAGATE_NONE)</div><div class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清除一些需要按照命令需求设置的标志，以防干扰</div><div class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line">    // 恢复client原始的flags</div><div class="line">    c-&gt;flags |= client_old_flags &amp;</div><div class="line">        (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line"></div><div class="line">    // 传播追加在Redis操作数组中的命令</div><div class="line">    if (server.also_propagate.numops) &#123;</div><div class="line">        int j;</div><div class="line">        redisOp *rop;</div><div class="line">        // 如果命令的flags设置传播的标志</div><div class="line">        if (flags &amp; CMD_CALL_PROPAGATE) &#123;</div><div class="line">            // 遍历所有的命令</div><div class="line">            for (j = 0; j &lt; server.also_propagate.numops; j++) &#123;</div><div class="line">                rop = &amp;server.also_propagate.ops[j];</div><div class="line">                int target = rop-&gt;target;</div><div class="line">                /* Whatever the command wish is, we honor the call() flags. */</div><div class="line">                // 执行相应传播命令操作</div><div class="line">                if (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</div><div class="line">                if (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</div><div class="line">                if (target)</div><div class="line">                    propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 释放Redis操作数组</div><div class="line">        redisOpArrayFree(&amp;server.also_propagate);</div><div class="line">    &#125;</div><div class="line">    // 命令执行的次数加1</div><div class="line">    server.stat_numcommands++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行命令时，可以指定一个flags。这个flags是用于执行完命令之后的一些后续工作。我们说明这些flags的含义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CMD_CALL_NONE：没有指定flags</div><div class="line">CMD_CALL_SLOWLOG：检查命令的执行速度，如果需要记录在慢查询日志中</div><div class="line">CMD_CALL_STATS：记录命令的统计信息</div><div class="line">CMD_CALL_PROPAGATE_AOF：如果client设置了强制传播的标志或修改了数据集，则将命令追加到AOF文件中</div><div class="line">CMD_CALL_PROPAGATE_REPL：如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器中</div><div class="line">CMD_CALL_PROPAGATE：如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器或追加到AOF中</div><div class="line">CMD_CALL_FULL：包含以上所有的含义</div></pre></td></tr></table></figure></p>
<p>执行命令c-&gt;cmd-&gt;proc(c)就相当于执行了命令实现的函数，然后会在执行完成后，由这些函数产生相应的命令回复，根据回复的大小，会将回复保存在输出缓冲区buf或回复链表repl中。然后服务器会调用writeToClient()函数来将回复写到fd中。详细请看：Redis 网络连接库剖析。</p>
<p>至此，一条命令的执行过程就很清楚明了了。</p>
<h2 id="3-Redis服务器的周期性任务"><a href="#3-Redis服务器的周期性任务" class="headerlink" title="3. Redis服务器的周期性任务"></a>3. Redis服务器的周期性任务</h2><p>我们曾经在Redis 事件处理实现一文中说到，Redis的事件分为文件事件（file event）和时间事件（time event）。时间事件虽然是晚于文件事件执行，但是会每隔100ms都会执行一次。话不多说直接上代码：Redis 单机服务器实现源码注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div></pre></td><td class="code"><pre><div class="line">// 使用一个宏定义：run_with_period(milliseconds) &#123; .... &#125;，实现一部分代码有次数限制的被执行</div><div class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;</div><div class="line">    int j;</div><div class="line">    UNUSED(eventLoop);</div><div class="line">    UNUSED(id);</div><div class="line">    UNUSED(clientData);</div><div class="line"></div><div class="line">    // 如果设置了看门狗，则在过期时间内，递达一个 SIGALRM 信号</div><div class="line">    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);</div><div class="line"></div><div class="line">    // 设置服务器的时间缓存</div><div class="line">    updateCachedTime();</div><div class="line"></div><div class="line">    // 更新服务器的一些统计值</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        // 命令执行的次数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);</div><div class="line">        // 从网络读到的字节数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,</div><div class="line">                server.stat_net_input_bytes);</div><div class="line">        // 已经写到网络的字节数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,</div><div class="line">                server.stat_net_output_bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 服务器的LRU时间表示位数为24位，因此最长表示2^24秒，大约1.5年，只要在1.5年内，该对象被访问，那么就不会出现对象的LRU时间比服务器的时钟还要年轻的现象</div><div class="line">    // LRU_CLOCK_RESOLUTION 可以改变LRU时间的精度</div><div class="line"></div><div class="line">    // 获取服务器的LRU时钟</div><div class="line">    server.lruclock = getLRUClock();</div><div class="line"></div><div class="line">    // 更新服务器的最大内存使用量峰值</div><div class="line">    if (zmalloc_used_memory() &gt; server.stat_peak_memory)</div><div class="line">        server.stat_peak_memory = zmalloc_used_memory();</div><div class="line"></div><div class="line">    // 更新常驻内存的大小</div><div class="line">    server.resident_set_size = zmalloc_get_rss();</div><div class="line"></div><div class="line">    // 安全的关闭服务器</div><div class="line">    if (server.shutdown_asap) &#123;</div><div class="line">        // 关闭服务器前的准备动作，成功则关闭服务器</div><div class="line">        if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);</div><div class="line">        // 失败则打印日志</div><div class="line">        serverLog(LL_WARNING,&quot;SIGTERM received but errors trying to shut down the server, check the logs for more information&quot;);</div><div class="line">        // 撤销关闭服务器标志</div><div class="line">        server.shutdown_asap = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 打印数据库的信息到日志中</div><div class="line">    run_with_period(5000) &#123;</div><div class="line">        // 遍历数据库</div><div class="line">        for (j = 0; j &lt; server.dbnum; j++) &#123;</div><div class="line">            long long size, used, vkeys;</div><div class="line"></div><div class="line">            // 获取当前数据库的键值对字典的槽位数，键值对字典已使用的数量，过期键字典已使用的数量</div><div class="line">            size = dictSlots(server.db[j].dict);</div><div class="line">            used = dictSize(server.db[j].dict);</div><div class="line">            vkeys = dictSize(server.db[j].expires);</div><div class="line">            // 打印到日志中</div><div class="line">            if (used || vkeys) &#123;</div><div class="line">                serverLog(LL_VERBOSE,&quot;DB %d: %lld keys (%lld volatile) in %lld slots HT.&quot;,j,used,vkeys,size);</div><div class="line">                /* dictPrintStats(server.dict); */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器不在哨兵模式下，那么周期性打印一些连接client的信息到日志中</div><div class="line">    if (!server.sentinel_mode) &#123;</div><div class="line">        run_with_period(5000) &#123;</div><div class="line">            serverLog(LL_VERBOSE,</div><div class="line">                &quot;%lu clients connected (%lu slaves), %zu bytes in use&quot;,</div><div class="line">                listLength(server.clients)-listLength(server.slaves),</div><div class="line">                listLength(server.slaves),</div><div class="line">                zmalloc_used_memory());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行client的周期性任务</div><div class="line">    clientsCron();</div><div class="line"></div><div class="line">    // 执行数据库的周期性任务</div><div class="line">    databasesCron();</div><div class="line"></div><div class="line">    // 如果当前没有正在进行RDB和AOF持久化操作，且AOF重写操作被提上了日程，那么在后台执行AOF的重写操作</div><div class="line">    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</div><div class="line">        server.aof_rewrite_scheduled)</div><div class="line">    &#123;</div><div class="line">        rewriteAppendOnlyFileBackground();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果正在进行RDB或AOF重写等操作，那么等待接收子进程发来的信息</div><div class="line">    if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||</div><div class="line">        ldbPendingChildren())</div><div class="line">    &#123;</div><div class="line">        int statloc;</div><div class="line">        pid_t pid;</div><div class="line"></div><div class="line">        // 接收所有子进程发送的信号，非阻塞</div><div class="line">        if ((pid = wait3(&amp;statloc,WNOHANG,NULL)) != 0) &#123;</div><div class="line">            // 获取退出码</div><div class="line">            int exitcode = WEXITSTATUS(statloc);</div><div class="line">            int bysignal = 0;</div><div class="line"></div><div class="line">            // 判断子进程是否因为信号而终止，是的话，取得子进程因信号而中止的信号码</div><div class="line">            if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</div><div class="line"></div><div class="line">            // 子进程没有退出，还在进行RDB或AOF重写等操作</div><div class="line">            if (pid == -1) &#123;</div><div class="line">                // 打印日志</div><div class="line">                serverLog(LL_WARNING,&quot;wait3() returned an error: %s. &quot;</div><div class="line">                    &quot;rdb_child_pid = %d, aof_child_pid = %d&quot;,</div><div class="line">                    strerror(errno),</div><div class="line">                    (int) server.rdb_child_pid,</div><div class="line">                    (int) server.aof_child_pid);</div><div class="line">            // RDB持久化完成</div><div class="line">            &#125; else if (pid == server.rdb_child_pid) &#123;</div><div class="line">                // 将RDB文件写入磁盘或网络中</div><div class="line">                backgroundSaveDoneHandler(exitcode,bysignal);</div><div class="line">            // AOF持久化完成</div><div class="line">            &#125; else if (pid == server.aof_child_pid) &#123;</div><div class="line">                // 将重写缓冲区的命令追加AOF文件中，且进行同步操作</div><div class="line">                backgroundRewriteDoneHandler(exitcode,bysignal);</div><div class="line">            // 其他子进程，打印日志</div><div class="line">            &#125; else &#123;</div><div class="line">                if (!ldbRemoveChild(pid)) &#123;</div><div class="line">                    serverLog(LL_WARNING,</div><div class="line">                        &quot;Warning, detected child with unmatched pid: %ld&quot;,</div><div class="line">                        (long)pid);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 更新能否resize哈希的策略</div><div class="line">            updateDictResizePolicy();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    // 没有正在进行RDB或AOF重写等操作，那么检查是否需要执行</div><div class="line">    &#125; else &#123;</div><div class="line">        // 遍历save命令的参数数组</div><div class="line">         for (j = 0; j &lt; server.saveparamslen; j++) &#123;</div><div class="line">            struct saveparam *sp = server.saveparams+j;</div><div class="line"></div><div class="line">            // 数据库的键被修改的次数大于SAVE命令参数指定的修改次数，且已经过了SAVE命令参数指定的秒数</div><div class="line">            if (server.dirty &gt;= sp-&gt;changes &amp;&amp;</div><div class="line">                server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</div><div class="line">                (server.unixtime-server.lastbgsave_try &gt;</div><div class="line">                 CONFIG_BGSAVE_RETRY_DELAY ||</div><div class="line">                 server.lastbgsave_status == C_OK))</div><div class="line">            &#123;</div><div class="line">                serverLog(LL_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;,</div><div class="line">                    sp-&gt;changes, (int)sp-&gt;seconds);</div><div class="line">                // 进行 BGSAVE 操作</div><div class="line">                rdbSaveBackground(server.rdb_filename);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         // 是否触发AOF重写操作</div><div class="line">         if (server.rdb_child_pid == -1 &amp;&amp;</div><div class="line">             server.aof_child_pid == -1 &amp;&amp;</div><div class="line">             server.aof_rewrite_perc &amp;&amp;</div><div class="line">             server.aof_current_size &gt; server.aof_rewrite_min_size)</div><div class="line">         &#123;</div><div class="line">            // 上一次重写后的大小</div><div class="line">            long long base = server.aof_rewrite_base_size ?</div><div class="line">                            server.aof_rewrite_base_size : 1;</div><div class="line">            // AOF文件增长的百分比</div><div class="line">            long long growth = (server.aof_current_size*100/base) - 100;</div><div class="line">            // 大于设置的百分比100则进行AOF后台重写</div><div class="line">            if (growth &gt;= server.aof_rewrite_perc) &#123;</div><div class="line">                serverLog(LL_NOTICE,&quot;Starting automatic rewriting of AOF on %lld%% growth&quot;,growth);</div><div class="line">                rewriteAppendOnlyFileBackground();</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将AOF缓存冲洗到磁盘中</div><div class="line">    if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);</div><div class="line"></div><div class="line">    // 当AOF重写操作，同样将重写缓冲区的数据刷新到AOF文件中</div><div class="line">    run_with_period(1000) &#123;</div><div class="line">        if (server.aof_last_write_status == C_ERR)</div><div class="line">            flushAppendOnlyFile(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 释放被设置为异步释放的client</div><div class="line">    freeClientsInAsyncFreeQueue();</div><div class="line"></div><div class="line">    // 解除client的暂停状态</div><div class="line">    clientsArePaused(); /* Don&apos;t check return value, just use the side effect. */</div><div class="line"></div><div class="line">    // 周期性执行复制的任务</div><div class="line">    run_with_period(1000) replicationCron();</div><div class="line"></div><div class="line">    /* Run the Redis Cluster cron. */</div><div class="line">    // 周期性执行集群任务</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        if (server.cluster_enabled) clusterCron();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //周期性执行哨兵任务</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        if (server.sentinel_mode) sentinelTimer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清理过期的被缓存的sockets连接</div><div class="line">    run_with_period(1000) &#123;</div><div class="line">        migrateCloseTimedoutSockets();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果 BGSAVE 被提上过日程，那么进行BGSAVE操作，因为AOF重写操作在更新</div><div class="line">    // 注意：此代码必须在上面的replicationCron()调用之后，确保在重构此文件以保持此顺序时。 这是有用的，因为我们希望优先考虑RDB节省的复制</div><div class="line">    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</div><div class="line">        server.rdb_bgsave_scheduled &amp;&amp;</div><div class="line">        (server.unixtime-server.lastbgsave_try &gt; CONFIG_BGSAVE_RETRY_DELAY ||</div><div class="line">         server.lastbgsave_status == C_OK))</div><div class="line">    &#123;</div><div class="line">        // 更新执行BGSAVE，成功则清除rdb_bgsave_scheduled标志</div><div class="line">        if (rdbSaveBackground(server.rdb_filename) == C_OK)</div><div class="line">            server.rdb_bgsave_scheduled = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 周期loop计数器加1</div><div class="line">    server.cronloops++;</div><div class="line">    // 返回周期，默认为100ms</div><div class="line">    return 1000/server.hz;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也是大致总结列出部分：</p>
<ul>
<li>主动删除过期的键（也可以在读数据库时被动删除）</li>
<li>喂看门狗 watchdog</li>
<li>更新一些统计值</li>
<li>渐进式rehash</li>
<li>触发 BGSAVE / AOF 的重写操作，并处理子进程的中断</li>
<li>不同状态的client的超时</li>
<li>复制重连<br>等……<br>我们重点看两个函数，一个是关于客户端资源管理的clientsCron()，一个是关于数据库资源管理的databasesCron()。</li>
</ul>
<h3 id="3-1客户端资源管理"><a href="#3-1客户端资源管理" class="headerlink" title="3.1客户端资源管理"></a>3.1客户端资源管理</h3><p>服务器要定时检查client是否与服务器有交互，如果超过了设置的限制时间，则要释放client所占用的资源。具体的函数是clientsCronHandleTimeout()，它被clientsCron()函数所调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 检查超时，如果client中断超时返回非零值，函数获取当前时间作为参数因为他被一个循环中调用多次。所以调用gettimeofday()为每一次迭代都是昂贵的，而没有任何实际的效益</div><div class="line">// client被关闭则返回1，没有关闭返回0</div><div class="line">int clientsCronHandleTimeout(client *c, mstime_t now_ms) &#123;</div><div class="line">    // 当前时间，单位秒</div><div class="line">    time_t now = now_ms/1000;</div><div class="line"></div><div class="line">    // 当前时间 - client上一次和服务器交互的时间 如果大于 服务器中设置client超过的最大时间</div><div class="line">    // 不检查这四类client的超时时间：slaves从节点服务器、masters主节点服务器、BLPOP被阻塞的client、订阅状态的client</div><div class="line">    if (server.maxidletime &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp;    /* no timeout for slaves */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;   /* no timeout for masters */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_BLOCKED) &amp;&amp;  /* no timeout for BLPOP */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_PUBSUB) &amp;&amp;   /* no timeout for Pub/Sub clients */</div><div class="line">        (now - c-&gt;lastinteraction &gt; server.maxidletime))</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_VERBOSE,&quot;Closing idle client&quot;);</div><div class="line">        freeClient(c);</div><div class="line">        return 1;</div><div class="line">    // 如果client处于BLPOP被阻塞</div><div class="line">    &#125; else if (c-&gt;flags &amp; CLIENT_BLOCKED) &#123;</div><div class="line">        // 如果阻塞的client的超时时间已经到达</div><div class="line">        if (c-&gt;bpop.timeout != 0 &amp;&amp; c-&gt;bpop.timeout &lt; now_ms) &#123;</div><div class="line">            // 回复client一个空回复</div><div class="line">            replyToBlockedClientTimedOut(c);</div><div class="line">            // 接触client的阻塞状态</div><div class="line">            unblockClient(c);</div><div class="line">        // 如果服务器处于集群模式</div><div class="line">        &#125; else if (server.cluster_enabled) &#123;</div><div class="line">            // 重定向client的阻塞到其他的服务器</div><div class="line">            if (clusterRedirectBlockedClientIfNeeded(c))</div><div class="line">                // 解除阻塞</div><div class="line">                unblockClient(c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-数据库资源管理"><a href="#3-2-数据库资源管理" class="headerlink" title="3.2 数据库资源管理"></a>3.2 数据库资源管理</h3><p>服务器要定时检查数据库的输入缓冲区是否可以resize，以节省内存资源。而resize输入缓冲区的两个条件：</p>
<ul>
<li>输入缓冲区的大小大于32K以及超过缓冲区的峰值的2倍。</li>
<li>client超过时间大于2秒，且输入缓冲区的大小超过1k<br>实现的函数是clientsCronResizeQueryBuffer()，被databasesCron()函数所调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// resize客户端的输入缓冲区</div><div class="line">int clientsCronResizeQueryBuffer(client *c) &#123;</div><div class="line">    // 获取输入缓冲区的大小</div><div class="line">    size_t querybuf_size = sdsAllocSize(c-&gt;querybuf);</div><div class="line">    // 计算服务器对于client的空转时间，也就是client的超时时间</div><div class="line">    time_t idletime = server.unixtime - c-&gt;lastinteraction;</div><div class="line"></div><div class="line">    // resize输入缓冲区的两个条件：</div><div class="line">    //      1. 输入缓冲区的大小大于32K以及超过缓冲区的峰值的2倍</div><div class="line">    //      2. client超过时间大于2秒，且输入缓冲区的大小超过1k</div><div class="line">    if (((querybuf_size &gt; PROTO_MBULK_BIG_ARG) &amp;&amp;</div><div class="line">         (querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2) ||</div><div class="line">         (querybuf_size &gt; 1024 &amp;&amp; idletime &gt; 2))</div><div class="line">    &#123;</div><div class="line">        // 只有输入缓冲区的未使用大小超过1k，则会释放未使用的空间</div><div class="line">        if (sdsavail(c-&gt;querybuf) &gt; 1024) &#123;</div><div class="line">            c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 清空输入缓冲区的峰值</div><div class="line">    c-&gt;querybuf_peak = 0;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-maxmemory的策略"><a href="#4-maxmemory的策略" class="headerlink" title="4. maxmemory的策略"></a>4. maxmemory的策略</h2><p>Redis 服务器对内存使用会有一个server.maxmemory的限制，如果超过这个限制，就要通过删除一些键空间来释放一些内存，具体函数对应freeMemoryIfNeeded()。</p>
<p>释放内存时，可以指定不同的策略。策略保存在maxmemory_policy中，他可以指定以下的几个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define MAXMEMORY_VOLATILE_LRU 0</div><div class="line">#define MAXMEMORY_VOLATILE_TTL 1</div><div class="line">#define MAXMEMORY_VOLATILE_RANDOM 2</div><div class="line">#define MAXMEMORY_ALLKEYS_LRU 3</div><div class="line">#define MAXMEMORY_ALLKEYS_RANDOM 4</div><div class="line">#define MAXMEMORY_NO_EVICTION 5</div></pre></td></tr></table></figure></p>
<p>可以看出主要分为三种，</p>
<ul>
<li>LRU：优先删除最近最少使用的键。</li>
<li>TTL：优先删除生存时间最短的键。</li>
<li>RANDOM：随机删除。<br>而ALLKEYS和VOLATILE的不同之处就是要确定是从数据库的键值对字典还是过期键字典中删除。</li>
</ul>
<p>了解了以上这些，我们贴出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line">// 按需释放内存空间</div><div class="line">int freeMemoryIfNeeded(void) &#123;</div><div class="line">    size_t mem_used, mem_tofree, mem_freed;</div><div class="line">    int slaves = listLength(server.slaves);</div><div class="line">    mstime_t latency, eviction_latency;</div><div class="line"></div><div class="line">    // 计算出服务器总的内存使用量，但是有两部分要减去</div><div class="line">    /*</div><div class="line">        1、从节点的输出缓冲区</div><div class="line">        2、AOF缓冲区</div><div class="line">    */</div><div class="line">    mem_used = zmalloc_used_memory();</div><div class="line">    // 存在从节点</div><div class="line">    if (slaves) &#123;</div><div class="line">        listIter li;</div><div class="line">        listNode *ln;</div><div class="line"></div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = listNodeValue(ln);</div><div class="line">            // 获取当前从节点的输出缓冲区的大小，不包含静态的固定回复缓冲区，因为他总被分配</div><div class="line">            unsigned long obuf_bytes = getClientOutputBufferMemoryUsage(slave);</div><div class="line">            // 减去当前从节点的输出缓冲区的大小</div><div class="line">            if (obuf_bytes &gt; mem_used)</div><div class="line">                mem_used = 0;</div><div class="line">            else</div><div class="line">                mem_used -= obuf_bytes;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 如果开启了AOF操作</div><div class="line">    if (server.aof_state != AOF_OFF) &#123;</div><div class="line">        // 减去AOF缓冲区的大小</div><div class="line">        mem_used -= sdslen(server.aof_buf);</div><div class="line">        // 减去AOF重写缓冲区的大小</div><div class="line">        mem_used -= aofRewriteBufferSize();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有超过服务器设置的最大内存限制，则返回C_OK</div><div class="line">    if (mem_used &lt;= server.maxmemory) return C_OK;</div><div class="line">    // 如果内存回收策略为不回收，则返回C_ERR</div><div class="line">    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</div><div class="line">        return C_ERR; /* We need to free memory, but policy forbids. */</div><div class="line"></div><div class="line">    // 计算需要回收的大小</div><div class="line">    mem_tofree = mem_used - server.maxmemory;</div><div class="line">    // 已回收的大小</div><div class="line">    mem_freed = 0;</div><div class="line">    // 设置回收延迟检测开始的时间</div><div class="line">    latencyStartMonitor(latency);</div><div class="line">    // 循环回收，直到到达需要回收大小</div><div class="line">    while (mem_freed &lt; mem_tofree) &#123;</div><div class="line">        int j, k, keys_freed = 0;</div><div class="line"></div><div class="line">        // 遍历所有的数据库</div><div class="line">        for (j = 0; j &lt; server.dbnum; j++) &#123;</div><div class="line">            long bestval = 0; /* just to prevent warning */</div><div class="line">            sds bestkey = NULL;</div><div class="line">            dictEntry *de;</div><div class="line">            redisDb *db = server.db+j;</div><div class="line">            dict *dict;</div><div class="line">            // 如果回收策略有ALLKEYS_LRU或RANDOM，从键值对字典中选择回收</div><div class="line">            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM)</div><div class="line">            &#123;</div><div class="line">                // 则从键值对字典中选择回收的键。选择样品字典</div><div class="line">                dict = server.db[j].dict;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则从过期键字典中选择回收的键。选择样品字典</div><div class="line">                dict = server.db[j].expires;</div><div class="line">            &#125;</div><div class="line">            if (dictSize(dict) == 0) continue;  //跳过空字典</div><div class="line"></div><div class="line">            /* volatile-random and allkeys-random policy */</div><div class="line">            // 如果回收策略有 ALLKEYS_RANDOM 或 VOLATILE_RANDOM，则是随机挑选</div><div class="line">            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</div><div class="line">            &#123;</div><div class="line">                // 随机返回一个key</div><div class="line">                de = dictGetRandomKey(dict);</div><div class="line">                bestkey = dictGetKey(de);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* volatile-lru and allkeys-lru policy */</div><div class="line">            // 如果回收策略有 ALLKEYS_LRU 或 VOLATILE_LRU，则使用LRU策略</div><div class="line">            else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_LRU)</div><div class="line">            &#123;</div><div class="line">                // 回收池</div><div class="line">                struct evictionPoolEntry *pool = db-&gt;eviction_pool;</div><div class="line"></div><div class="line">                while(bestkey == NULL) &#123;</div><div class="line">                    // evictionPoolPopulate()用于在每次我们想要过期一个键的时候，用几个节点填充evictionPool。 空闲时间小于当前key的之一的key被添加。 如果有free的节点，则始终添加key。 我们按升序插入key，所以空闲时间越短的键在左边，右边的空闲时间越长。</div><div class="line">                    // 从样品字典dict中随机选择样品</div><div class="line">                    evictionPoolPopulate(dict, db-&gt;dict, db-&gt;eviction_pool);</div><div class="line">                    // 从空转时间最长的开始遍历</div><div class="line">                    for (k = MAXMEMORY_EVICTION_POOL_SIZE-1; k &gt;= 0; k--) &#123;</div><div class="line">                        // 跳过空位置</div><div class="line">                        if (pool[k].key == NULL) continue;</div><div class="line">                        // 从样品字典dict中查找当前key</div><div class="line">                        de = dictFind(dict,pool[k].key);</div><div class="line"></div><div class="line">                        // 从收回池中删除</div><div class="line">                        sdsfree(pool[k].key);</div><div class="line">                        // 释放位置</div><div class="line">                        memmove(pool+k,pool+k+1,</div><div class="line">                            sizeof(pool[0])*(MAXMEMORY_EVICTION_POOL_SIZE-k-1));</div><div class="line">                        // 重置key和空转时间</div><div class="line">                        pool[MAXMEMORY_EVICTION_POOL_SIZE-1].key = NULL;</div><div class="line">                        pool[MAXMEMORY_EVICTION_POOL_SIZE-1].idle = 0;</div><div class="line"></div><div class="line">                        // 如果从样品字典中可以找到，则保存键</div><div class="line">                        if (de) &#123;</div><div class="line">                            bestkey = dictGetKey(de);</div><div class="line">                            break;</div><div class="line">                        // 没找到，则继续找下一个样品空间所保存的键</div><div class="line">                        &#125; else &#123;</div><div class="line">                            /* Ghost... */</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // 如果当前选出的所有的样品都没找到，则重新选择一批样品，知道找到一个可以释放的键</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* volatile-ttl */</div><div class="line">            // 如果回收策略有 VOLATILE_TTL，则选择生存时间最短的键</div><div class="line">            else if (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</div><div class="line">                // 抽样个数为maxmemory_samples个</div><div class="line">                for (k = 0; k &lt; server.maxmemory_samples; k++) &#123;</div><div class="line">                    sds thiskey;</div><div class="line">                    long thisval;</div><div class="line"></div><div class="line">                    // 返回一个键，获取他的生存时间</div><div class="line">                    de = dictGetRandomKey(dict);</div><div class="line">                    thiskey = dictGetKey(de);</div><div class="line">                    thisval = (long) dictGetVal(de);</div><div class="line"></div><div class="line">                    // 如果当前键的生存时间更短，则保存</div><div class="line">                    if (bestkey == NULL || thisval &lt; bestval) &#123;</div><div class="line">                        bestkey = thiskey;</div><div class="line">                        bestval = thisval;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Finally remove the selected key. */</div><div class="line">            // 删除所有被选择的键</div><div class="line">            if (bestkey) &#123;</div><div class="line">                long long delta;</div><div class="line"></div><div class="line">                robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</div><div class="line">                // 当一个键在主节点中过期时，主节点会发送del命令给从节点和AOF文件</div><div class="line">                propagateExpire(db,keyobj);</div><div class="line">                // 单独计算dbDelete()所释放的空间大小， 在AOF和复制链接中传播DEL的内存实际上大于我们释放的key的内存</div><div class="line">                // 但是无法解释，窦泽不会退出循环</div><div class="line">                // AOF和输出缓冲区的内存最终被释放，所以我们只关心键空间使用的内存</div><div class="line">                delta = (long long) zmalloc_used_memory();</div><div class="line">                // 设置删除key对象的开始时间</div><div class="line">                latencyStartMonitor(eviction_latency);</div><div class="line">                dbDelete(db,keyobj);</div><div class="line">                // 保存删除key对象时间</div><div class="line">                latencyEndMonitor(eviction_latency);</div><div class="line">                // 添加到延迟诊断字典中</div><div class="line">                latencyAddSampleIfNeeded(&quot;eviction-del&quot;,eviction_latency);</div><div class="line">                // 删除嵌套的延迟事件</div><div class="line">                latencyRemoveNestedEvent(latency,eviction_latency);</div><div class="line">                // 计算删除这个键的大小</div><div class="line">                delta -= (long long) zmalloc_used_memory();</div><div class="line">                // 更新内存释放量</div><div class="line">                mem_freed += delta;</div><div class="line">                // 服务器总的回收键的个数计数器加1</div><div class="line">                server.stat_evictedkeys++;</div><div class="line">                // 事件通知</div><div class="line">                notifyKeyspaceEvent(NOTIFY_EVICTED, &quot;evicted&quot;,</div><div class="line">                    keyobj, db-&gt;id);</div><div class="line">                // 释放键对象</div><div class="line">                decrRefCount(keyobj);</div><div class="line">                // 释放键的个数加1</div><div class="line">                keys_freed++;</div><div class="line"></div><div class="line">                // 如果有从节点，则刷新所有的输出缓冲区数据</div><div class="line">                if (slaves) flushSlavesOutputBuffers();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 如果所有数据库都没有释放键，返回C_ERR</div><div class="line">        if (!keys_freed) &#123;</div><div class="line">            latencyEndMonitor(latency);</div><div class="line">            latencyAddSampleIfNeeded(&quot;eviction-cycle&quot;,latency);</div><div class="line">            return C_ERR; /* nothing to free... */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 计算回收延迟的时间</div><div class="line">    latencyEndMonitor(latency);</div><div class="line">    latencyAddSampleIfNeeded(&quot;eviction-cycle&quot;,latency);</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-Redis服务器的main函数"><a href="#5-Redis服务器的main函数" class="headerlink" title="5. Redis服务器的main函数"></a>5. Redis服务器的main函数</h2><p>Redis 服务器的main()主要执行了一下操作：</p>
<ul>
<li>初始化服务器状态</li>
<li>载入服务器的配置</li>
<li>初始化服务器数据结构</li>
<li>载入持久化文件还原数据库状态</li>
<li>执行事件循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char **argv) &#123;</div><div class="line">    struct timeval tv;</div><div class="line">    int j;</div><div class="line"></div><div class="line">#ifdef INIT_SETPROCTITLE_REPLACEMENT</div><div class="line">    spt_init(argc, argv);</div><div class="line">#endif</div><div class="line">    // 本函数用来配置地域的信息，设置当前程序使用的本地化信息，LC_COLLATE 配置字符串比较</div><div class="line">    setlocale(LC_COLLATE,&quot;&quot;);</div><div class="line">    // 设置线程安全</div><div class="line">    zmalloc_enable_thread_safeness();</div><div class="line">    // 设置内存溢出的处理函数</div><div class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</div><div class="line">    // 初始化随机数发生器</div><div class="line">    srand(time(NULL)^getpid());</div><div class="line">    // 保存当前信息</div><div class="line">    gettimeofday(&amp;tv,NULL);</div><div class="line">    // 设置哈希函数的种子</div><div class="line">    dictSetHashFunctionSeed(tv.tv_sec^tv.tv_usec^getpid());</div><div class="line">    // 检查开启哨兵模式的两种方式</div><div class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</div><div class="line">    // 初始化服务器配置</div><div class="line">    initServerConfig();</div><div class="line"></div><div class="line">    // 设置可执行文件的绝对路径</div><div class="line">    server.executable = getAbsolutePath(argv[0]);</div><div class="line">    // 分配执行executable文件的参数列表的空间</div><div class="line">    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</div><div class="line">    server.exec_argv[argc] = NULL;</div><div class="line">    // 保存当前参数</div><div class="line">    for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</div><div class="line"></div><div class="line">    // 如果已开启哨兵模式</div><div class="line">    if (server.sentinel_mode) &#123;</div><div class="line">        // 初始化哨兵的配置</div><div class="line">        initSentinelConfig();</div><div class="line">        initSentinel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 检查是否执行&quot;redis-check-rdb&quot;检查程序</div><div class="line">    if (strstr(argv[0],&quot;redis-check-rdb&quot;) != NULL)</div><div class="line">        redis_check_rdb_main(argc,argv);    //该函数不会返回</div><div class="line"></div><div class="line">    // 解析参数</div><div class="line">    if (argc &gt;= 2) &#123;</div><div class="line">        j = 1; /* First option to parse in argv[] */</div><div class="line">        sds options = sdsempty();</div><div class="line">        char *configfile = NULL;</div><div class="line"></div><div class="line">        /* Handle special options --help and --version */</div><div class="line">        // 指定了打印版本信息，然后退出</div><div class="line">        if (strcmp(argv[1], &quot;-v&quot;) == 0 ||</div><div class="line">            strcmp(argv[1], &quot;--version&quot;) == 0) version();</div><div class="line">        // 执行帮助信息，然后退出</div><div class="line">        if (strcmp(argv[1], &quot;--help&quot;) == 0 ||</div><div class="line">            strcmp(argv[1], &quot;-h&quot;) == 0) usage();</div><div class="line">        // 执行内存测试程序</div><div class="line">        if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) &#123;</div><div class="line">            if (argc == 3) &#123;</div><div class="line">                memtest(atoi(argv[2]),50);</div><div class="line">                exit(0);</div><div class="line">            &#125; else &#123;</div><div class="line">                fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);</div><div class="line">                fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);</div><div class="line">                exit(1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* First argument is the config file name? */</div><div class="line">        // 如果第1个参数不是&apos;-&apos;，那么是配置文件</div><div class="line">        if (argv[j][0] != &apos;-&apos; || argv[j][1] != &apos;-&apos;) &#123;</div><div class="line">            configfile = argv[j];</div><div class="line">            // 设置配置文件的绝对路径</div><div class="line">            server.configfile = getAbsolutePath(configfile);</div><div class="line">            /* Replace the config file in server.exec_argv with</div><div class="line">             * its absoulte path. */</div><div class="line">            zfree(server.exec_argv[j]);</div><div class="line">            // 设置可执行的参数列表</div><div class="line">            server.exec_argv[j] = zstrdup(server.configfile);</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 解析指定的对象</div><div class="line">        while(j != argc) &#123;</div><div class="line">            // 如果是以&apos;-&apos;开头</div><div class="line">            if (argv[j][0] == &apos;-&apos; &amp;&amp; argv[j][1] == &apos;-&apos;) &#123;</div><div class="line">                /* Option name */</div><div class="line">                // 跳过&quot;--check-rdb&quot;</div><div class="line">                if (!strcmp(argv[j], &quot;--check-rdb&quot;)) &#123;</div><div class="line">                    /* Argument has no options, need to skip for parsing. */</div><div class="line">                    j++;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                // 每个选项之间用&apos;\n&apos;隔开</div><div class="line">                if (sdslen(options)) options = sdscat(options,&quot;\n&quot;);</div><div class="line">                // 将选项追加在sds中</div><div class="line">                options = sdscat(options,argv[j]+2);</div><div class="line">                // 选项和参数用 &quot; &quot;隔开</div><div class="line">                options = sdscat(options,&quot; &quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                /* Option argument */</div><div class="line">                // 追加选项参数</div><div class="line">                options = sdscatrepr(options,argv[j],strlen(argv[j]));</div><div class="line">                options = sdscat(options,&quot; &quot;);</div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        // 如果开启哨兵模式，哨兵模式配置文件不正确</div><div class="line">        if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == &apos;-&apos;) &#123;</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Sentinel config from STDIN not allowed.&quot;);</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Sentinel needs config file on disk to save state.  Exiting...&quot;);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        // 重置save命令的参数</div><div class="line">        resetServerSaveParams();</div><div class="line">        // 载入配置文件</div><div class="line">        loadServerConfig(configfile,options);</div><div class="line">        sdsfree(options);</div><div class="line">    &#125; else &#123;</div><div class="line">        serverLog(LL_WARNING, &quot;Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf&quot;, argv[0], server.sentinel_mode ? &quot;sentinel&quot; : &quot;redis&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 是否被监视</div><div class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</div><div class="line">    // 是否以守护进程的方式运行</div><div class="line">    int background = server.daemonize &amp;&amp; !server.supervised;</div><div class="line">    if (background) daemonize();</div><div class="line"></div><div class="line">    // 初始化服务器</div><div class="line">    initServer();</div><div class="line">    // 创建保存pid的文件</div><div class="line">    if (background || server.pidfile) createPidFile();</div><div class="line">    // 为服务器进程设置标题</div><div class="line">    redisSetProcTitle(argv[0]);</div><div class="line">    // 打印Redis的logo</div><div class="line">    redisAsciiArt();</div><div class="line">    // 检查backlog队列</div><div class="line">    checkTcpBacklogSettings();</div><div class="line"></div><div class="line">    // 如果不是哨兵模式</div><div class="line">    if (!server.sentinel_mode) &#123;</div><div class="line">        /* Things not needed when running in Sentinel mode. */</div><div class="line">        serverLog(LL_WARNING,&quot;Server started, Redis version &quot; REDIS_VERSION);</div><div class="line">    #ifdef __linux__</div><div class="line">        // 打印内存警告</div><div class="line">        linuxMemoryWarnings();</div><div class="line">    #endif</div><div class="line">        // 从AOF文件或RDB文件载入数据</div><div class="line">        loadDataFromDisk();</div><div class="line">        // 如果开启了集群模式</div><div class="line">        if (server.cluster_enabled) &#123;</div><div class="line">            // 集群模式下验证载入的数据</div><div class="line">            if (verifyClusterConfigWithData() == C_ERR) &#123;</div><div class="line">                serverLog(LL_WARNING,</div><div class="line">                    &quot;You can&apos;t have keys in a DB different than DB 0 when in &quot;</div><div class="line">                    &quot;Cluster mode. Exiting.&quot;);</div><div class="line">                exit(1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 打印端口号</div><div class="line">        if (server.ipfd_count &gt; 0)</div><div class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections on port %d&quot;, server.port);</div><div class="line">        // 打印本地套接字fd</div><div class="line">        if (server.sofd &gt; 0)</div><div class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections at %s&quot;, server.unixsocket);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 开启哨兵模式，哨兵模式和集群模式只能开启一种</div><div class="line">        sentinelIsRunning();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Warning the user about suspicious maxmemory setting. */</div><div class="line">    // 最大内存限制是否配置正确</div><div class="line">    if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&quot;, server.maxmemory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 进入事件循环之前执行beforeSleep()函数</div><div class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</div><div class="line">    // 运行事件循环，一直到服务器关闭</div><div class="line">    aeMain(server.el);</div><div class="line">    // 服务器关闭，删除事件循环</div><div class="line">    aeDeleteEventLoop(server.el);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/10/redis-analysis-eventhanding/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/10/redis-analysis-eventhanding/" itemprop="url">
                  Redis源码剖析和注释（十九）--- Redis 事件处理实现
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T18:39:02+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Redis事件介绍"><a href="#1-Redis事件介绍" class="headerlink" title="1. Redis事件介绍"></a>1. Redis事件介绍</h2><p>Redis服务器是一个事件驱动程序。下面先来简单介绍什么是事件驱动。</p>
<p>所谓事件驱动，就是当你输入一条命令并且按下回车，然后消息被组装成Redis协议的格式发送给Redis服务器，这就会产生一个事件，Redis服务器会接收该命令，处理该命令和发送回复，而当你没有与服务器进行交互时，那么服务器就会处于阻塞等待状态，会让出CPU从而进入睡眠状态，当事件触发时，就会被操作系统唤醒。事件驱动使CPU更高效的利用。</p>
<p>事件驱动是一种概括和抽象，也可以称为I/O多路复用（I/O multiplexing），它的实现方式各个系统都不同，一会会说到Redis的方式。</p>
<p>在redis服务器中，处理了两类事件：</p>
<ul>
<li>文件事件（file event）：Redis服务器通过套接字于客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。</li>
<li>时间事件（time event）：Redis服务器的一些操作需要在给定的事件点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h2 id="2-事件的抽象"><a href="#2-事件的抽象" class="headerlink" title="2. 事件的抽象"></a>2. 事件的抽象</h2><p>Redis将这两个事件分别抽象成一个数据结构来管理。</p>
<h3 id="2-1-文件事件结构"><a href="#2-1-文件事件结构" class="headerlink" title="2.1 文件事件结构"></a>2.1 文件事件结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* File event structure */</div><div class="line">typedef struct aeFileEvent &#123;</div><div class="line">    // 文件时间类型：AE_NONE，AE_READABLE，AE_WRITABLE</div><div class="line">    int mask; /* one of AE_(READABLE|WRITABLE) */</div><div class="line">    // 可读处理函数</div><div class="line">    aeFileProc *rfileProc;</div><div class="line">    // 可写处理函数</div><div class="line">    aeFileProc *wfileProc;</div><div class="line">    // 客户端传入的数据</div><div class="line">    void *clientData;</div><div class="line">&#125; aeFileEvent;  //文件事件</div></pre></td></tr></table></figure>
<p>其中rfileProc和wfileProc成员分别为两个函数指针，他们的原型为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask)</div></pre></td></tr></table></figure></p>
<p>这个函数是回调函数，如果当前文件事件所指定的事件类型发生时，则会调用对应的回调函数处理该事件。函数指针与回调函数详解</p>
<p>当事件就绪时，我们需要知道文件事件的文件描述符还有事件类型才能锁定该事件，因此定义了aeFiredEvent结构统一管理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* A fired event */</div><div class="line">typedef struct aeFiredEvent &#123;</div><div class="line">    // 就绪事件的文件描述符</div><div class="line">    int fd;</div><div class="line">    // 就绪事件类型：AE_NONE，AE_READABLE，AE_WRITABLE</div><div class="line">    int mask;</div><div class="line">&#125; aeFiredEvent; //就绪事件</div></pre></td></tr></table></figure></p>
<h3 id="2-2-时间事件结构"><a href="#2-2-时间事件结构" class="headerlink" title="2.2 时间事件结构"></a>2.2 时间事件结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* Time event structure */</div><div class="line">typedef struct aeTimeEvent &#123;</div><div class="line">    // 时间事件的id</div><div class="line">    long long id; /* time event identifier. */</div><div class="line">    // 时间事件到达的时间的秒数</div><div class="line">    long when_sec; /* seconds */</div><div class="line">    // 时间事件到达的时间的毫秒数</div><div class="line">    long when_ms; /* milliseconds */</div><div class="line">    // 时间事件处理函数</div><div class="line">    aeTimeProc *timeProc;</div><div class="line">    // 时间事件终结函数</div><div class="line">    aeEventFinalizerProc *finalizerProc;</div><div class="line">    // 客户端传入的数据</div><div class="line">    void *clientData;</div><div class="line">    // 指向下一个时间事件</div><div class="line">    struct aeTimeEvent *next;</div><div class="line">&#125; aeTimeEvent;  //时间事件</div></pre></td></tr></table></figure>
<p>从这个结构中可以看出，时间事件表是一个链表，因为它有一个next指针域，指向下一个时间事件。</p>
<p>和文件事件一样，当时间事件所指定的事件发生时，也会调用对应的回调函数，结构成员timeProc和finalizerProc都是回调函数，函数原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);</div><div class="line">typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);</div></pre></td></tr></table></figure></p>
<p>虽然对文件事件和时间事件都做了抽象，Redis仍然需要对事件做整体抽象，于是定义了aeEventLoop结构。</p>
<h3 id="2-3-事件状态结构"><a href="#2-3-事件状态结构" class="headerlink" title="2.3 事件状态结构"></a>2.3 事件状态结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* State of an event based program */</div><div class="line">typedef struct aeEventLoop &#123;</div><div class="line">    // 当前已注册的最大的文件描述符</div><div class="line">    int maxfd;   /* highest file descriptor currently registered */</div><div class="line">    // 文件描述符监听集合的大小</div><div class="line">    int setsize; /* max number of file descriptors tracked */</div><div class="line">    // 下一个时间事件的ID</div><div class="line">    long long timeEventNextId;</div><div class="line">    // 最后一次执行事件的时间</div><div class="line">    time_t lastTime;     /* Used to detect system clock skew */</div><div class="line">    // 注册的文件事件表</div><div class="line">    aeFileEvent *events; /* Registered events */</div><div class="line">    // 已就绪的文件事件表</div><div class="line">    aeFiredEvent *fired; /* Fired events */</div><div class="line">    // 时间事件的头节点指针</div><div class="line">    aeTimeEvent *timeEventHead;</div><div class="line">    // 事件处理开关</div><div class="line">    int stop;</div><div class="line">    // 多路复用库的事件状态数据</div><div class="line">    void *apidata; /* This is used for polling API specific data */</div><div class="line">    // 执行处理事件之前的函数</div><div class="line">    aeBeforeSleepProc *beforesleep;</div><div class="line">&#125; aeEventLoop;  //事件轮询的状态结构</div></pre></td></tr></table></figure>
<p>aeEventLoop结构保存了一个void *类型的万能指针apidata，是用来保存轮询事件的状态的，也就是保存底层调用的多路复用库的事件状态，关于Redis的多路复用库的选择，Redis包装了常见的select epoll evport kqueue，他们在编译阶段，根据不同的系统选择性能最高的一个多路复用库作为Redis的多路复用程序的实现，而且所有库实现的接口名称都是相同的，因此Redis多路复用程序底层实现是可以互换的。具体选择库的源码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// IO复用的选择，性能依次下降，Linux支持 &quot;ae_epoll.c&quot; 和 &quot;ae_select.c&quot;</div><div class="line">#ifdef HAVE_EVPORT</div><div class="line">#include &quot;ae_evport.c&quot;</div><div class="line">#else</div><div class="line">    #ifdef HAVE_EPOLL</div><div class="line">    #include &quot;ae_epoll.c&quot;</div><div class="line">    #else</div><div class="line">        #ifdef HAVE_KQUEUE</div><div class="line">        #include &quot;ae_kqueue.c&quot;</div><div class="line">        #else</div><div class="line">        #include &quot;ae_select.c&quot;</div><div class="line">        #endif</div><div class="line">    #endif</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>也可以通过Redis客户端的命令来查看当前选择的多路复用库，INFO server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; INFO server</div><div class="line"># Server</div><div class="line">……</div><div class="line">multiplexing_api:epoll</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>那么，既然知道了多路复用库的选择，那么我们来查看一下apidata保存的epoll模型的事件状态结构：ae_epoll.c文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct aeApiState &#123;</div><div class="line">    // epoll事件的文件描述符</div><div class="line">    int epfd;</div><div class="line">    // 事件表</div><div class="line">    struct epoll_event *events;</div><div class="line">&#125; aeApiState;   //事件的状态</div></pre></td></tr></table></figure></p>
<p>epoll模型的struct epoll_event的结构中定义这自己的事件类型，例如EPOLLIN POLLOUT等等，但是Redis的文件事件结构aeFileEvent中也在mask中定义了自己的事件类型，例如：AE_READABLE AE_WRITABLE等，于是，就需要实现一个中间层将两者的事件类型相联系起来，这也就是之前提到的ae_epoll.c文件中实现的相同的API，我们列出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 创建一个epoll实例，保存到eventLoop中</div><div class="line">static int aeApiCreate(aeEventLoop *eventLoop)</div><div class="line">// 调整事件表的大小</div><div class="line">static int aeApiResize(aeEventLoop *eventLoop, int setsize)  </div><div class="line">// 释放epoll实例和事件表空间</div><div class="line">static void aeApiFree(aeEventLoop *eventLoop)</div><div class="line">// 在epfd标识的事件表上注册fd的事件</div><div class="line">static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask)</div><div class="line">// 在epfd标识的事件表上注删除fd的事件</div><div class="line">static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask)</div><div class="line">// 等待所监听文件描述符上有事件发生</div><div class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp)</div><div class="line">// 返回正在使用的IO多路复用库的名字</div><div class="line">static char *aeApiName(void)</div></pre></td></tr></table></figure></p>
<p>这些API都是调用相应的底层多路复用库来将Redis事件状态结构aeEventLoop所关联，就是将epoll的底层函数封装起来，Redis实现事件时，只需调用这些接口即可。我们查看两个重要的函数的源码，看看是如何实现的</p>
<ul>
<li><p>向Redis事件状态结构aeEventLoop的事件表event注册一个事件，对应的是epoll_ctl函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 在epfd标识的事件表上注册fd的事件</div><div class="line">static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) &#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    struct epoll_event ee = &#123;0&#125;; /* avoid valgrind warning */</div><div class="line">    /* If the fd was already monitored for some event, we need a MOD</div><div class="line">     * operation. Otherwise we need an ADD operation. */</div><div class="line">    // EPOLL_CTL_ADD，向epfd注册fd的上的event</div><div class="line">    // EPOLL_CTL_MOD，修改fd已注册的event</div><div class="line">    // #define AE_NONE 0           //未设置</div><div class="line">    // #define AE_READABLE 1       //事件可读</div><div class="line">    // #define AE_WRITABLE 2       //事件可写</div><div class="line">    // 判断fd事件的操作，如果没有设置事件，则进行关联mask类型事件，否则进行修改</div><div class="line">    int op = eventLoop-&gt;events[fd].mask == AE_NONE ?</div><div class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</div><div class="line"></div><div class="line">    // struct epoll_event &#123;</div><div class="line">    //      uint32_t     events;      /* Epoll events */</div><div class="line">    //      epoll_data_t data;        /* User data variable */</div><div class="line">    // &#125;;</div><div class="line">    ee.events = 0;</div><div class="line">    // 如果是修改事件，合并之前的事件类型</div><div class="line">    mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */</div><div class="line">    // 根据mask映射epoll的事件类型</div><div class="line">    if (mask &amp; AE_READABLE) ee.events |= EPOLLIN;   //读事件</div><div class="line">    if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;  //写事件</div><div class="line">    ee.data.fd = fd;    //设置事件所从属的目标文件描述符</div><div class="line">    // 将ee事件注册到epoll中</div><div class="line">    if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>等待所监听文件描述符上有事件发生，对应着底层epoll_wait函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 等待所监听文件描述符上有事件发生</div><div class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    int retval, numevents = 0;</div><div class="line"></div><div class="line">    // 监听事件表上是否有事件发生</div><div class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</div><div class="line">            tvp ? (tvp-&gt;tv_sec*1000 + tvp-&gt;tv_usec/1000) : -1);</div><div class="line">    // 至少有一个就绪的事件</div><div class="line">    if (retval &gt; 0) &#123;</div><div class="line">        int j;</div><div class="line"></div><div class="line">        numevents = retval;</div><div class="line">        // 遍历就绪的事件表，将其加入到eventLoop的就绪事件表中</div><div class="line">        for (j = 0; j &lt; numevents; j++) &#123;</div><div class="line">            int mask = 0;</div><div class="line">            struct epoll_event *e = state-&gt;events+j;</div><div class="line"></div><div class="line">            // 根据就绪的事件类型，设置mask</div><div class="line">            if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</div><div class="line">            // 添加到就绪事件表中</div><div class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</div><div class="line">            eventLoop-&gt;fired[j].mask = mask;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 返回就绪的事件个数</div><div class="line">    return numevents;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-事件的源码实现"><a href="#3-事件的源码实现" class="headerlink" title="3. 事件的源码实现"></a>3. 事件的源码实现</h2><p>Redis事件的源码全部定义在ae.c文件中，我们从事件的主函数aeMain说起，一步一步深入剖析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 事件轮询的主函数</div><div class="line">void aeMain(aeEventLoop *eventLoop) &#123;</div><div class="line">    eventLoop-&gt;stop = 0;</div><div class="line">    // 一直处理事件</div><div class="line">    while (!eventLoop-&gt;stop) &#123;</div><div class="line">        // 执行处理事件之前的函数</div><div class="line">        if (eventLoop-&gt;beforesleep != NULL)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line">        //处理到时的时间事件和就绪的文件事件</div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个事件的主函数aeMain很清楚的可以看到，如果服务器一直处理事件，那么就是一个死循环，而一个最典型的事件驱动，就是一个死循环。调用处理事件的函数aeProcessEvents，他们参数是一个事件状态结构aeEventLoop和AE_ALL_EVENTS，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">// 处理到时的时间事件和就绪的文件事件</div><div class="line">// 函数返回执行的事件个数</div><div class="line">int aeProcessEvents(aeEventLoop *eventLoop, int flags)</div><div class="line">&#123;</div><div class="line">    int processed = 0, numevents;</div><div class="line"></div><div class="line">    /* Nothing to do? return ASAP */</div><div class="line">    // 如果什么事件都没有设置则直接返回</div><div class="line">    if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0;</div><div class="line"></div><div class="line">    /* Note that we want call select() even if there are no</div><div class="line">     * file events to process as long as we want to process time</div><div class="line">     * events, in order to sleep until the next time event is ready</div><div class="line">     * to fire. */</div><div class="line">    // 请注意，既然我们要处理时间事件，即使没有要处理的文件事件，我们仍要调用select（），以便在下一次事件准备启动之前进行休眠</div><div class="line"></div><div class="line">    // 当前还没有要处理的文件事件，或者设置了时间时间但是没有设置不阻塞标识</div><div class="line">    if (eventLoop-&gt;maxfd != -1 ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        int j;</div><div class="line">        aeTimeEvent *shortest = NULL;</div><div class="line">        struct timeval tv, *tvp;</div><div class="line"></div><div class="line">        // 如果设置了时间事件而没有设置不阻塞标识</div><div class="line">        if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            // 获取最近到时的时间事件</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        // 获取到了最早到时的时间事件</div><div class="line">        if (shortest) &#123;</div><div class="line">            long now_sec, now_ms;</div><div class="line">            // 获取当前时间</div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line"></div><div class="line">            /* How many milliseconds we need to wait for the next</div><div class="line">             * time event to fire? */</div><div class="line">            // 等待该时间事件到时所需要的时长</div><div class="line">            long long ms =</div><div class="line">                (shortest-&gt;when_sec - now_sec)*1000 +</div><div class="line">                shortest-&gt;when_ms - now_ms;</div><div class="line"></div><div class="line">            // 如果没到时</div><div class="line">            if (ms &gt; 0) &#123;</div><div class="line">                // 保存时长到tvp中</div><div class="line">                tvp-&gt;tv_sec = ms/1000;</div><div class="line">                tvp-&gt;tv_usec = (ms % 1000)*1000;</div><div class="line">            // 如果已经到时，则将tvp的时间设置为0</div><div class="line">            &#125; else &#123;</div><div class="line">                tvp-&gt;tv_sec = 0;</div><div class="line">                tvp-&gt;tv_usec = 0;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        // 没有获取到了最早到时的时间事件，时间事件链表为空</div><div class="line">        &#125; else &#123;</div><div class="line">            /* If we have to check for events but need to return</div><div class="line">             * ASAP because of AE_DONT_WAIT we need to set the timeout</div><div class="line">             * to zero */</div><div class="line">            // 如果设置了不阻塞标识</div><div class="line">            if (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                // 将tvp的时间设置为0，就不会阻塞</div><div class="line">                tv.tv_sec = tv.tv_usec = 0;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 阻塞到第一个时间事件的到来</div><div class="line">                /* Otherwise we can block */</div><div class="line">                tvp = NULL; /* wait forever */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 等待所监听文件描述符上有事件发生</div><div class="line">        // 如果tvp为NULL，则阻塞在此，否则等待tvp设置阻塞的时间，就会有时间事件到时</div><div class="line">        // 返回了就绪文件事件的个数</div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        // 遍历就绪文件事件表</div><div class="line">        for (j = 0; j &lt; numevents; j++) &#123;</div><div class="line">            // 获取就绪文件事件的地址</div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line">            // 获取就绪文件事件的类型，文件描述符</div><div class="line">            int mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            int fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            int rfired = 0;</div><div class="line"></div><div class="line">        /* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</div><div class="line">             * event removed an element that fired and we still didn&apos;t</div><div class="line">             * processed, so we check if the event is still valid. */</div><div class="line">            // 如果是文件可读事件发生</div><div class="line">            if (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                // 设置读事件标识 且 调用读事件方法处理读事件</div><div class="line">                rfired = 1;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            // 如果是文件可写事件发生</div><div class="line">            if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line">                // 读写事件的执行发法不同，则执行写事件，避免重复执行相同的方法</div><div class="line">                if (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            processed++;    //执行的事件次数加1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /* Check time events */</div><div class="line">    // 执行时间事件</div><div class="line">    if (flags &amp; AE_TIME_EVENTS)</div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    return processed; /* return the number of processed file/time events */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>刚才提到该函数的一个参数是AE_ALL_EVENTS，他的定义在ae.h中，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define AE_FILE_EVENTS 1                                //文件事件</div><div class="line">#define AE_TIME_EVENTS 2                                //时间事件</div><div class="line">#define AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)   //文件和时间事件</div><div class="line">#define AE_DONT_WAIT 4                                  //不阻塞等待标识</div></pre></td></tr></table></figure></p>
<p>很明显，flags是AE_FILE_EVENTS和AE_TIME_EVENTS或的结果，他们的含义如下：</p>
<ul>
<li>如果flags = 0，函数什么都不做，直接返回</li>
<li>如果flags设置了 AE_ALL_EVENTS ，则执行所有类型的事件</li>
<li>如果flags设置了 AE_FILE_EVENTS ，则执行文件事件</li>
<li>如果flags设置了 AE_TIME_EVENTS ，则执行时间事件</li>
<li>如果flags设置了 AE_DONT_WAIT ，那么函数处理完事件后直接返回，不阻塞等待<br>Redis服务器在没有被事件触发时，就会阻塞等待，因为没有设置AE_DONT_WAIT标识。但是他不会一直的死等待，等待文件事件的到来，因为他还要处理时间时间，因此，在调用aeApiPoll进行监听之前，先从时间事件表中获取一个最近到达的时间时间，根据要等待的时间构建一个struct timeval tv, *tvp结构的变量，这个变量保存着服务器阻塞等待文件事件的最长时间，一旦时间到达而没有触发文件事件，aeApiPoll函数就会停止阻塞，进而调用processTimeEvents处理时间事件，因为Redis服务器设定一个对自身资源和状态进行检查的周期性检查的时间事件，而该函数就是timeProc所指向的回调函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果在阻塞等待的最长时间之间，触发了文件事件，就会先执行文件事件，后执行时间事件，因此处理时间事件通常比预设的会晚一点。</p>
<p>而执行文件事件rfileProc和wfileProc也是调用了回调函数，Redis将文件事件的处理分为了好几种，用于处理不同的网络通信需求，下面列出回调函数的原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask)</div></pre></td></tr></table></figure></p>
<ul>
<li>acceptTcpHandler：用于accept client的connect。</li>
<li>acceptUnixHandler：用于acceptclient的本地connect。</li>
<li>sendReplyToClient：用于向client发送命令回复。</li>
<li>readQueryFromClient：用于读入client发送的请求。<br>接下来，我们查看获取最快达到的时间事件的函数aeSearchNearestTimer实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 寻找第一个快到时的时间事件</div><div class="line">// 这个操作是有用的知道有多少时间可以选择该事件设置为不用推迟任何事件的睡眠中。</div><div class="line">// 如果事件链表没有时间将返回NULL。</div><div class="line">static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)</div><div class="line">&#123;</div><div class="line">    // 时间事件头节点地址</div><div class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</div><div class="line">    aeTimeEvent *nearest = NULL;</div><div class="line"></div><div class="line">    // 遍历所有的时间事件</div><div class="line">    while(te) &#123;</div><div class="line">        // 寻找第一个快到时的时间事件，保存到nearest中</div><div class="line">        if (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</div><div class="line">                (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</div><div class="line">                 te-&gt;when_ms &lt; nearest-&gt;when_ms))</div><div class="line">            nearest = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    return nearest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数没什么，就是遍历链表，找到最小值。我们重点看执行时间事件的函数processTimeEvents实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">/* Process time events */</div><div class="line">// 执行时间事件</div><div class="line">static int processTimeEvents(aeEventLoop *eventLoop) &#123;</div><div class="line">    int processed = 0;</div><div class="line">    aeTimeEvent *te, *prev;</div><div class="line">    long long maxId;</div><div class="line">    time_t now = time(NULL);</div><div class="line"></div><div class="line">    // 这里尝试发现时间混乱的情况，上一次处理事件的时间比当前时间还要大</div><div class="line">    // 重置最近一次处理事件的时间</div><div class="line">    if (now &lt; eventLoop-&gt;lastTime) &#123;</div><div class="line">        te = eventLoop-&gt;timeEventHead;</div><div class="line">        while(te) &#123;</div><div class="line">            te-&gt;when_sec = 0;</div><div class="line">            te = te-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 设置上一次时间事件处理的时间为当前时间</div><div class="line">    eventLoop-&gt;lastTime = now;</div><div class="line"></div><div class="line">    prev = NULL;</div><div class="line">    te = eventLoop-&gt;timeEventHead;</div><div class="line">    maxId = eventLoop-&gt;timeEventNextId-1;   //当前时间事件表中的最大ID</div><div class="line">    // 遍历时间事件链表</div><div class="line">    while(te) &#123;</div><div class="line">        long now_sec, now_ms;</div><div class="line">        long long id;</div><div class="line"></div><div class="line">        /* Remove events scheduled for deletion. */</div><div class="line">        // 如果时间事件已被删除了</div><div class="line">        if (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</div><div class="line">            aeTimeEvent *next = te-&gt;next;</div><div class="line">            // 从事件链表中删除事件的节点</div><div class="line">            if (prev == NULL)</div><div class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</div><div class="line">            else</div><div class="line">                prev-&gt;next = te-&gt;next;</div><div class="line">            // 调用时间事件终结方法清楚该事件</div><div class="line">            if (te-&gt;finalizerProc)</div><div class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</div><div class="line">            zfree(te);</div><div class="line">            te = next;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 确保我们不处理在此迭代中由时间事件创建的时间事件。 请注意，此检查目前无效：我们总是在头节点添加新的计时器，但是如果我们更改实施细节，则该检查可能会再次有用：我们将其保留在未来的防御</div><div class="line">        if (te-&gt;id &gt; maxId) &#123;</div><div class="line">            te = te-&gt;next;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        // 获取当前时间</div><div class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">        // 找到已经到时的时间事件</div><div class="line">        if (now_sec &gt; te-&gt;when_sec ||</div><div class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</div><div class="line">        &#123;</div><div class="line">            int retval;</div><div class="line"></div><div class="line">            id = te-&gt;id;</div><div class="line">            // 调用时间事件处理方法</div><div class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</div><div class="line">            // 时间事件次数加1</div><div class="line">            processed++;</div><div class="line">            // 如果不是定时事件，则继续设置它的到时时间</div><div class="line">            if (retval != AE_NOMORE) &#123;</div><div class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</div><div class="line">            // 如果是定时时间，则retval为-1，则将其时间事件删除，惰性删除</div><div class="line">            &#125; else &#123;</div><div class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 更新前驱节点指针和后继节点指针</div><div class="line">        prev = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    return processed;   //返回执行事件的次数</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果时间事件不存在，则就调用finalizerProc指向的回调函数，删除当前的时间事件。如果存在，就调用timeProc指向的回调函数处理时间事件。Redis的时间事件分为两类</p>
<ul>
<li>定时事件：让一段程序在指定的时间后执行一次。</li>
<li>周期性事件：让一段程序每隔指定的时间后执行一次。<br>如果当前的时间事件是周期性，那么就会在将时间周期添加到周期事件的到时时间中。如果是定时事件，则将该时间事件删除。</li>
</ul>
<p>至此，Redis事件的实现就剖析完毕，但是事件的其他API，例如：创建事件，删除事件，调整事件表的大小等等都没有列出。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="He Lei" />
          <p class="site-author-name" itemprop="name">He Lei</p>
          <p class="site-description motion-element" itemprop="description">c/c++/python | redis | recommend algorithm | search engine</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">69</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mcgrady-forever" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wuxubj" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He Lei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
