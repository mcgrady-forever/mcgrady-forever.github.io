<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta property="og:type" content="website">
<meta property="og:title" content="HeLei Blog">
<meta property="og:url" content="http://hlei.io/page/4/index.html">
<meta property="og:site_name" content="HeLei Blog">
<meta property="og:description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HeLei Blog">
<meta name="twitter:description" content="c/c++/python | redis | recommend algorithm | search engine">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hlei.io/page/4/"/>





  <title> HeLei Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HeLei Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">不要因为走得太远，就忘记为什么而出发</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/08/redis-analysis-intset/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/redis-analysis-intset/" itemprop="url">
                  Redis源码剖析和注释（五）--- 整数集合(intset)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-08T03:42:50+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>整数集合（intset）是集合键底层实现之一。集合键另一实现是值为空的散列表（hash table），虽然使用散列表对集合的加入删除元素，判断元素是否存在等等操作时间复杂度为O(1)，但是当存储的元素是整型且元素数目较少时，如果使用散列表存储，就会比较浪费内存，因此整数集合（intset）类型因为节约内存就存在。</p>
<p>散列表的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SADD set1 1 2 3</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; SADD set1 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SMEMBERS set1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">127.0.0.1:6379&gt; SISMEMBER set1 2</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SREM set1 1</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SMEMBERS set1</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-整数集合结构的实现"><a href="#2-整数集合结构的实现" class="headerlink" title="2. 整数集合结构的实现"></a>2. 整数集合结构的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis根目录下的intset.h文件</div><div class="line"></div><div class="line">typedef struct intset &#123;</div><div class="line">    uint32_t encoding;  //编码格式，有如下三种格式，初始值默认为INTSET_ENC_INT16</div><div class="line">    uint32_t length;    //集合元素数量</div><div class="line">    int8_t contents[];  //保存元素的数组，元素类型并不一定是ini8_t类型，柔性数组不占intset结构体大小，并且数组中的元素从小到大排列。</div><div class="line">&#125; intset;               //整数集合结构</div><div class="line"></div><div class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))   //16位，2个字节，表示范围-32,768~32,767</div><div class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))   //32位，4个字节，表示范围-2,147,483,648~2,147,483,647</div><div class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))   //64位，8个字节，表示范围-9,223,372,036,854,775</div></pre></td></tr></table></figure>
<h2 id="3-升级"><a href="#3-升级" class="headerlink" title="3. 升级"></a>3. 升级</h2><p>intset整数集合之所以有三种表示编码格式的宏定义，是因为根据存储的元素数值大小，能够选取一个最”合适”的类型存储，”合适”可以理解为：既能够表示元素的大小，又可以节省空间。</p>
<p>因此，当新添加的元素，例如：65535，超过当前集合编码格式所能表示的范围，就要进行升级操作。</p>
<p>我们使用刚才命令中的集合，它在结构如下图：<br>[url01]</p>
<h3 id="3-1获得新元素的编码格式"><a href="#3-1获得新元素的编码格式" class="headerlink" title="3.1获得新元素的编码格式"></a>3.1获得新元素的编码格式</h3><p>当前新元素要插入到集合中时，首先就要判获得新元素的编码格式，所以调用_intsetValueEncoding()来返回一个”适合”该元素的编码格式。65535的最”适合”的编码格式是INTSET_ENC_INT32。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;    //返回合适v的编码方式</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)             //如果超出32位所能表示数值的范围则返回INTSET_ENC_INT64</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)        //如果超出16位所能表示数值的范围则返回INTSET_ENC_INT32</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;                    //否则返回用16位表示的INTSET_ENC_INT16</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-调整内存空间"><a href="#3-2-调整内存空间" class="headerlink" title="3.2 调整内存空间"></a>3.2 调整内存空间</h3><p>当得到新元素的编码格式后，就要将集合中所有元素的编码格式都要变成升级后的编码格式，因此，需要调整集合数组contents的内存空间大小，调用intsetResize()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Resize the intset */</div><div class="line">static intset *intsetResize(intset *is, uint32_t len) &#123; //调整集合的内存空间大小</div><div class="line">    uint32_t size = len*intrev32ifbe(is-&gt;encoding);     //计算数组的大小</div><div class="line">    is = zrealloc(is,sizeof(intset)+size);  </div><div class="line">    //分配空间，如果新空间的大小比原来的空间大，那么数组的元素会被保留</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>intrev32ifbe()是一个宏定义，定义和实现在redis根目录下的endianconv.h和endianconv.c中根据主机字节序用来做整数大小端的转换。<br>已经获知65535的编码格式，因此调整内存空间的大小等于编码格式的大小乘以集合元素的个数。如果图：<br>[url02]<br>注意：encoding成员已经发生变化，但是length并没有更新。</li>
</ul>
<h3 id="3-3-根据编码格式设置对应的值"><a href="#3-3-根据编码格式设置对应的值" class="headerlink" title="3.3 根据编码格式设置对应的值"></a>3.3 根据编码格式设置对应的值</h3><p>调整好内存空间后就根据编码格式来设置集合元素的值和最后将新元素添加到集合中，都调用_intsetSet()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Set the value at pos, using the configured encoding. */</div><div class="line">//根据集合is设置的编码方式，设置下标为pos的值为value</div><div class="line">static void _intsetSet(intset *is, int pos, int64_t value) &#123;    </div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获取集合设置的编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;             //如果是64位</div><div class="line">        ((int64_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev64ifbe(((int64_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;      //如果是32位</div><div class="line">        ((int32_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev32ifbe(((int32_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else &#123;</div><div class="line">        ((int16_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev16ifbe(((int16_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>memrev16ifbe()是一个宏定义，定义和实现在redis根目录下的endianconv.h和endianconv.c中根据主机字节序用来做内存大小端的转换。</li>
</ul>
<p>将集合中原来的元素和新插入的元素以”合适”的编码格式INTSET_ENC_INT32写到数组中，顺序过程如下图：<br>[url03]</p>
<p>最后要更新length。</p>
<h3 id="3-4-升级实现源码"><a href="#3-4-升级实现源码" class="headerlink" title="3.4 升级实现源码"></a>3.4 升级实现源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123; //根据value的编码方式，对整数集合is的编码格式升级</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);    //当前集合的编码方式</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);   //得到value合适的编码方式</div><div class="line">    int length = intrev32ifbe(is-&gt;length);          //集合元素数量</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;                //如果value小于0，则要将value添加到数组最前端，因此为移动1个编码长度</div><div class="line">    //集合的编码格式要升级，也就是内存增大</div><div class="line">    //因为 value 的编码比集合原有的其他元素的编码都要大，所以value如果是负数，就是最小值，如果是正数则是最大值</div><div class="line">    //索引value要么放在数组集合的最前端，要么最后端，根据prepend判断</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);    //更新集合is的编码方式</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //根据新的编码方式重新设置内存空间大小</div><div class="line"></div><div class="line">    /* Upgrade back-to-front so we don&apos;t overwrite values.</div><div class="line">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</div><div class="line">     * space at either the beginning or the end of the intset. */</div><div class="line">    //_intsetGetEncoded()得到下标为length的值</div><div class="line">    //_intsetSet设置下标为prepend+length的值为_intsetGetEncoded返回的值</div><div class="line">    //但是，编码格式已经发生改变，数组元素没变但是内存大小改变</div><div class="line">    while(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)    //value是负数，要放在最前端</div><div class="line">        _intsetSet(is,0,value); //设置下标为0的值为value</div><div class="line">    else</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);  //value为正数，设置最末尾+1的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //数组元素加1</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-5-升级的特点"><a href="#3-5-升级的特点" class="headerlink" title="3.5 升级的特点"></a>3.5 升级的特点</h3><ul>
<li>提升灵活性：因为C语言是静态类型的语言，通常在在数组中只是用一种类型保存数据，例如，要么只用int16_t类型，要么只用int32_t类型。通过自动升级底层数组来适应不同类型的新元素，不必担心类型的错误。</li>
<li>节约内存：整数集合既可以让集合保存三种不同类型的值，又可以确保升级操作只在有需要的时候进行，这样就节省了内存。</li>
<li>不支持降级：一旦对数组进行升级，编码就会一直保存升级后的状态。</li>
</ul>
<h2 id="4-整数集合的其他操作"><a href="#4-整数集合的其他操作" class="headerlink" title="4.整数集合的其他操作"></a>4.整数集合的其他操作</h2><p>源代码注释下载：redis源码注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div></pre></td><td class="code"><pre><div class="line">intset *intsetNew(void);    //创建一个空集合</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success);//将value添加到is集合中，如果成功success被设置为1否则为0</div><div class="line">intset *intsetRemove(intset *is, int64_t value, int *success);//从集合中删除value，删除成功success设置为1，失败为0</div><div class="line">uint8_t intsetFind(intset *is, int64_t value);//返回1表示value是集合中的元素，否则返回0</div><div class="line">int64_t intsetRandom(intset *is);//随机返回一个元素</div><div class="line">uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);//获得下标为pos的值并保存在value中</div><div class="line">uint32_t intsetLen(intset *is);//返回集合的元素个数</div><div class="line">size_t intsetBlobLen(intset *is);//返回集合所占用的字节总量</div><div class="line"></div><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;    //返回合适v的编码方式</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)         //如果超出32位所能表示数值的范围则返回INTSET_ENC_INT64</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)    //如果超出16位所能表示数值的范围则返回INTSET_ENC_INT32</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;                //返回用16位表示的INTSET_ENC_INT16</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return the value at pos, given an encoding. */</div><div class="line">static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) &#123;    //根据编码方式enc，返回在集合is中下标为pos的元素</div><div class="line">    int64_t v64;</div><div class="line">    int32_t v32;</div><div class="line">    int16_t v16;</div><div class="line"></div><div class="line">    if (enc == INTSET_ENC_INT64) &#123;  //64位编码</div><div class="line">        memcpy(&amp;v64,((int64_t*)is-&gt;contents)+pos,sizeof(v64));  //从下标pos开始的内存空间拷贝64bit的数据到v64</div><div class="line">        memrev64ifbe(&amp;v64); //如果是大端序，就会转换成小端序</div><div class="line">        return v64;</div><div class="line">    &#125; else if (enc == INTSET_ENC_INT32) &#123;//32位编码</div><div class="line">        memcpy(&amp;v32,((int32_t*)is-&gt;contents)+pos,sizeof(v32));//从下标pos开始的内存空间拷贝32bit的数据到v32</div><div class="line">        memrev32ifbe(&amp;v32); //32位大小端转换</div><div class="line">        return v32;</div><div class="line">    &#125; else &#123;//16位编码</div><div class="line">        memcpy(&amp;v16,((int16_t*)is-&gt;contents)+pos,sizeof(v16));//从下标pos开始的内存空间拷贝16bit的数据到v16</div><div class="line">        memrev16ifbe(&amp;v16); //16位大小端转换</div><div class="line">        return v16;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return the value at pos, using the configured encoding. */</div><div class="line">static int64_t _intsetGet(intset *is, int pos) &#123;    //根据集合is设置的编码方式，返回下标为pos的值</div><div class="line">    return _intsetGetEncoded(is,pos,intrev32ifbe(is-&gt;encoding));</div><div class="line">    //intrev32ifbe()函数返回参数的编码格式并且根据需求转换大小端</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Set the value at pos, using the configured encoding. */</div><div class="line">static void _intsetSet(intset *is, int pos, int64_t value) &#123;    //根据集合is设置的编码方式，设置下标为pos的值为value</div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获取集合设置的编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;             //如果是64位</div><div class="line">        ((int64_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev64ifbe(((int64_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;      //如果是32位</div><div class="line">        ((int32_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev32ifbe(((int32_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else &#123;</div><div class="line">        ((int16_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev16ifbe(((int16_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Create an empty intset. */</div><div class="line">intset *intsetNew(void) &#123;           //创建一个空集合</div><div class="line">    intset *is = zmalloc(sizeof(intset));   //分配空间</div><div class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);  //设置编码方式</div><div class="line">    is-&gt;length = 0; //集合为空</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Resize the intset */</div><div class="line">static intset *intsetResize(intset *is, uint32_t len) &#123; //调整集合的内存空间大小</div><div class="line">    uint32_t size = len*intrev32ifbe(is-&gt;encoding); //计算数组的大小</div><div class="line">    is = zrealloc(is,sizeof(intset)+size);  //分配空间，如果新空间的大小比原来的空间大，那么数组的元素会被保留</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and</div><div class="line"> * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when</div><div class="line"> * the value is not present in the intset and sets &quot;pos&quot; to the position</div><div class="line"> * where &quot;value&quot; can be inserted. */</div><div class="line">//找到is集合中值为value的下标，返回1，并保存在pos中，没有找到返回0，并将pos设置为value可以插入到数组的位置</div><div class="line">static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) &#123;</div><div class="line">    int min = 0, max = intrev32ifbe(is-&gt;length)-1, mid = -1;</div><div class="line">    int64_t cur = -1;</div><div class="line"></div><div class="line">    /* The value can never be found when the set is empty */</div><div class="line">    if (intrev32ifbe(is-&gt;length) == 0) &#123;    //如果为空集合</div><div class="line">        if (pos) *pos = 0;                  //pos设置为0</div><div class="line">        return 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Check for the case where we know we cannot find the value,</div><div class="line">         * but do know the insert position. */</div><div class="line">        if (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)-1)) &#123;    //因为数组是有序的，如果value大于数组最大值</div><div class="line">            if (pos) *pos = intrev32ifbe(is-&gt;length);       //可以将pos设置为数组末尾</div><div class="line">            return 0;</div><div class="line">        &#125; else if (value &lt; _intsetGet(is,0)) &#123;  //如果小于数组的最小值</div><div class="line">            if (pos) *pos = 0;          //pos可以是下标为0的位置</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while(max &gt;= min) &#123; //有序集合中进行二分查找</div><div class="line">        mid = ((unsigned int)min + (unsigned int)max) &gt;&gt; 1; //(min+max)/2，找到中间数的下标</div><div class="line">        cur = _intsetGet(is,mid);   //等到下标为mid的值cur</div><div class="line">        if (value &gt; cur) &#123;  //value大于当前值cur</div><div class="line">            min = mid+1;    //后一半找</div><div class="line">        &#125; else if (value &lt; cur) &#123;   //value小于当前值cur</div><div class="line">            max = mid-1;    //前一半找</div><div class="line">        &#125; else &#123;</div><div class="line">            break;  //找到退出循环</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (value == cur) &#123; //确认找到</div><div class="line">        if (pos) *pos = mid;    //设置pos为找到的位置，返回1</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (pos) *pos = min;    //此时min和max相等，所以pos可以设置为min或max，返回0</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123; //根据value的编码方式，对整数集合is的编码格式升级</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);    //当前集合的编码方式</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);   //得到value合适的编码方式</div><div class="line">    int length = intrev32ifbe(is-&gt;length);          //集合元素数量</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;                //如果value小于0，则要将value添加到数组最前端，因此为移动1个编码长度</div><div class="line">    //集合的编码格式要升级，也就是内存增大</div><div class="line">    //因为 value 的编码比集合原有的其他元素的编码都要大，所以value如果是负数，就是最小值，如果是正数则是最大值</div><div class="line">    //索引value要么放在数组集合的最前端，要么最后端，根据prepend判断</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);    //更新集合is的编码方式</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //根据新的编码方式重新设置内存空间大小</div><div class="line"></div><div class="line">    /* Upgrade back-to-front so we don&apos;t overwrite values.</div><div class="line">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</div><div class="line">     * space at either the beginning or the end of the intset. */</div><div class="line">    //_intsetGetEncoded()得到下标为length的值</div><div class="line">    //_intsetSet设置下标为prepend+length的值为_intsetGetEncoded返回的值</div><div class="line">    //但是，编码格式已经发生改变，数组元素没变但是内存大小改变</div><div class="line">    while(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)    //value是负数，要放在最前端</div><div class="line">        _intsetSet(is,0,value); //设置下标为0的值为value</div><div class="line">    else</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);  //value为正数，设置最末尾+1的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //数组元素加1</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) &#123;    //向前或向后移动指定下标范围内的数组元素</div><div class="line">    void *src, *dst;</div><div class="line">    uint32_t bytes = intrev32ifbe(is-&gt;length)-from; //获得要移动的元素的个数</div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获得集合is的默认编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;         //判断不同的编码格式</div><div class="line">        src = (int64_t*)is-&gt;contents+from;      //获得要被移动范围的起始地址</div><div class="line">        dst = (int64_t*)is-&gt;contents+to;        //获得要被移动到的目的地址</div><div class="line">        bytes *= sizeof(int64_t);               //计算要移动多少个字节</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;</div><div class="line">        src = (int32_t*)is-&gt;contents+from;</div><div class="line">        dst = (int32_t*)is-&gt;contents+to;</div><div class="line">        bytes *= sizeof(int32_t);</div><div class="line">    &#125; else &#123;</div><div class="line">        src = (int16_t*)is-&gt;contents+from;</div><div class="line">        dst = (int16_t*)is-&gt;contents+to;</div><div class="line">        bytes *= sizeof(int16_t);</div><div class="line">    &#125;</div><div class="line">    memmove(dst,src,bytes); //从src开始移动bytes个字节到dst</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Insert an integer in the intset */</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123;//将value添加到is集合中，如果成功success被设置为1否则为0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 1;  //设置success默认为1</div><div class="line"></div><div class="line">    /* Upgrade encoding if necessary. If we need to upgrade, we know that</div><div class="line">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</div><div class="line">     * because it lies outside the range of existing values. */</div><div class="line">    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;  //如果value的编码类型大于集合的编码类型</div><div class="line">        /* This always succeeds, so we don&apos;t need to curry *success. */</div><div class="line">        return intsetUpgradeAndAdd(is,value);   //升级集合，并且将value加入集合，一定成功</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Abort if the value is already present in the set.</div><div class="line">         * This call will populate &quot;pos&quot; with the right position to insert</div><div class="line">         * the value when it cannot be found. */</div><div class="line">        if (intsetSearch(is,value,&amp;pos)) &#123;  //查找value，若果value已经存在，intsetSearch返回1,如果不存在，pos保存value可以插入的位置</div><div class="line">            if (success) *success = 0;  //value存在，success设置为0</div><div class="line">            return is;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //value在集合中不存在，且pos保存可以插入的位置</div><div class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //调整集合大小</div><div class="line">        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1);   //如果pos不是在数组末尾则要移动调整集合</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _intsetSet(is,pos,value);   //设置pos下标的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //集合节点数量加1</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Delete integer from intset */</div><div class="line">intset *intsetRemove(intset *is, int64_t value, int *success) &#123; //从集合中删除value，删除成功success设置为1，失败为0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 0;  //设置success默认为0</div><div class="line"></div><div class="line">    //如果value的编码格式小于集合的编码格式且value在集合中已存在，pos保存着下标</div><div class="line">    if (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">        uint32_t len = intrev32ifbe(is-&gt;length);    //备份当前集合元素数量</div><div class="line"></div><div class="line">        /* We know we can delete */</div><div class="line">        if (success) *success = 1;  //删除成功，设置success为1</div><div class="line"></div><div class="line">        /* Overwrite value with tail and update length */</div><div class="line">        if (pos &lt; (len-1)) intsetMoveTail(is,pos+1,pos);    //如果不是最后一个元素，则移动元素覆盖掉被删除的元素</div><div class="line">        is = intsetResize(is,len-1);    //缩小大小</div><div class="line">        is-&gt;length = intrev32ifbe(len-1);   //更新集合元素个数</div><div class="line">    &#125;</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Determine whether a value belongs to this set */</div><div class="line">uint8_t intsetFind(intset *is, int64_t value) &#123;     //返回1表示value是集合中的元素，否则返回0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    return valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL);</div><div class="line">    //如果value的编码格式小于集合的编码格式且value在集合中已存在，返回1，其中任何一个不成立返回0</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return random member */</div><div class="line">int64_t intsetRandom(intset *is) &#123;  //随机返回一个元素</div><div class="line">    return _intsetGet(is,rand()%intrev32ifbe(is-&gt;length));  //随机生成一个下标，返回该下标的值</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Sets the value to the value at the given position. When this position is</div><div class="line"> * out of range the function returns 0, when in range it returns 1. */</div><div class="line">uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) &#123;   //获得下标为pos的值并保存在value中</div><div class="line">    if (pos &lt; intrev32ifbe(is-&gt;length)) &#123;   //如果pos小于数组长度</div><div class="line">        *value = _intsetGet(is,pos);        //返回pos下标的值，保存在value中</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return intset length */</div><div class="line">uint32_t intsetLen(intset *is) &#123;    //返回集合的元素个数</div><div class="line">    return intrev32ifbe(is-&gt;length);    //返回length成员</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return intset blob size in bytes. */</div><div class="line">size_t intsetBlobLen(intset *is) &#123;  //返回集合所占用的字节总量</div><div class="line">    return sizeof(intset)+intrev32ifbe(is-&gt;length)*intrev32ifbe(is-&gt;encoding);  //编码格式×元素个数+集合大小</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/05/redis-analysis-skiplist/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/05/redis-analysis-skiplist/" itemprop="url">
                  Redis源码剖析和注释（六）--- 压缩列表(ziplist)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-05T08:43:29+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-跳跃表（skiplist）介绍"><a href="#1-跳跃表（skiplist）介绍" class="headerlink" title="1. 跳跃表（skiplist）介绍"></a>1. 跳跃表（skiplist）介绍</h2><p>定义：跳跃表是一个有序链表，其中每个节点包含不定数量的链接，节点中的第i个链接构成的单向链表跳过含有少于i个链接的节点。</p>
<ul>
<li>跳跃表支持平均O(logN)，最坏O(N)</li>
<li>复杂度的节点查找，大部分情况下，跳跃表的效率可以和平衡树相媲美。</li>
<li>跳跃表在redis中当数据较多时作为有序集合键的实现方式之一。</li>
</ul>
<p>接下来，还是举个有序集合键的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; ZADD score 95.5 Mike 98 Li 96 Wang  //socre是一个有序集合键</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; ZRANGE score 0 -1 WITHSCORES//所有分数按从小到大排列，每一个成员都保存了一个分数</div><div class="line">1) &quot;Mike&quot;</div><div class="line">2) &quot;95.5&quot;</div><div class="line">3) &quot;Wang&quot;</div><div class="line">4) &quot;96&quot; </div><div class="line">5) &quot;Li&quot;</div><div class="line">6) &quot;98&quot;</div><div class="line">127.0.0.1:6379&gt; ZSCORE score Mike       //查询Mike的分值</div><div class="line">&quot;95.5&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-跳跃表的实现"><a href="#2-跳跃表的实现" class="headerlink" title="2. 跳跃表的实现"></a>2. 跳跃表的实现</h2><p>redis 3.0版本将跳跃表定义在redis.h文件中，而3.2版本定义在server.h文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">跳跃表节点 zskiplistNode</div><div class="line">typedef struct zskiplistNode &#123;</div><div class="line">    robj *obj;                          //保存成员对象的地址</div><div class="line">    double score;                       //分值</div><div class="line">    struct zskiplistNode *backward;     //后退指针</div><div class="line">    struct zskiplistLevel &#123;</div><div class="line">        struct zskiplistNode *forward;  //前进指针</div><div class="line">        unsigned int span;              //跨度</div><div class="line">    &#125; level[];                          //层级，柔型数组</div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">跳跃表表头 zskiplist（记录跳跃表信息）</div><div class="line">typedef struct zskiplist &#123;</div><div class="line">    struct zskiplistNode *header, *tail;//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</div><div class="line">    unsigned long length;       //跳跃表的长度或跳跃表节点数量计数器，除去第一个节点</div><div class="line">    int level;                  //跳跃表中节点的最大层数，除了第一个节点</div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h2 id="3-幂次定律"><a href="#3-幂次定律" class="headerlink" title="3. 幂次定律"></a>3. 幂次定律</h2><p>在redis中，返回一个随机层数值，随机算法所使用的幂次定律。</p>
<ul>
<li>含义是：如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律。</li>
<li>表现是：少数几个事件的发生频率占了整个发生频率的大部分， 而其余的大多数事件只占整个发生频率的一个小部分。</li>
</ul>
<p>在文件t_set.c中，zslRandomLevel函数的定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int zslRandomLevel(void) &#123;          //返回一个随机层数值</div><div class="line">    int level = 1;</div><div class="line">    //(random()&amp;0xFFFF)只保留低两个字节的位值，其他高位全部清零，所以该值范围为0到0xFFFF</div><div class="line">    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))  //ZSKIPLIST_P（0.25）所以level+1的概率为0.25</div><div class="line">        level += 1;         //返回一个1到ZSKIPLIST_MAXLEVEL（32）之间的值</div><div class="line">    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^32 elements */</div><div class="line">#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */</div></pre></td></tr></table></figure></p>
<p>算法性能分析：</p>
<p>层数至少为1，所以层数恰好等于1（不执行while循环体）的概率为 1−p.</p>
<ul>
<li>层数恰好等于2的概率为 p(1−p)（执行1次while循环体）。</li>
<li>层数恰好等于3的概率为 p^2(1−p)（执行2次while循环体）。</li>
<li>层数恰好等于4的概率为 p^3(1−p)（执行3次while循环体）。</li>
<li>层数恰好等于k的概率为 p^k−1(1−p)（执行k-1次while循环体）。（k &lt;= ZSKIPLIST_MAXLEVEL）<br>因此，一个节点的平均层数，或平均指针数为：</li>
</ul>
<p>​ 1×(1−p)+2p(1−p)+3p^2(1−p)+…+kp^(k−1)(1−p)<br>​ =1/(1−p)</p>
<p>因此，<br>当 p = 1/2 时，每个节点的平均指针为2；<br>当 p = 1/4 时，每个节点的平均指针为1.33；<br>而redis的概率 ZSKIPLIST_P 取值就为0.25，所以跳跃表的指针开销为1.33</p>
<h2 id="4-跳跃表与哈希表和平衡树的比较"><a href="#4-跳跃表与哈希表和平衡树的比较" class="headerlink" title="4. 跳跃表与哈希表和平衡树的比较"></a>4. 跳跃表与哈希表和平衡树的比较</h2><p>跳跃表和平衡树的元素都是有序排列，而哈希表不是有序的。因此在哈希表上的查找只能是单个key的查找，不适合做范围查找。</p>
<ul>
<li>跳跃表和平衡树做范围查找时，跳跃表算法简单，实现方便，而平衡树逻辑复杂。</li>
<li>查找单个key，跳跃表和平衡树的平均时间复杂度都为O(logN)，而哈希表的时间复杂度为O(1)。</li>
<li>跳跃表平均每个节点包含1.33个指针，而平衡树每个节点包含2个指针，更加节约内存。</li>
</ul>
<p>因此，在redis中实现有序集合的办法是：跳跃表+哈希表</p>
<ul>
<li>跳跃表元素有序，而且可以范围查找，且比平衡树简单。</li>
<li>哈希表查找单个key时间复杂度性能高。</li>
</ul>
<h2 id="5-跳跃表基本操作"><a href="#5-跳跃表基本操作" class="headerlink" title="5 跳跃表基本操作"></a>5 跳跃表基本操作</h2><p>redis关于跳跃表的API都定义在t_zset.c文件中。</p>
<h3 id="5-1-创建跳跃表-zslCreate"><a href="#5-1-创建跳跃表-zslCreate" class="headerlink" title="5.1 创建跳跃表 zslCreate()"></a>5.1 创建跳跃表 zslCreate()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">zskiplist *zslCreate(void) &#123;        //创建返回一个跳跃表 表头zskiplist</div><div class="line">    int j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    zsl = zmalloc(sizeof(*zsl));       //分配空间</div><div class="line">    zsl-&gt;level = 1;                     //设置默认层数</div><div class="line">    zsl-&gt;length = 0;                    //设置跳跃表长度</div><div class="line">    //创建一个层数为32，分数为0，没有obj的跳跃表头节点</div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</div><div class="line"></div><div class="line">    //跳跃表头节点初始化</div><div class="line">    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = NULL;   //将跳跃表头节点的所有前进指针forward设置为NULL</div><div class="line">        zsl-&gt;header-&gt;level[j].span = 0;         //将跳跃表头节点的所有跨度span设置为0</div><div class="line">    &#125;</div><div class="line">    zsl-&gt;header-&gt;backward = NULL;           //跳跃表头节点的后退指针backward置为NULL</div><div class="line"></div><div class="line">    zsl-&gt;tail = NULL;                       //表头指向跳跃表尾节点的指针置为NULL</div><div class="line">    return zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-2-插入节点-zslInsert"><a href="#5-2-插入节点-zslInsert" class="headerlink" title="5.2 插入节点 zslInsert()"></a>5.2 插入节点 zslInsert()</h3><p>//创建一个节点，分数为score，对象为obj，插入到zsl表头管理的跳跃表中，并返回新节点的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    int i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line"></div><div class="line">    x = zsl-&gt;header;            //获取跳跃表头结点地址，从头节点开始一层一层遍历</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;       //遍历头节点的每个level，从下标最大层减1到0</div><div class="line">        /* store rank that is crossed to reach the insert position */</div><div class="line">        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];  //更新rank[i]为i+1所跨越的节点数，但是最外一层为0</div><div class="line"></div><div class="line">        //这个while循环是查找的过程，沿着x指针遍历跳跃表，满足以下条件则要继续在当层往前走</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;       //当前层的前进指针不为空且</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||  //当前的要插入的score大于当前层的score或</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp; //当前score等于要插入的score且</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; 0))) &#123;//当前层的对象与要插入的obj不等</div><div class="line"></div><div class="line">            rank[i] += x-&gt;level[i].span;   //记录该层一共跨越了多少节点 加上 上一层遍历所跨越的节点数</div><div class="line">            x = x-&gt;level[i].forward;       //指向下一个节点</div><div class="line">        &#125;</div><div class="line">        //while循环跳出时，用update[i]记录第i层所遍历到的最后一个节点，遍历到i=0时，就要在该节点后要插入节点</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* we assume the key is not already inside, since we allow duplicated</div><div class="line">     * scores, and the re-insertion of score and redis object should never</div><div class="line">     * happen since the caller of zslInsert() should test in the hash table</div><div class="line">     * if the element is already inside or not.</div><div class="line">     * zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</div><div class="line">     * 所以这里不需要进一步进行检查，可以直接创建新元素。</div><div class="line">     */</div><div class="line"></div><div class="line">    level = zslRandomLevel();       //获得一个随机的层数</div><div class="line">    if (level &gt; zsl-&gt;level) &#123;       //如果大于当前所有节点最大的层数时</div><div class="line">        for (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = 0;            //将大于等于原来zsl-&gt;level层以上的rank[]设置为0</div><div class="line">            update[i] = zsl-&gt;header;    //将大于等于原来zsl-&gt;level层以上update[i]指向头结点</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length; //update[i]已经指向头结点，将第i层的跨度设置为length</div><div class="line">                                                    //length代表跳跃表的节点数量</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;     //更新表中的最大成数值</div><div class="line">    &#125;</div><div class="line">    x = zslCreateNode(level,score,obj);     //创建一个节点</div><div class="line">    for (i = 0; i &lt; level; i++) &#123;       //遍历每一层</div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;  //设置新节点的前进指针为查找时（while循环）每一层最后一个节点的的前进指针</div><div class="line">        update[i]-&gt;level[i].forward = x;//再把查找时每层的最后一个节点的前进指针设置为新创建的节点地址</div><div class="line"></div><div class="line">        /* update span covered by update[i] as x is inserted here */</div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);  //更新插入节点的跨度值</div><div class="line">        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;               //更新插入节点前一个节点的跨度值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* increment span for untouched levels */</div><div class="line">    for (i = level; i &lt; zsl-&gt;level; i++) &#123;  //如果插入节点的level小于原来的zsl-&gt;level才会执行</div><div class="line">        update[i]-&gt;level[i].span++;             //因为高度没有达到这些层，所以只需将查找时每层最后一个节点的值的跨度加1</div><div class="line">    &#125;</div><div class="line">    //设置插入节点的后退指针，就是查找时最下层的最后一个节点，该节点的地址记录在update[0]中</div><div class="line">    //如果插入在第二个节点，也就是头结点后的位置就将后退指针设置为NULL</div><div class="line">    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</div><div class="line"></div><div class="line">    if (x-&gt;level[0].forward)    //如果x节点不是最尾部的节点</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x;  //就将x节点后面的节点的后退节点设置成为x地址</div><div class="line">    else</div><div class="line">        zsl-&gt;tail = x;  //否则更新表头的tail指针，指向最尾部的节点x</div><div class="line">    zsl-&gt;length++;      //跳跃表节点计数器加1</div><div class="line">    return x;           //返回x地址</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-3-删除节点"><a href="#4-3-删除节点" class="headerlink" title="4.3 删除节点"></a>4.3 删除节点</h3><p>//被zslDelete, zslDeleteByScore and zslDeleteByRank使用的内部函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123;  //删除节点</div><div class="line">    int i;</div><div class="line"></div><div class="line">    //设置前进指针和跨度</div><div class="line">    for (i = 0; i &lt; zsl-&gt;level; i++) &#123;              //遍历下标为0到跳跃表最大层数-1的层</div><div class="line">        if (update[i]-&gt;level[i].forward == x) &#123;     //如果找到该节点</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;   //将前一个节点的跨度减1</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">            //前一个节点的前进指针指向被删除的节点的后一个节点，跳过该节点</div><div class="line">        &#125; else &#123;</div><div class="line">            update[i]-&gt;level[i].span -= 1;  //在第i层没找到，只将该层的最后一个节点的跨度减1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //设置后退指针</div><div class="line">    if (x-&gt;level[0].forward) &#123;      //如果被删除的前进节点不为空，后面还有节点</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;    //就将后面节点的后退指针指向被删除节点x的回退指针</div><div class="line">    &#125; else &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;       //否则直接将被删除的x节点的后退节点设置为表头的tail指针</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //更新跳跃表最大层数</div><div class="line">    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    zsl-&gt;length--;  //节点计数器减1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-4-获取节点排名"><a href="#4-4-获取节点排名" class="headerlink" title="4.4 获取节点排名"></a>4.4 获取节点排名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) &#123;   //查找score和o对象在跳跃表中的排位</div><div class="line">    zskiplistNode *x;</div><div class="line">    unsigned long rank = 0;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;        //遍历头结点的每一层</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||          //只要分值还小于给定的score或者</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;     //分值相等但是对象小于给定对象o</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= 0))) &#123;</div><div class="line">            rank += x-&gt;level[i].span;   //更新排位值</div><div class="line">            x = x-&gt;level[i].forward;    //指向下一个节点</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</div><div class="line">        //确保在第i层找到分值相同，且对象相同时才会返回排位值</div><div class="line">        if (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            return rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;   //没找到</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-5-区间操作"><a href="#4-5-区间操作" class="headerlink" title="4.5 区间操作"></a>4.5 区间操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) &#123; //返回第一个分数在range范围内的节点</div><div class="line">    zskiplistNode *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    /* If everything is out of range, return early. */</div><div class="line">    if (!zslIsInRange(zsl,range)) return NULL;  //如果不在范围内，则返回NULL，确保至少有一个节点符号range</div><div class="line"></div><div class="line">    //判断下限</div><div class="line">    x = zsl-&gt;header;//遍历跳跃表</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;//遍历每一层</div><div class="line">        /* Go forward while *OUT* of range. */</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;           //如果该层有下一个节点且</div><div class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))//当前节点的score还小于(小于等于)range的min</div><div class="line">                x = x-&gt;level[i].forward;        //继续指向下一个节点</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* This is an inner range, so the next node cannot be NULL. */</div><div class="line">    x = x-&gt;level[0].forward;    //找到目标节点</div><div class="line">    redisAssert(x != NULL);     //保证能找到</div><div class="line"></div><div class="line">    /* Check if score &lt;= max. */</div><div class="line">    //判断上限</div><div class="line">    if (!zslValueLteMax(x-&gt;score,range)) return NULL;   //该节点的分值如果比max还要大，就返回NULL</div><div class="line">    return x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) &#123;//返回最后一个分数在range范围内的节点</div><div class="line">    zskiplistNode *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    /* If everything is out of range, return early. */</div><div class="line">    if (!zslIsInRange(zsl,range)) return NULL;  //如果不在范围内，则返回NULL，确保至少有一个节点符号range</div><div class="line"></div><div class="line">    //判断上限</div><div class="line">    x = zsl-&gt;header;//遍历跳跃表</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;   //遍历每一层</div><div class="line">        /* Go forward while *IN* range. */</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;   //如果该层有下一个节点且</div><div class="line">            zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))//当前节点的score小于(小于等于)max</div><div class="line">                x = x-&gt;level[i].forward;    //继续指向下一个节点</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* This is an inner range, so this node cannot be NULL. */</div><div class="line">    redisAssert(x != NULL);//保证能找到</div><div class="line"></div><div class="line">    /* Check if score &gt;= min. */</div><div class="line">    //判断下限</div><div class="line">    if (!zslValueGteMin(x-&gt;score,range)) return NULL;   //如果找到的节点的分值比range的min还要小</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/04/redis-analysis-dict/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/04/redis-analysis-dict/" itemprop="url">
                  Redis源码剖析和注释（三）---字典结构
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-04T06:45:54+08:00">
                2018-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>字典又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。例如：redis中的所有key到value的映射，就是通过字典结构维护，还有hash类型的键值。</p>
<p>通过redis中的命令感受一下哈希键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HSET user name Mike </div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HSET user passwd 123456</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HSET user sex male</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HLEN user       //user就是一个包含3个键值对的哈希键</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; HGETALL user</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;Mike&quot;</div><div class="line">3) &quot;passwd&quot;</div><div class="line">4) &quot;123456&quot;</div><div class="line">5) &quot;sex&quot;</div><div class="line">6) &quot;male&quot;</div></pre></td></tr></table></figure></p>
<p>user键在底层实现就是一个字典，字典包含3个键值对。</p>
<h2 id="2-字典的实现"><a href="#2-字典的实现" class="headerlink" title="2. 字典的实现"></a>2. 字典的实现</h2><p>redis的字典是由哈希表实现的，一个哈希表有多个节点，每个节点保存一个键值对。</p>
<h3 id="2-1-哈希表"><a href="#2-1-哈希表" class="headerlink" title="2.1 哈希表"></a>2.1 哈希表</h3><p>redis中哈希表定义在dict.h/dictht中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht &#123; //哈希表</div><div class="line">    dictEntry **table;      //存放一个数组的地址，数组存放着哈希表节点dictEntry的地址。</div><div class="line">    unsigned long size;     //哈希表table的大小，初始化大小为4</div><div class="line">    unsigned long sizemask; //用于将哈希值映射到table的位置索引。它的值总是等于(size-1)。</div><div class="line">    unsigned long used;     //记录哈希表已有的节点（键值对）数量。</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure></p>
<h3 id="2-2-哈希表节点"><a href="#2-2-哈希表节点" class="headerlink" title="2.2 哈希表节点"></a>2.2 哈希表节点</h3><p>哈希表的table指向的数组存放这dictEntry类型的地址。也定义在dict.h/dictEntryt中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ypedef struct dictEntry &#123;</div><div class="line">    void *key;                  //key</div><div class="line">    union &#123;</div><div class="line">        void *val;</div><div class="line">        uint64_t u64;</div><div class="line">        int64_t s64;</div><div class="line">        double d;</div><div class="line">    &#125; v;                        //value</div><div class="line">    struct dictEntry *next;     //指向下一个hash节点，用来解决hash键冲突（collision）</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure></p>
<p>下图展现的就是通过链接法（chaining）来解决冲突的方法。<br>[url01]</p>
<h3 id="2-3-字典"><a href="#2-3-字典" class="headerlink" title="2.3 字典"></a>2.3 字典</h3><p>字典结构定义在dict.h/dict中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct dict &#123;</div><div class="line">    dictType *type;     //指向dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据。</div><div class="line">    void *privdata;     //私有数据，保存着dictType结构中函数的参数。</div><div class="line">    dictht ht[2];       //两张哈希表。</div><div class="line">    long rehashidx;     //rehash的标记，rehashidx==-1，表示没在进行rehash</div><div class="line">    int iterators;      //正在迭代的迭代器数量</div><div class="line">&#125; dict;</div></pre></td></tr></table></figure></p>
<p>dictType类型保存着 操作字典不同类型key和value的方法 的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictType &#123;</div><div class="line">    unsigned int (*hashFunction)(const void *key);      //计算hash值的函数</div><div class="line">    void *(*keyDup)(void *privdata, const void *key);   //复制key的函数</div><div class="line">    void *(*valDup)(void *privdata, const void *obj);   //复制value的函数</div><div class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);  //比较key的函数</div><div class="line">    void (*keyDestructor)(void *privdata, void *key);   //销毁key的析构函数</div><div class="line">    void (*valDestructor)(void *privdata, void *obj);   //销毁val的析构函数</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure></p>
<p>下图展现的就是刚才命令user哈希键所展现的内部结构：<br>[url02]</p>
<h2 id="3-哈希算法"><a href="#3-哈希算法" class="headerlink" title="3. 哈希算法"></a>3. 哈希算法</h2><p>Thomas Wang认为好的hash函数具有两个好的特点：</p>
<ul>
<li>hash函数是可逆的。</li>
<li>具有雪崩效应，意思是，输入值1bit位的变化会造成输出值1/2的bit位发生变化</li>
</ul>
<h3 id="3-1-计算int整型哈希值的哈希函数"><a href="#3-1-计算int整型哈希值的哈希函数" class="headerlink" title="3.1 计算int整型哈希值的哈希函数"></a>3.1 计算int整型哈希值的哈希函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">unsigned int dictIntHashFunction(unsigned int key)      //用于计算int整型哈希值的哈希函数</div><div class="line">&#123;</div><div class="line">    key += ~(key &lt;&lt; 15);</div><div class="line">    key ^=  (key &gt;&gt; 10);</div><div class="line">    key +=  (key &lt;&lt; 3);</div><div class="line">    key ^=  (key &gt;&gt; 6);</div><div class="line">    key += ~(key &lt;&lt; 11);</div><div class="line">    key ^=  (key &gt;&gt; 16);</div><div class="line">    return key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-MurmurHash2哈希算法"><a href="#3-2-MurmurHash2哈希算法" class="headerlink" title="3.2 MurmurHash2哈希算法"></a>3.2 MurmurHash2哈希算法</h3><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis用MurmurHash2算法来计算哈希值，能产生32-bit或64-bit哈希值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">unsigned int dictGenHashFunction(const void *key, int len) &#123;  //用于计算字符串的哈希值的哈希函数</div><div class="line">    /* &apos;m&apos; and &apos;r&apos; are mixing constants generated offline.</div><div class="line">     They&apos;re not really &apos;magic&apos;, they just happen to work well.  */</div><div class="line">    //m和r这两个值用于计算哈希值，只是因为效果好。</div><div class="line">    uint32_t seed = dict_hash_function_seed;</div><div class="line">    const uint32_t m = 0x5bd1e995;</div><div class="line">    const int r = 24;</div><div class="line"></div><div class="line">    /* Initialize the hash to a &apos;random&apos; value */</div><div class="line">    uint32_t h = seed ^ len;    //初始化</div><div class="line"></div><div class="line">    /* Mix 4 bytes at a time into the hash */</div><div class="line">    const unsigned char *data = (const unsigned char *)key;</div><div class="line"></div><div class="line">    //将字符串key每四个一组看成uint32_t类型，进行运算的到h</div><div class="line">    while(len &gt;= 4) &#123;</div><div class="line">        uint32_t k = *(uint32_t*)data;</div><div class="line"></div><div class="line">        k *= m;</div><div class="line">        k ^= k &gt;&gt; r;</div><div class="line">        k *= m;</div><div class="line"></div><div class="line">        h *= m;</div><div class="line">        h ^= k;</div><div class="line"></div><div class="line">        data += 4;</div><div class="line">        len -= 4;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Handle the last few bytes of the input array  */</div><div class="line">    switch(len) &#123;</div><div class="line">    case 3: h ^= data[2] &lt;&lt; 16;</div><div class="line">    case 2: h ^= data[1] &lt;&lt; 8;</div><div class="line">    case 1: h ^= data[0]; h *= m;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    /* Do a few final mixes of the hash to ensure the last few</div><div class="line">     * bytes are well-incorporated. */</div><div class="line">    h ^= h &gt;&gt; 13;</div><div class="line">    h *= m;</div><div class="line">    h ^= h &gt;&gt; 15;</div><div class="line"></div><div class="line">    return (unsigned int)h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-djb哈希算法"><a href="#3-3-djb哈希算法" class="headerlink" title="3.3 djb哈希算法"></a>3.3 djb哈希算法</h3><p>djb哈希算法，算法的思想是利用字符串中的ascii码值与一个随机seed，通过len次变换，得到最后的hash值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) &#123;   //用于计算字符串的哈希值的哈希函数</div><div class="line">    unsigned int hash = (unsigned int)dict_hash_function_seed;</div><div class="line"></div><div class="line">    while (len--)</div><div class="line">        hash = ((hash &lt;&lt; 5) + hash) + (tolower(*buf++)); /* hash * 33 + c */</div><div class="line">    return hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-rehash"><a href="#4-rehash" class="headerlink" title="4. rehash"></a>4. rehash</h2><p>当哈希表的大小不能满足需求，就可能会有两个或者以上数量的键被分配到了哈希表数组上的同一个索引上，于是就发生冲突（collision），在Redis中解决冲突的办法是链接法（separate chaining）。但是需要尽可能避免冲突，希望哈希表的负载因子（load factor），维持在一个合理的范围之内，就需要对哈希表进行扩展或收缩。</p>
<p>Redis对哈希表的rehash操作步骤如下：</p>
<ul>
<li>扩展或收缩 <ul>
<li>扩展：ht[1]的大小为第一个大于等于ht[0].used * 2的 2n 。</li>
<li>收缩：ht[1]的大小为第一个大于等于ht[0].used的 2n 。</li>
</ul>
</li>
<li>将所有的ht[0]上的节点rehash到ht[1]上。</li>
<li>释放ht[0]，将ht[1]设置为第0号表，并创建新的ht[1]。</li>
</ul>
<p>源码：</p>
<ul>
<li><p>扩展操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static int _dictExpandIfNeeded(dict *d) //扩展d字典，并初始化</div><div class="line">&#123;</div><div class="line">    /* Incremental rehashing already in progress. Return. */</div><div class="line">    if (dictIsRehashing(d)) return DICT_OK;     //正在进行rehash，直接返回</div><div class="line"></div><div class="line">    /* If the hash table is empty expand it to the initial size. */</div><div class="line">    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE); //如果字典（的 0 号哈希表）为空，那么创建并返回初始化大小的 0 号哈希表</div><div class="line"></div><div class="line">    /* If we reached the 1:1 ratio, and we are allowed to resize the hash</div><div class="line">     * table (global setting) or we should avoid it but the ratio between</div><div class="line">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</div><div class="line">     * the number of buckets. */</div><div class="line">    //1. 字典已使用节点数和字典大小之间的比率接近 1：1</div><div class="line">    //2. 能够扩展的标志为真</div><div class="line">    //3. 已使用节点数和字典大小之间的比率超过 dict_force_resize_ratio</div><div class="line">    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp; (dict_can_resize ||    </div><div class="line">         d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))    </div><div class="line">    &#123;</div><div class="line">        return dictExpand(d, d-&gt;ht[0].used*2);  //扩展为节点个数的2倍</div><div class="line">    &#125;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>收缩操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int dictResize(dict *d)     //缩小字典d</div><div class="line">&#123;</div><div class="line">    int minimal;</div><div class="line"></div><div class="line">    //如果dict_can_resize被设置成0，表示不能进行rehash，或正在进行rehash，返回出错标志DICT_ERR</div><div class="line">    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;</div><div class="line"></div><div class="line">    minimal = d-&gt;ht[0].used;            //获得已经有的节点数量作为最小限度minimal</div><div class="line">    if (minimal &lt; DICT_HT_INITIAL_SIZE)//但是minimal不能小于最低值DICT_HT_INITIAL_SIZE（4）</div><div class="line">        minimal = DICT_HT_INITIAL_SIZE;</div><div class="line">    return dictExpand(d, minimal);      //用minimal调整字典d的大小</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>扩展和收缩操作都调用了dictExpand()函数，该函数通过计算传入的第二个大小参数进行计算，算出一个最接近2n的realsize，然后进行扩展或收缩，dictExpand()函数源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">int dictExpand(dict *d, unsigned long size)     //根据size调整或创建字典d的哈希表</div><div class="line">&#123;</div><div class="line">    dictht n; /* the new hash table */</div><div class="line">    unsigned long realsize = _dictNextPower(size);  //获得一个最接近2^n的realsize</div><div class="line"></div><div class="line">    /* the size is invalid if it is smaller than the number of</div><div class="line">     * elements already inside the hash table */</div><div class="line">    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size) //正在rehash或size不够大返回出错标志</div><div class="line">        return DICT_ERR;</div><div class="line"></div><div class="line">    /* Rehashing to the same table size is not useful. */</div><div class="line">    if (realsize == d-&gt;ht[0].size) return DICT_ERR; //如果新的realsize和原本的size一样则返回出错标志</div><div class="line">    /* Allocate the new hash table and initialize all pointers to NULL */</div><div class="line">    //初始化新的哈希表的成员</div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize-1;</div><div class="line">    n.table = zcalloc(realsize*sizeof(dictEntry*));</div><div class="line">    n.used = 0;</div><div class="line"></div><div class="line">    /* Is this the first initialization? If so it&apos;s not really a rehashing</div><div class="line">     * we just set the first hash table so that it can accept keys. */</div><div class="line">    if (d-&gt;ht[0].table == NULL) &#123;   //如果ht[0]哈希表为空，则将新的哈希表n设置为ht[0]</div><div class="line">        d-&gt;ht[0] = n;</div><div class="line">        return DICT_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Prepare a second hash table for incremental rehashing */</div><div class="line">    d-&gt;ht[1] = n;           //如果ht[0]非空，则需要rehash</div><div class="line">    d-&gt;rehashidx = 0;       //设置rehash标志位为0，开始渐进式rehash（incremental rehashing）</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>收缩或者扩展哈希表需要将ht[0]表中的所有键全部rehash到ht[1]中，但是rehash操作不是一次性、集中式完成的，而是分多次，渐进式，断续进行的，这样才不会对服务器性能造成影响。因此下面介绍渐进式rehash。</p>
<h2 id="5-渐进式rehash（incremental-rehashing）"><a href="#5-渐进式rehash（incremental-rehashing）" class="headerlink" title="5. 渐进式rehash（incremental rehashing）"></a>5. 渐进式rehash（incremental rehashing）</h2><p>渐进式rehash的关键：</p>
<ol>
<li>字典结构dict中的一个成员rehashidx，当rehashidx为-1时表示不进行rehash，当rehashidx值为0时，表示开始进行rehash。</li>
<li>在rehash期间，每次对字典的添加、删除、查找、或更新操作时，都会判断是否正在进行rehash操作，如果是，则顺带进行单步rehash，并将rehashidx+1。</li>
<li>当rehash时进行完成时，将rehashidx置为-1，表示完成rehash。</li>
</ol>
<p>源码在此：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">static void _dictRehashStep(dict *d) &#123;      //单步rehash</div><div class="line">    if (d-&gt;iterators == 0) dictRehash(d,1); //当迭代器数量不为0，才能进行1步rehash</div><div class="line">&#125;</div><div class="line"></div><div class="line">int dictRehash(dict *d, int n) &#123;       //n步进行rehash</div><div class="line">    int empty_visits = n*10; /* Max number of empty buckets to visit. */</div><div class="line">    if (!dictIsRehashing(d)) return 0;  //只有rehashidx不等于-1时，才表示正在进行rehash，否则返回0</div><div class="line"></div><div class="line">    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;  //分n步，而且ht[0]上还有没有移动的节点</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        /* Note that rehashidx can&apos;t overflow as we are sure there are more</div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        //确保rehashidx没有越界，因为rehashidx是从-1开始，0表示已经移动1个节点，它总是小于hash表的size的</div><div class="line">        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</div><div class="line"></div><div class="line">        //第一个循环用来更新 rehashidx 的值，因为有些桶为空，所以 rehashidx并非每次都比原来前进一个位置，而是有可能前进几个位置，但最多不超过 10。</div><div class="line">        //将rehashidx移动到ht[0]有节点的下标，也就是table[d-&gt;rehashidx]非空</div><div class="line">        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            if (--empty_visits == 0) return 1;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[0].table[d-&gt;rehashidx];     //ht[0]下标为rehashidx有节点，得到该节点的地址</div><div class="line">        /* Move all the keys in this bucket from the old to the new hash HT */</div><div class="line">        //第二个循环用来将ht[0]表中每次找到的非空桶中的链表（或者就是单个节点）拷贝到ht[1]中</div><div class="line">        while(de) &#123;</div><div class="line">            unsigned int h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;  //备份下一个节点的地址</div><div class="line">            /* Get the index in the new hash table */</div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;    //获得计算哈希值并得到哈希表中的下标h</div><div class="line"></div><div class="line">            //将该节点插入到下标为h的位置</div><div class="line">            de-&gt;next = d-&gt;ht[1].table[h];</div><div class="line">            d-&gt;ht[1].table[h] = de;</div><div class="line"></div><div class="line">            //更新两个表节点数目计数器</div><div class="line">            d-&gt;ht[0].used--;</div><div class="line">            d-&gt;ht[1].used++;</div><div class="line"></div><div class="line">            //将de指向以一个处理的节点</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;    //迁移过后将该下标的指针置为空</div><div class="line">        d-&gt;rehashidx++;                         //更新rehashidx</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if we already rehashed the whole table... */</div><div class="line">    if (d-&gt;ht[0].used == 0) &#123;           //ht[0]上已经没有节点了，说明已经迁移完成</div><div class="line">        zfree(d-&gt;ht[0].table);          //释放hash表内存</div><div class="line">        d-&gt;ht[0] = d-&gt;ht[1];            //将迁移过的1号哈希表设置为0号哈希表</div><div class="line">        _dictReset(&amp;d-&gt;ht[1]);          //重置ht[1]哈希表</div><div class="line">        d-&gt;rehashidx = -1;              //rehash标志关闭</div><div class="line">        return 0;                       //表示前已完成</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* More to rehash... */</div><div class="line">    return 1;           //表示还有节点等待迁移</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6. 迭代器"></a>6. 迭代器</h2><p>redis在字典结构也定义了迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictIterator &#123;</div><div class="line">    dict *d;                    //被迭代的字典</div><div class="line">    long index;                 //迭代器当前所指向的哈希表索引位置</div><div class="line">    int table, safe;            //table表示正迭代的哈希表号码，ht[0]或ht[1]。safe表示这个迭代器是否安全。</div><div class="line">    dictEntry *entry, *nextEntry;   //entry指向当前迭代的哈希表节点，nextEntry则指向当前节点的下一个节点。</div><div class="line">    /* unsafe iterator fingerprint for misuse detection. */</div><div class="line">    long long fingerprint;      //避免不安全迭代器的指纹标记</div><div class="line">&#125; dictIterator;</div></pre></td></tr></table></figure></p>
<p>迭代器分为安全迭代器和不安全迭代器：</p>
<p>非安全迭代器只能进行Get等读的操作, 而安全迭代器则可以进行iterator支持的任何操作。<br>由于dict结构中保存了safe iterators的数量，如果数量不为0， 是不能进行下一步的rehash的; 因此安全迭代器的存在保证了遍历数据的准确性。<br>在非安全迭代器的迭代过程中, 会通过fingerprint方法来校验iterator在初始化与释放时字典的hash值是否一致; 如果不一致说明迭代过程中发生了非法操作.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/04/redis-analysis-sds/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/04/redis-analysis-sds/" itemprop="url">
                  Redis源码剖析和注释（二）---简单动态字符串
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-04T06:02:51+08:00">
                2018-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>Redis兼容传统的C语言字符串类型，但没有直接使用C语言的传统的字符串（以’\0’结尾的字符数组）表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的对象。简单动态字符串在Redis数据库中应用很广泛，例如：键值对在底层就是由SDS实现的。</p>
<p>在redis种，有一种数据类型叫string类型，而string类型简单的说就是SDS实现的（简单理解），先通过几个命令来感受一下string类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET str1 Redis  //设置key:value = str1:Redis</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GET str1        //获取str1的value</div><div class="line">&quot;Redis&quot;</div><div class="line">127.0.0.1:6379&gt; TYPE str1       //获取key的存储类型 string类型</div><div class="line">string</div><div class="line">127.0.0.1:6379&gt; STRLEN str1     //str1的长度为5字节</div><div class="line">(integer) 5</div></pre></td></tr></table></figure></p>
<h2 id="2-SDS的定义"><a href="#2-SDS的定义" class="headerlink" title="2.SDS的定义"></a>2.SDS的定义</h2><p>SDS定义在redis源码根目录下的sds.h/sdshdr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef char *sds;  </div><div class="line">//sds兼容传统C风格字符串，所以起了个别名叫sds，并且可以存放sdshdr结构buf成员的地址</div></pre></td></tr></table></figure></p>
<p>SDS也有一个表头（header）用来存放sds的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct sdshdr &#123;</div><div class="line">    int len;        //buf中已占用空间的长度</div><div class="line">    int free;       //buf中剩余可用空间的长度</div><div class="line">    char buf[];     //初始化sds分配的数据空间，而且是柔性数组（Flexible array member）</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>根据这个结构体，我们用图大概表示一下str1，如下图：<br><img src="/2018/02/04/redis-analysis-s2s/redis-sds01.jpg" alt="sdshdr"></p>
<p>这里写图片描述</p>
<ul>
<li>len为5，表示这个sds长度为5字节。</li>
<li>free为2，表示这个sds还有2个字节未使用的空间。</li>
<li>buf是一个char[]的数组，分配了（len+1+free）个字节的长度，前len个字节保存着’R’、’e’、’d’、’i’、’s’这5个字符，接下来的1个字节保存着’\0’，剩下的free个字节未使用</li>
</ul>
<h2 id="3-SDS的优点"><a href="#3-SDS的优点" class="headerlink" title="3. SDS的优点"></a>3. SDS的优点</h2><p>SDS本质上就是char *，因为有了表头sdshdr结构的存在，所以SDS比传统C字符串在某些方面更加优秀，并且能够兼容传统C字符串。</p>
<h2 id="3-1-兼容C的部分函数"><a href="#3-1-兼容C的部分函数" class="headerlink" title="3.1 兼容C的部分函数"></a>3.1 兼容C的部分函数</h2><p>因为SDS兼容传统的C字符串，采用以’\0’作为结尾，所以SDS就能够使用一部分</p>
<h2 id="3-2-二进制安全（Binary-Safe）"><a href="#3-2-二进制安全（Binary-Safe）" class="headerlink" title="3.2 二进制安全（Binary Safe）"></a>3.2 二进制安全（Binary Safe）</h2><p>因为传统C字符串符合ASCII编码，这种编码的操作的特点就是：遇零则止 。即，当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片，视频等二进制文件，操作文件时就被截断了。</p>
<p>而SDS表头的buf被定义为字节数组，因为判断是否到达字符串结尾的依据则是表头的len成员，这意味着它可以存放任何二进制的数据和文本数据，包括’\0’，如下图：<br><img src="/2018/02/04/redis-analysis-s2s/redis-sds02.jpg" alt="buf"></p>
<h2 id="3-3-获得字符串长度的操作复杂度为O-1"><a href="#3-3-获得字符串长度的操作复杂度为O-1" class="headerlink" title="3.3 获得字符串长度的操作复杂度为O(1)"></a>3.3 获得字符串长度的操作复杂度为O(1)</h2><p>传统的C字符串获得长度时的做法：遍历字符串的长度，遇零则止，复杂度为O(n)。</p>
<p>而SDS表头的len成员就保存着字符串长度，所以获得字符串长度的操作复杂度为O(1)。</p>
<h2 id="3-4-杜绝缓冲区溢出"><a href="#3-4-杜绝缓冲区溢出" class="headerlink" title="3.4 杜绝缓冲区溢出"></a>3.4 杜绝缓冲区溢出</h2><p>因为SDS表头的free成员记录着buf字符数组中未使用空间的字节数，所以，在进行APPEND命令向字符串后追加字符串时，如果不够用会先进行内存扩展，在进行追加。</p>
<p>总之，正是因为表头的存在，使得redis的字符串有这么多优点</p>
<h2 id="4-SDS源码剖析"><a href="#4-SDS源码剖析" class="headerlink" title="4. SDS源码剖析"></a>4. SDS源码剖析</h2><h3 id="4-1-SDS内存分配策略—空间预分配"><a href="#4-1-SDS内存分配策略—空间预分配" class="headerlink" title="4.1 SDS内存分配策略—空间预分配"></a>4.1 SDS内存分配策略—空间预分配</h3><p>空间预分配策略用于优化SDS的字符串增长操作。</p>
<p>如果对SDS进行修改后，SDS表头的len成员小于1MB，那么就会分配和len长度相同的未使用空间。free和len成员大小相等。<br>如果对SDS进行修改后，SDS的长度大于等于1MB，那么就会分配1MB的未使用空间。<br>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">sds sdsMakeRoomFor(sds s, size_t addlen) &#123;      //对 sds 中 buf 的长度进行扩展</div><div class="line">    struct sdshdr *sh, *newsh;</div><div class="line">    size_t free = sdsavail(s);  //获得s的未使用空间长度</div><div class="line">    size_t len, newlen;</div><div class="line"></div><div class="line">    //free的长度够用不用扩展直接返回</div><div class="line">    if (free &gt;= addlen) return s;  </div><div class="line"></div><div class="line">    //free长度不够用，需要扩展</div><div class="line">    len = sdslen(s);    //获得s字符串的长度</div><div class="line">    sh = (void*) (s-(sizeof(struct sdshdr)));       //获取表头地址</div><div class="line">    newlen = (len+addlen);  //扩展后的新长度</div><div class="line"></div><div class="line">    //空间预分配     </div><div class="line">    //#define SDS_MAX_PREALLOC (1024*1024)  </div><div class="line">    //预先分配内存的最大长度为 1MB</div><div class="line">    if (newlen &lt; SDS_MAX_PREALLOC)  //新长度小于“最大预分配长度”，就直接将扩展的新长度乘2</div><div class="line">        newlen *= 2;</div><div class="line">    else</div><div class="line">        newlen += SDS_MAX_PREALLOC; //新长度大于“最大预分配长度”，就在加上一个“最大预分配长度”</div><div class="line">    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);   //获得新的扩展空间的地址</div><div class="line">    if (newsh == NULL) return NULL;</div><div class="line"></div><div class="line">    newsh-&gt;free = newlen - len; //更新新空间的未使用的空间free</div><div class="line">    return newsh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-2-SDS内存释放策略—惰性空间释放"><a href="#4-2-SDS内存释放策略—惰性空间释放" class="headerlink" title="4.2 SDS内存释放策略—惰性空间释放"></a>4.2 SDS内存释放策略—惰性空间释放</h3><p>惰性空间释放用于优化SDS的字符串缩短操作。</p>
<ul>
<li>当要缩短SDS保存的字符串时，程序并不立即使用内存充分配来回收缩短后多出来的字节，而是使用表头的free成员将这些字节记录起来，并等待将来使用。<br>源代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void sdsclear(sds s) &#123;  //重置sds的buf空间，懒惰释放</div><div class="line">    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));</div><div class="line">    sh-&gt;free += sh-&gt;len;    //表头free成员+已使用空间的长度len = 新的free</div><div class="line">    sh-&gt;len = 0;            //已使用空间变为0</div><div class="line">    sh-&gt;buf[0] = &apos;\0&apos;;         //字符串置空</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-3-Redis源码注释"><a href="#4-3-Redis源码注释" class="headerlink" title="4.3 Redis源码注释"></a>4.3 Redis源码注释</h3><ol>
<li><p>在sds.h文件中，有两个static inline的函数，分别是sdslen和sdsavail函数，你可以把它认为是一个static的函数，加上了inline的属性。而inline关键字仅仅是建议编译器做内联展开处理，而不是强制。</p>
</li>
<li><p>在sds.c中，几乎所有的函数所传的参数都是sds类型，而非表头sdshdr的地址，但是使用了通过sds指针运算从而求得表头的地址的技巧，因为sds是指向sdshdr结构buf成员的。通过sds.h/sdslen函数，来分析：</p>
</li>
</ol>
<p>这里的关键就是sds类型是指向sdshdr结构buf成员。</p>
<ul>
<li>struct sdshdr结构共有三个变量，其中sds指向的buf成员是一个柔性数组，它仅仅起到占位符的作用，并不占用该结构体的大小，因此sizeof(sizeof(struct sdshdr))大小为8字节。</li>
<li>由于一个SDS类型的内存是通过动态内存分配的，所以它的内存在堆区，堆由下往上增长，因此sds指针减区sizeof(struct sdshdr)的大小就得到了表头的地址，然后就可以通过”-&gt;”访问表头的成员。如下图：<br><img src="/2018/02/04/redis-analysis-s2s/redis-sds03.jpg" alt="sds&amp;sdshdr"><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static inline size_t sdslen(const sds s) &#123;      //计算buf中字符串的长度</div><div class="line"></div><div class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); //s指针地址减去结构体大小就是结构体的地址</div><div class="line"></div><div class="line">   return sh-&gt;len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过这种技巧，将表头结构隐藏起来，只对外公开sds类型。</p>
<ul>
<li>sds.h文件注释<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#ifndef __SDS_H</div><div class="line">#define __SDS_H</div><div class="line"></div><div class="line">#define SDS_MAX_PREALLOC (1024*1024)    //预先分配内存的最大长度为1MB</div><div class="line"></div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line"></div><div class="line">typedef char *sds;  //sds兼容传统C风格字符串，所以起了个别名叫sds，并且可以存放sdshdr结构buf成员的地址</div><div class="line"></div><div class="line">struct sdshdr &#123;</div><div class="line">    unsigned int len;   //buf中已占用空间的长度</div><div class="line">    unsigned int free;  //buf中剩余可用空间的长度</div><div class="line">    char buf[];         //初始化sds分配的数据空间，而且是柔性数组（Flexible array member）</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static inline size_t sdslen(const sds s) &#123;      //计算buf中字符串的长度</div><div class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));</div><div class="line">    return sh-&gt;len;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline size_t sdsavail(const sds s) &#123;    //计算buf中的未使用空间的长度</div><div class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));</div><div class="line">    return sh-&gt;free;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sds sdsnewlen(const void *init, size_t initlen);    //创建一个长度为initlen的字符串,并保存init字符串中的值</div><div class="line">sds sdsnew(const char *init);       //创建一个默认长度的字符串</div><div class="line">sds sdsempty(void);     //建立一个只有表头，字符串为空&quot;\0&quot;的sds</div><div class="line">size_t sdslen(const sds s); //计算buf中字符串的长度</div><div class="line">sds sdsdup(const sds s);    //拷贝一份s的副本</div><div class="line">void sdsfree(sds s);     //释放s字符串和表头</div><div class="line">size_t sdsavail(const sds s);   //计算buf中的未使用空间的长度</div><div class="line">sds sdsgrowzero(sds s, size_t len); //将sds扩展制定长度并赋值为0</div><div class="line">sds sdscatlen(sds s, const void *t, size_t len);    //将字符串t追加到s表头的buf末尾，追加len个字节</div><div class="line">sds sdscat(sds s, const char *t);       //将t字符串拼接到s的末尾</div><div class="line">sds sdscatsds(sds s, const sds t);      //将sds追加到s末尾</div><div class="line">sds sdscpylen(sds s, const char *t, size_t len);    //将字符串t覆盖到s表头的buf中，拷贝len个字节</div><div class="line">sds sdscpy(sds s, const char *t);       //将字符串覆盖到s表头的buf中</div><div class="line"></div><div class="line">sds sdscatvprintf(sds s, const char *fmt, va_list ap);  //打印函数，被 sdscatprintf 所调用</div><div class="line">#ifdef __GNUC__</div><div class="line">sds sdscatprintf(sds s, const char *fmt, ...)   //打印任意数量个字符串，并将这些字符串追加到给定 sds 的末尾</div><div class="line">    __attribute__((format(printf, 2, 3)));</div><div class="line">#else</div><div class="line">sds sdscatprintf(sds s, const char *fmt, ...);  //打印任意数量个字符串，并将这些字符串追加到给定 sds 的末尾</div><div class="line">#endif</div><div class="line"></div><div class="line">sds sdscatfmt(sds s, char const *fmt, ...); //格式化打印多个字符串，并将这些字符串追加到给定 sds 的末尾</div><div class="line">sds sdstrim(sds s, const char *cset);   //去除sds中包含有 cset字符串出现字符 的字符</div><div class="line">void sdsrange(sds s, int start, int end);   //根据start和end区间截取字符串</div><div class="line">void sdsupdatelen(sds s);           //更新字符串s的长度</div><div class="line">void sdsclear(sds s);               //将字符串重置保存空间，懒惰释放</div><div class="line">int sdscmp(const sds s1, const sds s2);     //比较两个sds的大小，相等返回0</div><div class="line">sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);  //使用长度为seplen的sep分隔符对长度为len的s进行分割，返回一个sds数组的地址，*count被设置为数组元素数量</div><div class="line">void sdsfreesplitres(sds *tokens, int count); //释放tokens中的count个sds元素</div><div class="line">void sdstolower(sds s);     //将sds字符串所有字符转换为小写</div><div class="line">void sdstoupper(sds s);     //将sds字符串所有字符转换为大写</div><div class="line">sds sdsfromlonglong(long long value);       //根据long long value创建一个SDS</div><div class="line">sds sdscatrepr(sds s, const char *p, size_t len);   //将长度为len的字符串p以带引号&quot;&quot;的格式追加到s末尾</div><div class="line">sds *sdssplitargs(const char *line, int *argc); //参数拆分,主要用于 config.c 中对配置文件进行分析。</div><div class="line">sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);    //将s中所有在 from 中的字符串，替换成 to 中的字符串</div><div class="line">sds sdsjoin(char **argv, int argc, char *sep);  //以分隔符连接字符串子数组构成新的字符串</div><div class="line"></div><div class="line">/* Low level functions exposed to the user API */</div><div class="line">sds sdsMakeRoomFor(sds s, size_t addlen);   //对 sds 中 buf 的长度进行扩展</div><div class="line">void sdsIncrLen(sds s, int incr);       //根据incr的正负，移动字符串末尾的&apos;\0&apos;标志</div><div class="line">sds sdsRemoveFreeSpace(sds s);      //回收sds中的未使用空间</div><div class="line">size_t sdsAllocSize(sds s);      //获得sds所有分配的空间</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/01/03/java-concurrent02/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/03/java-concurrent02/" itemprop="url">
                  谈谈Java并发（二）
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-03T01:50:15+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/shamo89/p/6684960.html" target="_blank" rel="external">http://www.cnblogs.com/shamo89/p/6684960.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class Concurrent &#123;</div><div class="line"></div><div class="line">    public final static int THREAD_POOL_SIZE = 5;</div><div class="line"></div><div class="line">    public static Map&lt;String, Integer&gt; crunchifyHashTableObject = null;</div><div class="line">    public static Map&lt;String, Integer&gt; crunchifySynchronizedMapObject = null;</div><div class="line">    public static Map&lt;String, Integer&gt; crunchifyConcurrentHashMapObject = null;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line"></div><div class="line">        // Test with Hashtable Object</div><div class="line">        crunchifyHashTableObject = new Hashtable&lt;String, Integer&gt;();</div><div class="line">        crunchifyPerformTest(crunchifyHashTableObject);</div><div class="line"></div><div class="line">        // Test with synchronizedMap Object</div><div class="line">        crunchifySynchronizedMapObject = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;());</div><div class="line">        crunchifyPerformTest(crunchifySynchronizedMapObject);</div><div class="line"></div><div class="line">        // Test with ConcurrentHashMap Object</div><div class="line">        crunchifyConcurrentHashMapObject = new ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line">        crunchifyPerformTest(crunchifyConcurrentHashMapObject);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void crunchifyPerformTest(final Map&lt;String, Integer&gt; crunchifyThreads) throws InterruptedException &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;Test started for: &quot; + crunchifyThreads.getClass());</div><div class="line">        long averageTime = 0;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line"></div><div class="line">            long startTime = System.nanoTime();</div><div class="line">            ExecutorService crunchifyExServer = Executors.newFixedThreadPool(THREAD_POOL_SIZE);</div><div class="line"></div><div class="line">            for (int j = 0; j &lt; THREAD_POOL_SIZE; j++) &#123;</div><div class="line">                crunchifyExServer.execute(new Runnable() &#123;</div><div class="line">                    @SuppressWarnings(&quot;unused&quot;)</div><div class="line">                    public void run() &#123;</div><div class="line"></div><div class="line">                        for (int i = 0; i &lt; 500000; i++) &#123;</div><div class="line">                            Integer crunchifyRandomNumber = (int) Math.ceil(Math.random() * 550000);</div><div class="line"></div><div class="line">                            // Retrieve value. We are not using it anywhere</div><div class="line">                            Integer crunchifyValue = crunchifyThreads.get(String.valueOf(crunchifyRandomNumber));</div><div class="line"></div><div class="line">                            // Put value</div><div class="line">                            crunchifyThreads.put(String.valueOf(crunchifyRandomNumber), crunchifyRandomNumber);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Make sure executor stops</div><div class="line">            crunchifyExServer.shutdown();</div><div class="line"></div><div class="line">            // Blocks until all tasks have completed execution after a shutdown request</div><div class="line">            crunchifyExServer.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);</div><div class="line"></div><div class="line">            long entTime = System.nanoTime();</div><div class="line">            long totalTime = (entTime - startTime) / 1000000L;</div><div class="line">            averageTime += totalTime;</div><div class="line">            System.out.println(&quot;2500K entried added/retrieved in &quot; + totalTime + &quot; ms&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;For &quot; + crunchifyThreads.getClass() + &quot; the average time is &quot; + averageTime / 5 + &quot; ms\n&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Test started for: class java.util.Hashtable</div><div class="line">2500K entried added/retrieved in 2585 ms</div><div class="line">2500K entried added/retrieved in 1645 ms</div><div class="line">2500K entried added/retrieved in 1612 ms</div><div class="line">2500K entried added/retrieved in 1615 ms</div><div class="line">2500K entried added/retrieved in 1611 ms</div><div class="line">For class java.util.Hashtable the average time is 1813 ms</div><div class="line"></div><div class="line">Test started for: class java.util.Collections$SynchronizedMap</div><div class="line">2500K entried added/retrieved in 2186 ms</div><div class="line">2500K entried added/retrieved in 1730 ms</div><div class="line">2500K entried added/retrieved in 1735 ms</div><div class="line">2500K entried added/retrieved in 1693 ms</div><div class="line">2500K entried added/retrieved in 1435 ms</div><div class="line">For class java.util.Collections$SynchronizedMap the average time is 1755 ms</div><div class="line"></div><div class="line">Test started for: class java.util.concurrent.ConcurrentHashMap</div><div class="line">2500K entried added/retrieved in 941 ms</div><div class="line">2500K entried added/retrieved in 2475 ms</div><div class="line">2500K entried added/retrieved in 768 ms</div><div class="line">2500K entried added/retrieved in 641 ms</div><div class="line">2500K entried added/retrieved in 770 ms</div><div class="line">For class java.util.concurrent.ConcurrentHashMap the average time is 1119 ms</div></pre></td></tr></table></figure></p>
<p>性能表现：ConcurrentHashMap &gt; SynchronizedMap &gt; Hashtable</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2017/12/15/java-concurrent01/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/15/java-concurrent01/" itemprop="url">
                  谈谈Java并发（一）
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-15T03:25:53+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SimpleDateFormat是一个常用的类日期格式化类，这个类不是线程安全的，在多线程环境下调用 format() 和 parse() 方法应该使用同步代码来避免问题。也借由这个问题，进一步来探讨下如何在多线程并发执行的程序中写出安全、高效的代码。</p>
<p>##发现问题<br>例如我们要把时间格式化后再使用，很容易我们可以写出这样一个DateUtil，每次处理一个请求的时候，就需要创建一个SimpleDateFormat实例对象，然后再丢弃这个对象。大量的对象就这样被创建出来，占用大量的内存和jvm空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DateUtil &#123;</div><div class="line">    </div><div class="line">    public static  String formatDate(Date date)throws ParseException&#123;</div><div class="line">         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        return sdf.format(date);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Date parse(String strDate) throws ParseException&#123;</div><div class="line">         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        return sdf.parse(strDate);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你也许会说，OK，那我就创建一个静态的simpleDateFormat实例，然后放到一个DateUtil类（如下）<br>中，在使用时直接使用这个实例进行操作，这样问题就解决了。改进后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.peidasoft.dateformat;</div><div class="line"></div><div class="line">import java.text.ParseException;</div><div class="line">import java.text.SimpleDateFormat;</div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class DateUtil &#123;</div><div class="line">    private static final  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">    </div><div class="line">    public static  String formatDate(Date date)throws ParseException&#123;</div><div class="line">        return sdf.format(date);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Date parse(String strDate) throws ParseException&#123;</div><div class="line"></div><div class="line">        return sdf.parse(strDate);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，这个方法的确很不错，在大部分的时间里面都会工作得很好。但当你在生产环境中使用一段时间之后，你就会发现这么一个事实：它不是线程安全的。在正常的测试情况之下，都没有问题，但一旦在生产环境中一定负载情况下时，这个问题就出来了。他会出现各种不同的情况，比如转化的时间不正确，比如报错，比如线程被挂死等等。我们看下面的测试用例，那事实说话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class DateUtilTest &#123;</div><div class="line">    </div><div class="line">    public static class TestSimpleDateFormatThreadSafe extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while(true) &#123;</div><div class="line">                try &#123;</div><div class="line">                    this.join(2000);</div><div class="line">                &#125; catch (InterruptedException e1) &#123;</div><div class="line">                    e1.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(this.getName()+&quot;:&quot;+DateUtil.parse(&quot;2013-05-24 06:02:20&quot;));</div><div class="line">                &#125; catch (ParseException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        for(int i = 0; i &lt; 3; i++)&#123;</div><div class="line">            new TestSimpleDateFormatThreadSafe().start();</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>执行输出如下：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;Thread-1&quot; java.lang.NumberFormatException: multiple points</div><div class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1082)</div><div class="line">    at java.lang.Double.parseDouble(Double.java:510)</div><div class="line">    at java.text.DigitList.getDouble(DigitList.java:151)</div><div class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1302)</div><div class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1589)</div><div class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1311)</div><div class="line">    at java.text.DateFormat.parse(DateFormat.java:335)</div><div class="line">    at com.peidasoft.orm.dateformat.DateNoStaticUtil.parse(DateNoStaticUtil.java:17)</div><div class="line">    at com.peidasoft.orm.dateformat.DateUtilTest$TestSimpleDateFormatThreadSafe.run(DateUtilTest.java:20)</div><div class="line">Exception in thread &quot;Thread-0&quot; java.lang.NumberFormatException: multiple points</div><div class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1082)</div><div class="line">    at java.lang.Double.parseDouble(Double.java:510)</div><div class="line">    at java.text.DigitList.getDouble(DigitList.java:151)</div><div class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1302)</div><div class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1589)</div><div class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1311)</div><div class="line">    at java.text.DateFormat.parse(DateFormat.java:335)</div><div class="line">    at com.peidasoft.orm.dateformat.DateNoStaticUtil.parse(DateNoStaticUtil.java:17)</div><div class="line">    at com.peidasoft.orm.dateformat.DateUtilTest$TestSimpleDateFormatThreadSafe.run(DateUtilTest.java:20)</div><div class="line">Thread-2:Mon May 24 06:02:20 CST 2021</div><div class="line">Thread-2:Fri May 24 06:02:20 CST 2013</div><div class="line">Thread-2:Fri May 24 06:02:20 CST 2013</div><div class="line">Thread-2:Fri May 24 06:02:20 CST 2013</div></pre></td></tr></table></figure>
<p>##分析问题<br>SimpleDateFormat继承了DateFormat,在DateFormat中定义了一个protected属性的 Calendar类的对象：calendar。只是因为Calendar累的概念复杂，牵扯到时区与本地化等等，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。</p>
<p>##解决问题</p>
<ol>
<li>需要的时候创建新实例：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DateUtil &#123;</div><div class="line">    </div><div class="line">    public static  String formatDate(Date date)throws ParseException&#123;</div><div class="line">         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        return sdf.format(date);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Date parse(String strDate) throws ParseException&#123;</div><div class="line">         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        return sdf.parse(strDate);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：在需要用到SimpleDateFormat 的地方新建一个实例，不管什么时候，将有线程安全问题的对象由共享变为局部私有都能避免多线程问题，不过也加重了创建对象的负担。在一般情况下，这样其实对性能影响比不是很明显的。</p>
<ol>
<li>使用同步：同步SimpleDateFormat对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class DateSyncUtil &#123;</div><div class="line"></div><div class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">      </div><div class="line">    public static String formatDate(Date date)throws ParseException&#123;</div><div class="line">        synchronized(sdf)&#123;</div><div class="line">            return sdf.format(date);</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Date parse(String strDate) throws ParseException&#123;</div><div class="line">        synchronized(sdf)&#123;</div><div class="line">            return sdf.parse(strDate);</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：当线程较多时，当一个线程调用该方法时，其他想要调用此方法的线程就要block，多线程并发量大的时候会对性能有一定的影响。</p>
<ol>
<li><p>使用ThreadLocal：　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ConcurrentDateUtil &#123;</div><div class="line"></div><div class="line">    private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        protected DateFormat initialValue() &#123;</div><div class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public static Date parse(String dateStr) throws ParseException &#123;</div><div class="line">        return threadLocal.get().parse(dateStr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String format(Date date) &#123;</div><div class="line">        return threadLocal.get().format(date);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalDateUtil &#123;</div><div class="line">    private static final String date_format = &quot;yyyy-MM-dd HH:mm:ss&quot;;</div><div class="line">    private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;(); </div><div class="line"> </div><div class="line">    public static DateFormat getDateFormat()   </div><div class="line">    &#123;  </div><div class="line">        DateFormat df = threadLocal.get();  </div><div class="line">        if(df==null)&#123;  </div><div class="line">            df = new SimpleDateFormat(date_format);  </div><div class="line">            threadLocal.set(df);  </div><div class="line">        &#125;  </div><div class="line">        return df;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static String formatDate(Date date) throws ParseException &#123;</div><div class="line">        return getDateFormat().format(date);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Date parse(String strDate) throws ParseException &#123;</div><div class="line">        return getDateFormat().parse(strDate);</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：使用ThreadLocal, 也是将共享变量变为独享，线程独享肯定能比方法独享在并发环境中能减少不少创建对象的开销。如果对性能要求比较高的情况下，一般推荐使用这种方法。</p>
<p>4.抛弃JDK，使用其他类库中的时间格式化类：<br>a. 使用Apache commons 里的FastDateFormat，宣称是既快又线程安全的SimpleDateFormat, 可惜它只能对日期进行format, 不能对日期串进行解析。<br>b. 使用Joda-Time类库来处理时间相关问题</p>
<p>##总结<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">由SimpleDateFormat的线程安全问题，我们在遇到多线程并发问题是可以得到如下的解决方案：</div><div class="line">1. 函数内单独创建对象</div><div class="line">2. 采用同步代码</div><div class="line">3. 用threadlocal变量</div><div class="line">4. 采用线程安全的第三方库</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2017/12/07/linux-file-io/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/07/linux-file-io/" itemprop="url">
                  比较read/write & fread/fwrite
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-07T18:21:43+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UNIX环境下的C对二进制流文件的读写有两套：</p>
<ol>
<li>fopen,fread,fwrite,fprintf</li>
<li>open, read, write</li>
</ol>
<p>##区别</p>
<ol>
<li>fopen 系列是标准的C库函数；open系列是 POSIX 定义的，是UNIX系统里的system call。<br>也就是说，fopen系列更具有可移植性；而open系列只能用在 POSIX 的操作系统上。</li>
<li>使用fopen 系列函数时要定义一个指代文件的对象，被称为“文件句柄”（file handler），是一个结构体；而open系列使用的是一个被称为“文件描述符” （file descriptor）的int型整数。</li>
<li>fopen 系列是级别较高的I/O，读写时使用缓冲；而open系列相对低层，更接近操作系统，读写时没有缓冲。由于能更多地与操作系统打交道，open系列可以访问更改一些fopen系列无法访问的信息，如查看文件的读写权限。这些额外的功能通常因系统而异。</li>
<li>使用fopen系列函数需要”#include <sdtio.h>“；使用open系列函数需要”#include <fcntl.h>“ ，链接时要之用libc（-lc）</fcntl.h></sdtio.h></li>
</ol>
<p>##在开源项目中的运用<br>redis中写日志使用的是第一套,下面是redis的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">void serverLogRaw(int level, const char *msg) &#123;</div><div class="line">    const int syslogLevelMap[] = &#123; LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING &#125;;</div><div class="line">    const char *c = &quot;.-*#&quot;;</div><div class="line">    FILE *fp;</div><div class="line">    char buf[64];</div><div class="line">    int rawmode = (level &amp; LL_RAW);</div><div class="line">    int log_to_stdout = server.logfile[0] == &apos;\0&apos;;</div><div class="line"></div><div class="line">    level &amp;= 0xff; /* clear flags */</div><div class="line">    if (level &lt; server.verbosity) return;</div><div class="line"></div><div class="line">    fp = log_to_stdout ? stdout : fopen(server.logfile,&quot;a&quot;);</div><div class="line">    if (!fp) return;</div><div class="line"></div><div class="line">    if (rawmode) &#123;</div><div class="line">        fprintf(fp,&quot;%s&quot;,msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        int off;</div><div class="line">        struct timeval tv;</div><div class="line">        int role_char;</div><div class="line">        pid_t pid = getpid();</div><div class="line"></div><div class="line">        gettimeofday(&amp;tv,NULL);</div><div class="line">        off = strftime(buf,sizeof(buf),&quot;%d %b %H:%M:%S.&quot;,localtime(&amp;tv.tv_sec));</div><div class="line">        snprintf(buf+off,sizeof(buf)-off,&quot;%03d&quot;,(int)tv.tv_usec/1000);</div><div class="line">        if (server.sentinel_mode) &#123;</div><div class="line">            role_char = &apos;X&apos;; /* Sentinel. */</div><div class="line">        &#125; else if (pid != server.pid) &#123;</div><div class="line">            role_char = &apos;C&apos;; /* RDB / AOF writing child. */</div><div class="line">        &#125; else &#123;</div><div class="line">            role_char = (server.masterhost ? &apos;S&apos;:&apos;M&apos;); /* Slave or Master. */</div><div class="line">        &#125;</div><div class="line">        fprintf(fp,&quot;%d:%c %s %c %s\n&quot;,</div><div class="line">            (int)getpid(),role_char, buf,c[level],msg);</div><div class="line">    &#125;</div><div class="line">    fflush(fp);</div><div class="line"></div><div class="line">    if (!log_to_stdout) fclose(fp);</div><div class="line">    if (server.syslog_enabled) syslog(syslogLevelMap[level], &quot;%s&quot;, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>google开源的日志系统glog写文件操作也采用第一套io函数，在函数LogFileObject::Write</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2017/11/29/network-tcp-machine-state/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/29/network-tcp-machine-state/" itemprop="url">
                  TCP状态机分析（二）CLOSE_WAIT&TIME_WAIT
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-29T01:46:17+08:00">
                2017-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index">
                    <span itemprop="name">network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##CLOSE_WAIT<br>在被动关闭连接(对方关闭)情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。</p>
<p>解决方法:<br>基本的思想就是要检测出对方已经关闭的socket，然后关闭它。</p>
<ol>
<li>代码需要判断socket，一旦read返回0，断开连接，read返回负，检查一下errno，如果不是AGAIN，也断开连接。(注:在UNP 7.5节的图7.6中，可以看到使用select能够检测出对方发送了FIN，再根据这条规则就可以处理CLOSE_WAIT的连接)</li>
<li>给每一个socket设置一个时间戳last_update，每接收或者是发送成功数据，就用当前时间更新这个时间戳。定期检查所有的时间戳，如果时间戳与当前时间差值超过一定的阈值，就关闭这个socket。</li>
<li>使用一个Heart-Beat线程，定期向socket发送指定格式的心跳数据包，如果接收到对方的RST报文，说明对方已经关闭了socket，那么我们也关闭这个socket。</li>
<li>设置SO_KEEPALIVE选项，并修改内核参数,下面会详细介绍<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">a. 参数设置</div><div class="line">查看相关的参数</div><div class="line">sysctl -a|grep tcp_keepalive</div><div class="line">net.ipv4.tcp_keepalive_intvl = 30</div><div class="line">net.ipv4.tcp_keepalive_probes = 2</div><div class="line">net.ipv4.tcp_keepalive_time = 160</div><div class="line"></div><div class="line">参数的含义</div><div class="line">tcp_keepalive_intvl:探测消息发送的频率</div><div class="line">tcp_keepalive_probes:TCP发送keepalive探测以确定该连接已经断开的次数</div><div class="line">tcp_keepalive_time:当keepalive打开的情况下，TCP发送keepalive消息的频率</div><div class="line"></div><div class="line">设置相关的参数</div><div class="line">sysctl -w net.ipv4.tcp_keepalive_time = 7500</div><div class="line">也可以直接打开/etc/sysctl.conf</div><div class="line">加入net.ipv4.tcp_keepalive_time = 7500，然后保存退出</div><div class="line"></div><div class="line">让参数生效</div><div class="line">sysctl -p</div><div class="line"></div><div class="line">b. 开启keepalive属性 </div><div class="line">int keepAlive = 1; </div><div class="line">setsockopt(client_fd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive)); </div><div class="line"></div><div class="line">c. 系统调用设置</div><div class="line">这样只会影响单个连接，上面修改内核参数会影响所有设置keepalive属性的连接</div><div class="line">#include &lt;sys/types.h&gt;  </div><div class="line">#include &lt;sys/socket.h&gt;  </div><div class="line">#include &lt;netinet/tcp.h&gt;  </div><div class="line">  </div><div class="line">int keepAlive = 1;          // 开启keepalive属性  </div><div class="line">int keepIdle = 1800;        // 如该连接在1800秒内没有任何数据往来,则进行探测   </div><div class="line">int keepInterval = 3;       // 探测时发包的时间间隔为3秒  </div><div class="line">int keepCount = 2;          // 探测尝试的次数.如果第1次探测包就收到响应了,则后几次的不再发.  </div><div class="line">setsockopt(client_fd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));  </div><div class="line">setsockopt(client_fd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));  </div><div class="line">setsockopt(client_fd, SOL_TCP,TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));  </div><div class="line">setsockopt(client_fd, SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount));</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这篇文章对于一次生产环境遇到的CLOSE_WAIT问题分析很到位<br>转载：<a href="https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&amp;mid=402163560&amp;idx=1&amp;sn=5269044286ce1d142cca1b5fed3efab1&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&amp;mid=402163560&amp;idx=1&amp;sn=5269044286ce1d142cca1b5fed3efab1&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd</a></p>
<p>##TIME_WAIT<br>主动发起close的一方会出现TIME_WAIT，比如nginx到web server之间，可以对内核参数做优化(/etc/sysctl.conf)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">net.ipv4.tcp_tw_reuse = 1</div><div class="line">net.ipv4.tcp_tw_recycle = 0</div><div class="line">net.ipv4.tcp_fin_timeout = 15</div></pre></td></tr></table></figure>
<p>然后执行 /sbin/sysctl -p 让参数生效。</p>
<p>参数说明</p>
<ul>
<li>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</li>
<li>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</li>
<li>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</li>
<li>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2017/10/30/muduo-chapter01/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/30/muduo-chapter01/" itemprop="url">
                  <<Linux多线程服务端编程-使用muduo c++网络库>>笔记（一）
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-30T04:33:54+08:00">
                2017-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##c++主要内存问题及解决方法<br>1、缓冲区溢出<br>solution：使用vector<char>、string或自己编写的BufferClass来管理缓冲区，记录缓冲区的长度，并通过成员函数而不是裸指针修改缓冲区。</char></p>
<p>2、空悬指针/野指针<br>solution：shared_ptr/weak_ptr</p>
<p>3、重复释放<br>solution：scoped_ptr，只在对象析构时候释放一次</p>
<p>4、内存泄漏<br>solution：scoped_ptr，对象析构时候自动释放内存</p>
<p>5、不配对的new[]/delete<br>solution：把new[]替换为vector/scoped_array</p>
<p>6、内存碎片<br>solution：todo</p>
<p>##shared_ptr是否线程安全<br>shared_ptr计数操作是线程安全的，release 1.33.0后在大多数系统中采用无锁的原子操作实现；但对于对象本身的访问不是线程安全的。对于shared_ptr的线程安全问题，boost官方文档中作了详细说明, <a href="http://www.boost.org/doc/libs/1_65_1/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr" target="_blank" rel="external">http://www.boost.org/doc/libs/1_65_1/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr</a><br>这里作了下总结：</p>
<ol>
<li>多个线程可以同时读一个shared_ptr实例</li>
<li>不同的线程中可以对不同的shared_ptr实例进行“写操作”（包括operator=、reset、析构）</li>
<li>一个shared_ptr实例被不同的线程同时读写是不安全的</li>
</ol>
<p>代码例子：<br>Reading a shared_ptr from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>));</div><div class="line"></div><div class="line"><span class="comment">// thread A</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p); <span class="comment">// reads p</span></div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3(p); <span class="comment">// OK, multiple reads are safe</span></div></pre></td></tr></table></figure></p>
<p>Writing different shared_ptr instances from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// thread A</span></div><div class="line">p.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1912</span>)); <span class="comment">// writes p</span></div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line">p2.reset(); <span class="comment">// OK, writes p2</span></div></pre></td></tr></table></figure></p>
<p>Reading and writing a shared_ptr from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// thread A</span></div><div class="line">p = p3; <span class="comment">// reads p3, writes p</span></div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line">p3.reset(); <span class="comment">// writes p3; undefined, simultaneous read/write</span></div></pre></td></tr></table></figure></p>
<p>Reading and destroying a shared_ptr from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// thread A</span></div><div class="line">p3 = p2; <span class="comment">// reads p2, writes p3</span></div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line"><span class="comment">// p2 goes out of scope: undefined, the destructor is considered a "write access"</span></div></pre></td></tr></table></figure></p>
<p>Writing a shared_ptr from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// thread A</span></div><div class="line">p3.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line">p3.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>)); <span class="comment">// undefined, multiple writes</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2017/10/17/redis-rdb/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/17/redis-rdb/" itemprop="url">
                  redis-rdb
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-17T05:20:47+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Reids是一个内存型数据库，所有的数据都存放在内存中。这种模式的缺点就是一旦服务器关闭后会立刻丢失所有存储的数据，Redis当然要避免这种情况的发生，于是其提供了两种持久化机制：RDB和AOF。它们的功能都是将内存中存放的数据保存到磁盘文件上，等到服务器下次开启时能重载数据，以免数据丢失。今天，我们先来剖析一下RDB持久化机制。</p>
<p>##RDB概述<br>开启一个redis-cli，执行添加数据操作如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; flushdb</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set name chris</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; save</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>我先开启了一个Redis客户端，清空数据，然后依次添加了一个键值对到数据库，最后通过SAVE文件将数据库中的数据保存到rdb文件中，实现数据的持久化，服务器会显示数据已经存放在磁盘文件上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">6228:M 17 Oct 05:15:16.846 * DB saved on disk</div></pre></td></tr></table></figure></p>
<p>保存到磁盘的文件名为dump.rdb，利用od命令就能查看里面的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~/software/redis-3.2.6/src$ od -c dump.rdb </div><div class="line">0000000   R   E   D   I   S   0   0   0   7 372  \t   r   e   d   i   s</div><div class="line">0000020   -   v   e   r 005   3   .   2   .   6 372  \n   r   e   d   i</div><div class="line">0000040   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 302</div><div class="line">0000060   T 364 345   Y 372  \b   u   s   e   d   -   m   e   m 302 350</div><div class="line">0000100   H  \b  \0 376  \0 373 001  \0  \0 004   n   a   m   e 005   c</div><div class="line">0000120   h   r   i   s 376 002 373 001  \0  \0 004   n   a   m   e 005</div><div class="line">0000140   c   h   r   i   s 377 326 354   a   i 227   . 350   %</div><div class="line">0000156</div></pre></td></tr></table></figure></p>
<p><em>RDB文件标识和版本号：REDIS0007
</em>Redis版本：redis-ver 3.2.3<br><em>Redis系统位数（32位或64位）：redis-bits
</em>系统时间：ctime<br><em>内存使用量：used-mem
</em>一组键值对：name-chris</p>
<p>##RDB文件结构<br>| REDIS | db_version | databases | EOF | checksum | </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="He Lei" />
          <p class="site-author-name" itemprop="name">He Lei</p>
          <p class="site-description motion-element" itemprop="description">c/c++/python | redis | recommend algorithm | search engine</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">68</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mcgrady-forever" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wuxubj" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He Lei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
