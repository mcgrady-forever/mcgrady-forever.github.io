<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta property="og:type" content="website">
<meta property="og:title" content="HeLei Blog">
<meta property="og:url" content="http://hlei.io/page/4/index.html">
<meta property="og:site_name" content="HeLei Blog">
<meta property="og:description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HeLei Blog">
<meta name="twitter:description" content="c/c++/python | redis | recommend algorithm | search engine">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hlei.io/page/4/"/>





  <title> HeLei Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HeLei Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">不要因为走得太远，就忘记为什么而出发</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/23/redis-analysis-replicatesource/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/23/redis-analysis-replicatesource/" itemprop="url">
                  Redis源码剖析和注释（二十二）--- Redis 复制(replicate)源码详细解析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T20:08:12+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-复制的介绍"><a href="#1-复制的介绍" class="headerlink" title="1. 复制的介绍"></a>1. 复制的介绍</h2><p>Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="2-复制的实现"><a href="#2-复制的实现" class="headerlink" title="2. 复制的实现"></a>2. 复制的实现</h2><h3 id="2-1-主从关系的建立"><a href="#2-1-主从关系的建立" class="headerlink" title="2.1 主从关系的建立"></a>2.1 主从关系的建立</h3><p>复制的建立方法有三种。</p>
<ol>
<li>在redis.conf文件中配置slaveof <masterip> <masterport>选项，然后指定该配置文件启动Redis生效。</masterport></masterip></li>
<li>在redis-server启动命令后加上–slaveof <masterip> <masterport>启动生效。</masterport></masterip></li>
<li>直接使用 slaveof <masterip> <masterport>命令在从节点执行生效。<br>无论是通过哪一种方式来建立主从复制，都是从节点来执行slaveof命令，那么从节点执行了这个命令到底做了什么，我们上源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// SLAVEOF host port命令实现</div><div class="line">void slaveofCommand(client *c) &#123;</div><div class="line">    // 如果当前处于集群模式，不能进行复制操作</div><div class="line">    if (server.cluster_enabled) &#123;</div><div class="line">        addReplyError(c,&quot;SLAVEOF not allowed in cluster mode.&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // SLAVEOF NO ONE命令使得这个从节点关闭复制功能，并从从节点转变回主节点，原来同步所得的数据集不会被丢弃。</div><div class="line">    if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;no&quot;) &amp;&amp;</div><div class="line">        !strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;one&quot;)) &#123;</div><div class="line">        // 如果保存了主节点IP</div><div class="line">        if (server.masterhost) &#123;</div><div class="line">            // 取消复制操作，设置服务器为主服务器</div><div class="line">            replicationUnsetMaster();</div><div class="line">            // 获取client的每种信息，并以sds形式返回，并打印到日志中</div><div class="line">            sds client = catClientInfoString(sdsempty(),c);</div><div class="line">            serverLog(LL_NOTICE,&quot;MASTER MODE enabled (user request from &apos;%s&apos;)&quot;,</div><div class="line">                client);</div><div class="line">            sdsfree(client);</div><div class="line">        &#125;</div><div class="line">    // SLAVEOF host port</div><div class="line">    &#125; else &#123;</div><div class="line">        long port;</div><div class="line"></div><div class="line">        // 获取端口号</div><div class="line">        if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;port, NULL) != C_OK))</div><div class="line">            return;</div><div class="line"></div><div class="line">        // 如果已存在从属于masterhost主节点且命令参数指定的主节点和masterhost相等，端口也相等，直接返回</div><div class="line">        if (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[1]-&gt;ptr)</div><div class="line">            &amp;&amp; server.masterport == port) &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.&quot;);</div><div class="line">            addReplySds(c,sdsnew(&quot;+OK Already connected to specified master\r\n&quot;));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 第一次执行设置端口和ip，或者是重新设置端口和IP</div><div class="line">        // 设置服务器复制操作的主节点IP和端口</div><div class="line">        replicationSetMaster(c-&gt;argv[1]-&gt;ptr, port);</div><div class="line">        // 获取client的每种信息，并以sds形式返回，并打印到日志中</div><div class="line">        sds client = catClientInfoString(sdsempty(),c);</div><div class="line">        serverLog(LL_NOTICE,&quot;SLAVE OF %s:%d enabled (user request from &apos;%s&apos;)&quot;,</div><div class="line">            server.masterhost, server.masterport, client);</div><div class="line">        sdsfree(client);</div><div class="line">    &#125;</div><div class="line">    // 回复ok</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</masterport></masterip></li>
</ol>
<p>当从节点的client执行SLAVEOF命令后，该命令会被构建成Redis协议格式，发送给从节点服务器，然后节点服务器会调用slaveofCommand()函数执行该命令。</p>
<p>而SLAVEOF命令做的操作并不多，主要以下三步：</p>
<ul>
<li>判断当前环境是否在集群模式下，因为集群模式下不行执行该命令。</li>
<li>是否执行的是SLAVEOF NO ONE命令，该命令会断开主从的关系，设置当前节点为主节点服务器。</li>
<li>设置从节点所属主节点的IP和port。调用了replicationSetMaster()函数。</li>
</ul>
<p>SLAVEOF命令能做的只有这么多，我们来具体看下replicationSetMaster()函数的代码，看看它做了哪些与复制相关的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 设置复制操作的主节点IP和端口</div><div class="line">void replicationSetMaster(char *ip, int port) &#123;</div><div class="line">    // 按需清除原来的主节点信息</div><div class="line">    sdsfree(server.masterhost);</div><div class="line">    // 设置ip和端口</div><div class="line">    server.masterhost = sdsnew(ip);</div><div class="line">    server.masterport = port;</div><div class="line">    // 如果有其他的主节点，在释放</div><div class="line">    // 例如服务器1是服务器2的主节点，现在服务器2要同步服务器3，服务器3要成为服务器2的主节点，因此要释放服务器1</div><div class="line">    if (server.master) freeClient(server.master);</div><div class="line">    // 解除所有客户端的阻塞状态</div><div class="line">    disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */</div><div class="line">    // 关闭所有从节点服务器的连接，强制从节点服务器进行重新同步操作</div><div class="line">    disconnectSlaves(); /* Force our slaves to resync with us as well. */</div><div class="line">    // 释放主节点结构的缓存，不会执行部分重同步PSYNC</div><div class="line">    replicationDiscardCachedMaster(); /* Don&apos;t try a PSYNC. */</div><div class="line">    // 释放复制积压缓冲区</div><div class="line">    freeReplicationBacklog(); /* Don&apos;t allow our chained slaves to PSYNC. */</div><div class="line">    // 取消执行复制操作</div><div class="line">    cancelReplicationHandshake();</div><div class="line">    // 设置复制必须重新连接主节点的状态</div><div class="line">    server.repl_state = REPL_STATE_CONNECT;</div><div class="line">    // 初始化复制的偏移量</div><div class="line">    server.master_repl_offset = 0;</div><div class="line">    // 清零连接断开的时长</div><div class="line">    server.repl_down_since = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由代码知，replicationSetMaster()函数执行操作的也很简单，总结为两步：</p>
<ul>
<li>清理之前所属的主节点的信息。</li>
<li>设置新的主节点IP和port等。<br>因为，当前从节点有可能之前从属于另外的一个主节点服务器，因此要清理所有关于之前主节点的缓存、关闭旧的连接等等。然后设置该从节点的新主节点，设置了IP和port，还设置了以下状态：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 设置复制必须重新连接主节点的状态</div><div class="line">server.repl_state = REPL_STATE_CONNECT;</div><div class="line">// 初始化全局复制的偏移量</div><div class="line">server.master_repl_offset = 0;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后，就没有然后了，然后就会执行复制操作吗？这也没有什么关于复制的操作执行了，那么复制操作是怎么开始的呢？</p>
<h3 id="2-2-主从网络连接建立"><a href="#2-2-主从网络连接建立" class="headerlink" title="2.2 主从网络连接建立"></a>2.2 主从网络连接建立</h3><p>slaveof命令是一个异步命令，执行命令时，从节点保存主节点的信息，确立主从关系后就会立即返回，后续的复制流程在节点内部异步执行。那么，如何触发复制的执行呢？</p>
<p>周期性执行的函数：replicationCron()函数，该函数被服务器的时间事件的回调函数serverCron()所调用，而serverCron()函数在Redis服务器初始化时，被设置为时间事件的处理函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// void initServer(void) Redis服务器初始化</div><div class="line">aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL)</div></pre></td></tr></table></figure></p>
<p>replicationCron()函数执行频率为1秒一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 节选自serverCron函数</div><div class="line">// 周期性执行复制的任务</div><div class="line">run_with_period(1000) replicationCron();</div></pre></td></tr></table></figure></p>
<p>主从关系建立后，从节点服务器的server.repl_state被设置为REPL_STATE_CONNECT，而replicationCron()函数会被每秒执行一次，该函数会发现我（从节点）现在有主节点了，而且我要的状态是要连接主节点（REPL_STATE_CONNECT）。</p>
<p>replicationCron()函数处理这以情况的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* Check if we should connect to a MASTER */</div><div class="line">// 如果处于要必须连接主节点的状态，尝试连接</div><div class="line">if (server.repl_state == REPL_STATE_CONNECT) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Connecting to MASTER %s:%d&quot;,</div><div class="line">        server.masterhost, server.masterport);</div><div class="line">    // 以非阻塞的方式连接主节点</div><div class="line">    if (connectWithMaster() == C_OK) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;MASTER &lt;-&gt; SLAVE sync started&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>replicationCron()函数根据从节点的状态，调用connectWithMaster()非阻塞连接主节点。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 以非阻塞的方式连接主节点</div><div class="line">int connectWithMaster(void) &#123;</div><div class="line">    int fd;</div><div class="line"></div><div class="line">    // 连接主节点</div><div class="line">    fd = anetTcpNonBlockBestEffortBindConnect(NULL,</div><div class="line">        server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);</div><div class="line">    if (fd == -1) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to connect to MASTER: %s&quot;,</div><div class="line">            strerror(errno));</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 监听主节点fd的可读和可写事件的发生，并设置其处理程序为syncWithMaster</div><div class="line">    if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) == AE_ERR)</div><div class="line">    &#123;</div><div class="line">        close(fd);</div><div class="line">        serverLog(LL_WARNING,&quot;Can&apos;t create readable event for SYNC&quot;);</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 最近一次读到RDB文件内容的时间</div><div class="line">    server.repl_transfer_lastio = server.unixtime;</div><div class="line">    // 从节点和主节点的同步套接字</div><div class="line">    server.repl_transfer_s = fd;</div><div class="line">    // 处于和主节点正在连接的状态</div><div class="line">    server.repl_state = REPL_STATE_CONNECTING;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>connectWithMaster()函数执行的操作可以总结为：</p>
<ul>
<li>根据IP和port非阻塞的方式连接主节点，得到主从节点进行通信的文件描述符fd，并保存到从节点服务器server.repl_transfer_s中，并且将刚才的REPL_STATE_CONNECT状态设置为REPL_STATE_CONNECTING。</li>
<li>监听fd的可读和可写事件，并且设置事件发生的处理程序syncWithMaster()函数。<br>至此，主从网络建立就完成了。</li>
</ul>
<h3 id="2-3-发送PING命令"><a href="#2-3-发送PING命令" class="headerlink" title="2.3 发送PING命令"></a>2.3 发送PING命令</h3><p>主从建立网络时，同时注册fd的AE_READABLE|AE_WRITABLE事件，因此会触发一个AE_WRITABLE事件，调用syncWithMaster()函数，处理写事件。</p>
<p>根据当前的REPL_STATE_CONNECTING状态，从节点向主节点发送PING命令，PING命令的目的有：</p>
<ul>
<li>检测主从节点之间的网络是否可用。</li>
<li>检查主从节点当前是否接受处理命令。<br>syncWithMaster()函数中相关操作的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Send a PING to check the master is able to reply without errors. */</div><div class="line">// 如果复制的状态为REPL_STATE_CONNECTING，发送一个PING去检查主节点是否能正确回复一个PONG</div><div class="line">if (server.repl_state == REPL_STATE_CONNECTING) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Non blocking connect for SYNC fired the event.&quot;);</div><div class="line">    // 暂时取消接听fd的写事件，以便等待PONG回复时，注册可读事件</div><div class="line">    aeDeleteFileEvent(server.el,fd,AE_WRITABLE);</div><div class="line">    // 设置复制状态为等待PONG回复</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</div><div class="line">    // 发送一个PING命令</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PING&quot;,NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>发送PING命令主要的操作是：</p>
<ul>
<li>先取消监听fd的写事件，因为接下来要读主节点服务器发送过来的PONG回复，因此只监听可读事件的发生。</li>
<li>设置从节点的复制状态为REPL_STATE_RECEIVE_PONG。等待一个主节点回复一个PONG命令。</li>
<li>以写的方式调用sendSynchronousCommand()函数发送一个PING命令给主节点。<br>主节点服务器从fd会读到一个PING命令，然后会回复一个PONG命令到fd中，执行的命令就是addReply(c,shared.pong);。</li>
</ul>
<p>此时，会触发fd的可读事件，调用syncWithMaster()函数来处理，此时从节点的复制状态为REPL_STATE_RECEIVE_PONG，等待主节点回复PONG。syncWithMaster()函数中处理这一状态的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/* Receive the PONG command. */</div><div class="line">// 如果复制的状态为REPL_STATE_RECEIVE_PONG，等待接受PONG命令</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</div><div class="line">   // 从主节点读一个PONG命令sendSynchronousCommand</div><div class="line">   err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line"></div><div class="line">    // 只接受两种有效的回复。一种是 &quot;+PONG&quot;，一种是认证错误&quot;-NOAUTH&quot;。</div><div class="line">    // 旧版本的返回有&quot;-ERR operation not permitted&quot;</div><div class="line">    if (err[0] != &apos;+&apos; &amp;&amp;</div><div class="line">        strncmp(err,&quot;-NOAUTH&quot;,7) != 0 &amp;&amp;</div><div class="line">        strncmp(err,&quot;-ERR operation not permitted&quot;,28) != 0)</div><div class="line">    &#123;   // 没有收到正确的PING命令的回复</div><div class="line">        serverLog(LL_WARNING,&quot;Error reply to PING from master: &apos;%s&apos;&quot;,err);</div><div class="line">        sdsfree(err);</div><div class="line">        goto error;</div><div class="line">     &#125; else &#123;</div><div class="line">       serverLog(LL_NOTICE,&quot;Master replied to PING, replication can continue...&quot;);</div><div class="line">     &#125;</div><div class="line">     sdsfree(err);</div><div class="line">     // 已经收到PONG，更改状态设置为发送认证命令AUTH给主节点</div><div class="line">     server.repl_state = REPL_STATE_SEND_AUTH;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，以读的方式调用sendSynchronousCommand()，并将读到的”+PONG\r\n”返回到err中，如果从节点正确接收到主节点发送的PONG命令，会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_AUTH。等待进行权限的认证。</p>
<h3 id="2-4-认证权限"><a href="#2-4-认证权限" class="headerlink" title="2.4 认证权限"></a>2.4 认证权限</h3><p>权限认证会在syncWithMaster()函数继续执行，紧接着刚才的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* AUTH with the master if required. */</div><div class="line">// 如果需要，发送AUTH认证给主节点</div><div class="line">if (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</div><div class="line">   // 如果服务器设置了认证密码</div><div class="line">   if (server.masterauth) &#123;</div><div class="line">        // 写AUTH给主节点</div><div class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;AUTH&quot;,server.masterauth,NULL);</div><div class="line">        if (err) goto write_error;</div><div class="line">        // 设置状态为等待接受认证回复</div><div class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</div><div class="line">        return;</div><div class="line">    // 如果没有设置认证密码，直接设置复制状态为发送端口号给主节点</div><div class="line">    &#125; else &#123;</div><div class="line">        server.repl_state = REPL_STATE_SEND_PORT;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果从节点的服务器设置了认证密码，则会以写方式调用sendSynchronousCommand()函数，将AUTH命令和密码写到fd中，并且将从节点的复制状态设置为server.repl_state = REPL_STATE_RECEIVE_AUTH，接受AUTH的验证。</p>
<p>如果从节点服务器没有设置认证密码，就直接将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_PORT，准发发送一个端口号。</p>
<p>主节点会读取到AUTH命令，调用authCommand()函数来处理，主节点服务器会比较从节点发送过来的server.masterauth和主节点服务器保存的server.requirepass是否一致，如果一致，会回复一个”+OK\r\n”。</p>
<p>当主节点将回复写到fd时，又会触发从节点的可读事件，紧接着调用syncWithMaster()函数来处理接收AUTH认证结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Receive AUTH reply. */</div><div class="line">// 接受AUTH认证的回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</div><div class="line">    // 从主节点读回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 回复错误，认证失败</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to AUTH to MASTER: %s&quot;,err);</div><div class="line">        sdsfree(err);</div><div class="line">        goto error;</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送端口号给主节点</div><div class="line">    server.repl_state = REPL_STATE_SEND_PORT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以读方式从fd中读取一个回复，判断认证是否成功，认证成功，则会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_PORT表示要发送一个端口号给主节点。这和没有设置认证的情况结果相同。</p>
<h3 id="2-5-发送端口号"><a href="#2-5-发送端口号" class="headerlink" title="2.5 发送端口号"></a>2.5 发送端口号</h3><p>从节点在认证完权限后，会继续在syncWithMaster()函数执行，处理发送端口号的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Set the slave port, so that Master&apos;s INFO command can list the</div><div class="line"> * slave listening port correctly. */</div><div class="line">// 如果复制状态是，发送从节点端口号给主节点，主节点的INFO命令就能够列出从节点正在监听的端口号</div><div class="line">if (server.repl_state == REPL_STATE_SEND_PORT) &#123;</div><div class="line">    // 获取端口号</div><div class="line">    sds port = sdsfromlonglong(server.slave_announce_port ?</div><div class="line">        server.slave_announce_port : server.port);</div><div class="line">    // 将端口号写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;listening-port&quot;,port, NULL);</div><div class="line">    sdsfree(port);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受端口号</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发送端口号，以REPLCONF listening-port命令的方式，写到fd中。然后将复制状态设置为server.repl_state = REPL_STATE_RECEIVE_PORT，等待接受主节点的回复。</p>
<p>主节点从fd中读到REPLCONF listening-port <port>命令，调用replconfCommand()命令来处理，而replconfCommand()函数的定义就在replication.c文件中，REPLCONF命令可以设置多种不同的选项，解析到端口号后，将端口号保存从节点对应client状态的c-&gt;slave_listening_port = port中。最终回复一个”+OK\r\n”状态的回复，写在fd中。</port></p>
<p>当主节点将回复写到fd时，又会触发从节点的可读事件，紧接着调用syncWithMaster()函数来处理接受端口号，验证主节点是否正确的接收到从节点的端口号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Receive REPLCONF listening-port reply. */</div><div class="line">// 复制状态为接受端口号</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</div><div class="line">    // 从主节点读取端口号</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    /* Ignore the error if any, not all the Redis versions support</div><div class="line">     * REPLCONF listening-port. */</div><div class="line">    // 忽略所有的错误，因为不是所有的Redis版本都支持REPLCONF listening-port命令</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF listening-port: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送IP</div><div class="line">    server.repl_state = REPL_STATE_SEND_IP;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确的接收到从节点的端口号，会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_IP表示要送一个IP给主节点。</p>
<h3 id="2-6-发送-IP-地址"><a href="#2-6-发送-IP-地址" class="headerlink" title="2.6 发送 IP 地址"></a>2.6 发送 IP 地址</h3><p>从节点发送完端口号并且正确收到主节点的回复后，紧接着syncWithMaster()函数执行发送IP的代码。发送IP和发送端口号过程几乎一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送IP</div><div class="line">if (server.repl_state == REPL_STATE_SEND_IP) &#123;</div><div class="line">    // 将IP写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;ip-address&quot;,server.slave_announce_ip, NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受IP</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样是以REPLCONF ip-address命令的方式，将从节点的IP写到fd中。并且设置从节点的复制状态为server.repl_state = REPL_STATE_RECEIVE_IP，等待接受主节点的回复。然后就直接返回，等待fd可读发生。</p>
<p>主节点仍然会调用replication.c文件中实现的replconfCommand()函数来处理REPLCONF命令，解析出REPLCONF ip-address ip命令，保存从节点的ip到主节点的对应从节点的client的c-&gt;slave_ip中。然后回复”+OK\r\n”状态，写到fd中。</p>
<p>此时，从节点监听到fd触发了可读事件，会调用syncWithMaster()函数来处理，验证主节点是否正确接收到从节点的IP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Receive REPLCONF ip-address reply. */</div><div class="line">// 复制状态为接受IP回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</div><div class="line">    // 从主节点读一个IP回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 错误回复</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF ip-address: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送一个capa（能力？能否解析出RDB文件的EOF流格式）</div><div class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确接收了从节点IP，就会设置从节点的复制状态server.repl_state = REPL_STATE_SEND_CAPA表示发送从节点的能力（capability）。</p>
<h3 id="2-7-发送能力（capability）"><a href="#2-7-发送能力（capability）" class="headerlink" title="2.7 发送能力（capability）"></a>2.7 发送能力（capability）</h3><p>发送能力和发送端口和IP也是如出一辙，紧接着syncWithMaster()函数执行发送capa的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送capa，通知主节点从节点的能力</div><div class="line">if (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</div><div class="line">    // 将从节点的capa写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;capa&quot;,&quot;eof&quot;,NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受从节点的capa</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从节点将REPLCONF capa eof命令发送给主节点，写到fd中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">目前只支持一种能力，就是能够解析出RDB文件的EOF流格式。用于无盘复制的方式中。</div></pre></td></tr></table></figure></p>
<p>主节点仍然会调用replication.c文件中实现的replconfCommand()函数来处理REPLCONF命令，解析出REPLCONF capa eof命令，将eof对应的标识，按位与到主节点的对应从节点的client的c-&gt;slave_capa中。然后回复”+OK\r\n”状态，写到fd中。</p>
<p>此时，从节点监听到fd触发了可读事件，会调用syncWithMaster()函数来处理，验证主节点是否正确接收到从节点的capa。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Receive CAPA reply. */</div><div class="line">// 复制状态为接受从节点的capa回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</div><div class="line">    // 从主节点读取capa回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 错误回复</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF capa: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送PSYNC命令</div><div class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确接收了从节点capa，就会设置从节点的复制状态server.repl_state = REPL_STATE_SEND_PSYNC表示发送一个PSYNC命令</p>
<h3 id="2-8-发送PSYNC命令"><a href="#2-8-发送PSYNC命令" class="headerlink" title="2.8 发送PSYNC命令"></a>2.8 发送PSYNC命令</h3><p>从节点发送PSYNC命令给主节点，尝试进行同步主节点的数据集。同步分为两种：</p>
<ul>
<li>全量同步：第一次执行复制的场景。</li>
<li>部分同步：用于主从复制因为网络中断等原因造成数据丢失的场景。<br>因为这是第一次执行同步，因此会进行全量同步。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送PSYNC命令。尝试进行部分重同步。</div><div class="line">// 如果没有缓冲主节点的结构，slaveTryPartialResynchronization()函数将会至少尝试使用PSYNC去进行一个全同步，这样就能得到主节点的运行runid和全局复制偏移量。并且在下次重连接时可以尝试进行部分重同步。</div><div class="line">if (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</div><div class="line">    // 向主节点发送一个部分重同步命令PSYNC，参数0表示不读主节点的回复，只获取主节点的运行runid和全局复制偏移量</div><div class="line">    if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) &#123;</div><div class="line">        // 发送PSYNC出错</div><div class="line">        err = sdsnew(&quot;Write error sending the PSYNC command.&quot;);</div><div class="line">        goto write_error;</div><div class="line">    &#125;</div><div class="line">    // 设置复制状态为等待接受一个PSYNC回复</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从节点调用slaveTryPartialResynchronization()函数尝试进行重同步，注意第二个参数是0。因为slaveTryPartialResynchronization()分成两部分，一部分是写，一部分是读，因为第二个参数是0，因此执行写的一部分，发送一个PSYNC命令给主节点。只列举出写的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* Writing half */</div><div class="line">// 如果read_reply为0，则该函数往socket上会写入一个PSYNC命令</div><div class="line">if (!read_reply) &#123;</div><div class="line">    // 将repl_master_initial_offset设置为-1表示主节点的run_id和全局复制偏移量是无效的。</div><div class="line">    // 如果能使用PSYNC命令执行一个全量同步，会正确设置全复制偏移量，以便这个信息被正确传播主节点的所有从节点中</div><div class="line">    server.repl_master_initial_offset = -1;</div><div class="line"></div><div class="line">    // 主节点的缓存不为空，可以尝试进行部分重同步。PSYNC &lt;master_run_id&gt; &lt;repl_offset&gt;</div><div class="line">    if (server.cached_master) &#123;</div><div class="line">        // 保存缓存runid</div><div class="line">        psync_runid = server.cached_master-&gt;replrunid;</div><div class="line">        // 获取已经复制的偏移量</div><div class="line">        snprintf(psync_offset,sizeof(psync_offset),&quot;%lld&quot;, server.cached_master-&gt;reploff+1);</div><div class="line">        serverLog(LL_NOTICE,&quot;Trying a partial resynchronization (request %s:%s).&quot;, psync_runid, psync_offset);</div><div class="line">    // 主节点的缓存为空，发送PSYNC ? -1。请求全量同步</div><div class="line">    &#125; else &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;Partial resynchronization not possible (no cached master)&quot;);</div><div class="line">        psync_runid = &quot;?&quot;;</div><div class="line">        memcpy(psync_offset,&quot;-1&quot;,3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Issue the PSYNC command */</div><div class="line">    // 发送一个PSYNC命令给主节点</div><div class="line">    reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PSYNC&quot;,psync_runid,psync_offset,NULL);</div><div class="line">    // 写成功失败会返回一个&quot;-&quot;开头的字符串</div><div class="line">    if (reply != NULL) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to send PSYNC to master: %s&quot;,reply);</div><div class="line">        sdsfree(reply);</div><div class="line">        // 删除文件的可读事件，返回写错误PSYNC_WRITE_ERROR</div><div class="line">        aeDeleteFileEvent(server.el,fd,AE_READABLE);</div><div class="line">        return PSYNC_WRITE_ERROR;</div><div class="line">    &#125;</div><div class="line">    // 返回等待回复的标识PSYNC_WAIT_REPLY，调用者会将read_reply设置为1，然后再次调用该函数，执行下面的读部分。</div><div class="line">    return PSYNC_WAIT_REPLY;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于从节点是第一次和主节点进行同步操作，因此从节点缓存的主节点client状态erver.cached_master为空，所以就会发送一个PSYNC ? -1命令给主节点，表示进行一次全量同步。</p>
<p>主节点会接收到PSYNC ? -1命令，然后调用replication.c文件中实现的syncCommand()函数处理PSYNC命令。</p>
<p>syncCommand()函数先会判断执行的是PSYNC还是SYNC命令，如果是PSYNC命令会调用masterTryPartialResynchronization()命令执行部分同步，但是由于这是第一次执行复制操作，所以会执行失败。进而执行全量同步。</p>
<p>syncCommand()函数的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">/* SYNC and PSYNC command implemenation. */</div><div class="line">// SYNC and PSYNC 命令实现</div><div class="line">void syncCommand(client *c) &#123;</div><div class="line">    ..........//为了简洁，删除一些判断条件的代码</div><div class="line"></div><div class="line">    // 尝试执行一个部分同步PSYNC的命令，则masterTryPartialResynchronization()会回复一个 &quot;+FULLRESYNC &lt;runid&gt; &lt;offset&gt;&quot;,如果失败则执行全量同步</div><div class="line">    // 所以，从节点会如果和主节点连接断开，从节点会知道runid和offset，随后会尝试执行PSYNC</div><div class="line">    // 如果是执行PSYNC命令</div><div class="line">    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;psync&quot;)) &#123;</div><div class="line">        // 主节点尝试执行部分重同步，执行成功返回C_OK</div><div class="line">        if (masterTryPartialResynchronization(c) == C_OK) &#123;</div><div class="line">            // 可以执行PSYNC命令，则将接受PSYNC命令的个数加1</div><div class="line">            server.stat_sync_partial_ok++;</div><div class="line">            // 不需要执行后面的全量同步，直接返回</div><div class="line">            return; /* No full resync needed, return. */</div><div class="line">        // 不能执行PSYNC部分重同步，需要进行全量同步</div><div class="line">        &#125; else &#123;</div><div class="line">            char *master_runid = c-&gt;argv[1]-&gt;ptr;</div><div class="line">            // 从节点以强制全量同步为目的，所以不能执行部分重同步，因此增加PSYNC命令失败的次数</div><div class="line">            if (master_runid[0] != &apos;?&apos;) server.stat_sync_partial_err++;</div><div class="line">        &#125;</div><div class="line">    // 执行SYNC命令</div><div class="line">    &#125; else &#123;</div><div class="line">        // 设置标识，执行SYNC命令，不接受REPLCONF ACK</div><div class="line">        c-&gt;flags |= CLIENT_PRE_PSYNC;</div><div class="line">    &#125;</div><div class="line">    // 全量重同步次数加1</div><div class="line">    server.stat_sync_full++;</div><div class="line"></div><div class="line">    // 设置client状态为：从服务器节点等待BGSAVE节点的开始</div><div class="line">    c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</div><div class="line">    // 执行SYNC命令后是否关闭TCP_NODELAY</div><div class="line">    if (server.repl_disable_tcp_nodelay)</div><div class="line">        // 是的话，则启用nagle算法</div><div class="line">        anetDisableTcpNoDelay(NULL, c-&gt;fd); /* Non critical if it fails. */</div><div class="line">    // 保存主服务器传来的RDB文件的fd，设置为-1</div><div class="line">    c-&gt;repldbfd = -1;</div><div class="line">    // 设置client状态为从节点，标识client是一个从服务器</div><div class="line">    c-&gt;flags |= CLIENT_SLAVE;</div><div class="line">    // 添加到服务器从节点链表中</div><div class="line">    listAddNodeTail(server.slaves,c);</div><div class="line"></div><div class="line">    /* CASE 1: BGSAVE is in progress, with disk target. */</div><div class="line">    // 情况1. 正在执行 BGSAVE ，且是同步到磁盘上</div><div class="line">    if (server.rdb_child_pid != -1 &amp;&amp;</div><div class="line">        server.rdb_child_type == RDB_CHILD_TYPE_DISK)</div><div class="line">    &#123;</div><div class="line">        client *slave;</div><div class="line">        listNode *ln;</div><div class="line">        listIter li;</div><div class="line"></div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            slave = ln-&gt;value;</div><div class="line">            // 如果有从节点已经创建子进程执行写RDB操作，等待完成，那么退出循环</div><div class="line">            // 从节点的状态为 SLAVE_STATE_WAIT_BGSAVE_END 在情况三中被设置</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) break;</div><div class="line">        &#125;</div><div class="line">        // 对于这个从节点，我们检查它是否具有触发当前BGSAVE操作的能力</div><div class="line">        if (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</div><div class="line">            // 将slave的输出缓冲区所有内容拷贝给c的所有输出缓冲区中</div><div class="line">            copyClientOutputBuffer(c,slave);</div><div class="line">            // 设置全量重同步从节点的状态，设置部分重同步的偏移量</div><div class="line">            replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</div><div class="line">            serverLog(LL_NOTICE,&quot;Waiting for end of BGSAVE for SYNC&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Can&apos;t attach the slave to the current BGSAVE. Waiting for next BGSAVE for SYNC&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    /* CASE 2: BGSAVE is in progress, with socket target. */</div><div class="line">    // 情况2. 正在执行BGSAVE，且是无盘同步，直接写到socket中</div><div class="line">    &#125; else if (server.rdb_child_pid != -1 &amp;&amp;</div><div class="line">               server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</div><div class="line">    &#123;</div><div class="line">        // 虽然有子进程在执行写RDB，但是它直接写到socket中，所以等待下次执行BGSAVE</div><div class="line">        serverLog(LL_NOTICE,&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;);</div><div class="line"></div><div class="line">    /* CASE 3: There is no BGSAVE is progress. */</div><div class="line">    // 情况3：没有执行BGSAVE的进程</div><div class="line">    &#125; else &#123;</div><div class="line">        // 服务器支持无盘同步</div><div class="line">        if (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</div><div class="line">            // 无盘同步复制的子进程被创建在replicationCron()中，因为想等待更多的从节点可以到来而延迟</div><div class="line">            if (server.repl_diskless_sync_delay)</div><div class="line">                serverLog(LL_NOTICE,&quot;Delay next BGSAVE for diskless SYNC&quot;);</div><div class="line">        // 服务器不支持无盘复制</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果没有正在执行BGSAVE，且没有进行写AOF文件，则开始为复制执行BGSAVE，并且是将RDB文件写到磁盘上</div><div class="line">            if (server.aof_child_pid == -1) &#123;</div><div class="line">                startBgsaveForReplication(c-&gt;slave_capa);</div><div class="line">            &#125; else &#123;</div><div class="line">                serverLog(LL_NOTICE,</div><div class="line">                    &quot;No BGSAVE in progress, but an AOF rewrite is active. BGSAVE for replication delayed&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 只有一个从节点，且backlog为空，则创建一个新的backlog</div><div class="line">    if (listLength(server.slaves) == 1 &amp;&amp; server.repl_backlog == NULL)</div><div class="line">        createReplicationBacklog();</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先先明确，主节点执行处理从节点发来PSYNC命令的操作。所以主节点会将从节点视为自己的从节点客户端来操作。会将从节点的复制设置为SLAVE_STATE_WAIT_BGSAVE_START状态表示</p>
<p>主节点执行全量同步的情况有三种：</p>
<ul>
<li>主节点服务器正在执行BGSAVE命令，且将RDB文件写到磁盘上。<br>这种情况，如果有已经设置过全局重同步偏移量的从节点，可以共用输出缓冲区的数据。</li>
<li>主节点服务器正在执行BGSAVE命令，且将RDB文件写到网络socket上，无盘同步。<br>由于本次BGSAVE命令直接将RDB写到socket中，因此只能等待下一BGSAVE。</li>
<li>主节点服务器没有正在执行BGSAVE。<br>如果也没有进行AOF持久化的操作，那么开始为复制操作执行BGSAVE，生成一个写到磁盘上的RDB文件。<br>我们针对第三种情况来分析。调用了startBgsaveForReplication()来开始执行BGSAVE命令。我们贴出主要的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 开始为复制执行BGSAVE，根据配置选择磁盘或套接字作为RDB发送的目标，在开始之前确保冲洗脚本缓存</div><div class="line">// mincapa参数是SLAVE_CAPA_*按位与的结果</div><div class="line">int startBgsaveForReplication(int mincapa) &#123;</div><div class="line">    int retval;</div><div class="line">    // 是否直接写到socket</div><div class="line">    int socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line"></div><div class="line">    if (socket_target)</div><div class="line">        // 直接写到socket中</div><div class="line">        // fork一个子进程将rdb写到 状态为等待BGSAVE开始 的从节点的socket中</div><div class="line">        retval = rdbSaveToSlavesSockets();</div><div class="line">    else</div><div class="line">        // 否则后台进行RDB持久化BGSAVE操作，保存到磁盘上</div><div class="line">        retval = rdbSaveBackground(server.rdb_filename);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    // 如果是直接写到socket中，rdbSaveToSlavesSockets()已经会设置从节点为全量复制</div><div class="line">    // 否则直接写到磁盘上，执行以下代码</div><div class="line">    if (!socket_target) &#123;</div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = ln-&gt;value;</div><div class="line">            // 设置等待全量同步的从节点的状态</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</div><div class="line">                    // 设置要执行全量重同步从节点的状态</div><div class="line">                    replicationSetupSlaveForFullResync(slave,</div><div class="line">                            getPsyncInitialOffset());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>replicationSetupSlaveForFullResync()函数源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int replicationSetupSlaveForFullResync(client *slave, long long offset) &#123;</div><div class="line">    char buf[128];</div><div class="line">    int buflen;</div><div class="line"></div><div class="line">    // 设置全量重同步的偏移量</div><div class="line">    slave-&gt;psync_initial_offset = offset;</div><div class="line">    // 设置从节点复制状态，开始累计差异数据</div><div class="line">    slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END;</div><div class="line">    // 将slaveseldb设置为-1，是为了强制发送一个select命令在复制流中</div><div class="line">    server.slaveseldb = -1;</div><div class="line"></div><div class="line">    // 如果从节点的状态是CLIENT_PRE_PSYNC，则表示是Redis是2.8之前的版本，则不将这些信息发送给从节点。</div><div class="line">    // 因为在2.8之前只支持SYNC的全量复制同步，而在之后的版本提供了部分的重同步</div><div class="line">    if (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;</div><div class="line">        buflen = snprintf(buf,sizeof(buf),&quot;+FULLRESYNC %s %lld\r\n&quot;,</div><div class="line">                          server.runid,offset);</div><div class="line">        // 否则会将全量复制的信息写给从节点</div><div class="line">        if (write(slave-&gt;fd,buf,buflen) != buflen) &#123;</div><div class="line">            freeClientAsync(slave);</div><div class="line">            return C_ERR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>哇，主节点终于回复从节点的PSYNC命令了，回复了一个+FULLRESYNC，写到主从同步的fd。表示要进行全量同步啊！！！</p>
<p>此时，从节点的复制状态一定为REPL_STATE_RECEIVE_PSYNC，fd的读事件发生，调用syncWithMaster()函数进行处理。</p>
<p>处理这种情况的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 那么尝试进行第二次部分重同步，从主节点读取指令来决定执行部分重同步还是全量同步</div><div class="line">psync_result = slaveTryPartialResynchronization(fd,1);</div></pre></td></tr></table></figure></p>
<p>这次的第二个参数是1，因此会执行该函数的读部分。(因为这个函数有两个部分，上一次执行了写部分，因为第二个参数是0)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/* Reading half */</div><div class="line">// 从主节点读一个命令保存在reply中</div><div class="line">reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">if (sdslen(reply) == 0) &#123;</div><div class="line">    // 主节点为了保持连接的状态，可能会在接收到PSYNC命令后发送一个空行</div><div class="line">    sdsfree(reply);</div><div class="line">    // 所以就返回PSYNC_WAIT_REPLY，调用者会将read_reply设置为1，然后再次调用该函数。</div><div class="line">    return PSYNC_WAIT_REPLY;</div><div class="line">&#125;</div><div class="line">// 如果读到了一个命令，删除fd的可读事件</div><div class="line">aeDeleteFileEvent(server.el,fd,AE_READABLE);</div><div class="line"></div><div class="line">// 接受到的是&quot;+FULLRESYNC&quot;，表示进行一次全量同步</div><div class="line">if (!strncmp(reply,&quot;+FULLRESYNC&quot;,11)) &#123;</div><div class="line">    char *runid = NULL, *offset = NULL;</div><div class="line">    // 解析回复中的内容，将runid和复制偏移量提取出来</div><div class="line">    runid = strchr(reply,&apos; &apos;);</div><div class="line">    if (runid) &#123;</div><div class="line">        runid++;    //定位到runid的地址</div><div class="line">        offset = strchr(runid,&apos; &apos;);</div><div class="line">        if (offset) offset++;   //定位offset</div><div class="line">    &#125;</div><div class="line">    // 如果runid和offset任意为空，那么发生不期望错误</div><div class="line">    if (!runid || !offset || (offset-runid-1) != CONFIG_RUN_ID_SIZE) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Master replied with wrong +FULLRESYNC syntax.&quot;);</div><div class="line">        // 将主节点的运行ID重置为0</div><div class="line">        memset(server.repl_master_runid,0,CONFIG_RUN_ID_SIZE+1);</div><div class="line">    // runid和offset获取成功</div><div class="line">    &#125; else &#123;</div><div class="line">        // 设置服务器保存的主节点的运行ID</div><div class="line">        memcpy(server.repl_master_runid, runid, offset-runid-1);</div><div class="line">        server.repl_master_runid[CONFIG_RUN_ID_SIZE] = &apos;\0&apos;;</div><div class="line">        // 主节点的偏移量</div><div class="line">        server.repl_master_initial_offset = strtoll(offset,NULL,10);</div><div class="line">        serverLog(LL_NOTICE,&quot;Full resync from master: %s:%lld&quot;,server.repl_master_runid,          server.repl_master_initial_offset);</div><div class="line">    &#125;</div><div class="line">    // 执行全量同步，所以缓存的主节点结构没用了，将其清空</div><div class="line">    replicationDiscardCachedMaster();</div><div class="line">    sdsfree(reply);</div><div class="line">    // 返回执行的状态</div><div class="line">    return PSYNC_FULLRESYNC;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接受到的是&quot;+CONTINUE&quot;，表示进行一次部分重同步</div><div class="line">if (!strncmp(reply,&quot;+CONTINUE&quot;,9)) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Successful partial resynchronization with master.&quot;);</div><div class="line">    sdsfree(reply);</div><div class="line">    // 因为执行部分重同步，因此要使用缓存的主节点结构，所以将其设置为当前的主节点，被同步的主节点</div><div class="line">    replicationResurrectCachedMaster(fd);</div><div class="line">    // 返回执行的状态</div><div class="line">    return PSYNC_CONTINUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收到了错误，两种情况。</div><div class="line">// 1. 主节点不支持PSYNC命令，Redis版本低于2.8</div><div class="line">// 2. 从主节点读取了一个不期望的回复</div><div class="line">if (strncmp(reply,&quot;-ERR&quot;,4)) &#123;</div><div class="line">    /* If it&apos;s not an error, log the unexpected event. */</div><div class="line">    serverLog(LL_WARNING,&quot;Unexpected reply to PSYNC from master: %s&quot;, reply);</div><div class="line">&#125; else &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Master does not support PSYNC or is in error state (reply: %s)&quot;, reply);</div><div class="line">&#125;</div><div class="line">sdsfree(reply);</div><div class="line">replicationDiscardCachedMaster();</div><div class="line">// 发送不支持PSYNC命令的状态</div><div class="line">return PSYNC_NOT_SUPPORTED;</div></pre></td></tr></table></figure></p>
<p>至此，从节点监听主节点的读命令事件已经完成，所以取消监听了读事件。等到主节点开始传送数据给从节点时，从节点会新创建读事件。</p>
<p>该函数可以解析出主节点发过来的命令是哪一个，一共有三种：</p>
<ul>
<li>“+FULLRESYNC”：代表要进行一次全量复制。</li>
<li>“+CONTINUE”：代表要进行一次部分重同步。</li>
<li>“-ERR”：发生了错误。有两种可能：Redis版本过低不支持PSYNC命令和从节点读到一个错误回复。<br>我们关注第一个全量同步的操作。如果读到了主节点发来的”+FULLRESYNC”，那么会将同时发来的主节点运行ID和全局的复制偏移量保存到从节点的服务器属性中server.repl_master_runid和server.repl_master_initial_offset。然后返回PSYNC_FULLRESYNC。</li>
</ul>
<p>回到syncWithMaster函数，继续处理全量同步。由于要进行全量同步，如果当前从节点还作为其他节点的主节点，因此要断开所有从节点的连接，让他们也重新同步当前节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 执行到这里，psync_result == PSYNC_FULLRESYNC或PSYNC_NOT_SUPPORTED</div><div class="line">    // 准备一个合适临时文件用来写入和保存主节点传来的RDB文件数据</div><div class="line">    while(maxtries--) &#123;</div><div class="line">        // 设置文件的名字</div><div class="line">        snprintf(tmpfile,256,</div><div class="line">            &quot;temp-%d.%ld.rdb&quot;,(int)server.unixtime,(long int)getpid());</div><div class="line">        // 以读写，可执行权限打开临时文件</div><div class="line">        dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);</div><div class="line">        // 打开成功，跳出循环</div><div class="line">        if (dfd != -1) break;</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">    /* Setup the non blocking download of the bulk file. */</div><div class="line">    // 监听一个fd的读事件，并设置该事件的处理程序为readSyncBulkPayload</div><div class="line">    if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL)</div><div class="line">            == AE_ERR)</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_WARNING,</div><div class="line">            &quot;Can&apos;t create readable event for SYNC: %s (fd=%d)&quot;,</div><div class="line">            strerror(errno),fd);</div><div class="line">        goto error;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 复制状态为正从主节点接受RDB文件</div><div class="line">    server.repl_state = REPL_STATE_TRANSFER;</div><div class="line">    // 初始化RDB文件的大小</div><div class="line">    server.repl_transfer_size = -1;</div><div class="line">    // 已读的大小</div><div class="line">    server.repl_transfer_read = 0;</div><div class="line">    // 最近一个执行fsync的偏移量为0</div><div class="line">    server.repl_transfer_last_fsync_off = 0;</div><div class="line">    // 传输RDB文件的临时fd</div><div class="line">    server.repl_transfer_fd = dfd;</div><div class="line">    // 最近一次读到RDB文件内容的时间</div><div class="line">    server.repl_transfer_lastio = server.unixtime;</div><div class="line">    // 保存RDB文件的临时文件名</div><div class="line">    server.repl_transfer_tmpfile = zstrdup(tmpfile);</div><div class="line">    return;</div></pre></td></tr></table></figure></p>
<p> 准备好了所有，接下来就要等待主节点来发送RDB文件了。因此上面做了这三件事：</p>
<ul>
<li>打开一个临时文件，用来保存主节点发来的RDB文件数据的。</li>
<li>监听fd的读事件，等待主节点发送RDB文件数据，触发可读事件执行readSyncBulkPayload()函数，该函数就会把主节点发来的数据读到一个缓冲区中，然后将缓冲区的数据写到刚才打开的临时文件中，接着要载入到从节点的数据库中，最后同步到磁盘中。</li>
<li>设置复制操作的状态为server.repl_state = REPL_STATE_TRANSFER。并且初始化复制的信息，例如：RDB文件的大小，偏移量，等等。（具体看上面的代码）<br>主节点要发送RDB文件，但是回复完”+FULLRESYNC”就再也没有操作了。而子节点创建了监听主节点写RDB文件的事件，等待主节点来写，才调用readSyncBulkPayload()函数来处理。这又有问题了，到底主节点什么时候发送RDB文件呢？如果不是主动执行，那么一定就在周期性函数内被执行。</li>
</ul>
<p>它的调用关系如下：</p>
<p>serverCron()-&gt;backgroundSaveDoneHandler()-&gt;backgroundSaveDoneHandlerDisk()-&gt;updateSlavesWaitingBgsave()</p>
<p>updateSlavesWaitingBgsave()函数定义在replication.c中，主要操作有两步，我们简单介绍：</p>
<ul>
<li>只读打开主节点的临时RDB文件，然后设置从节点client复制状态为SLAVE_STATE_SEND_BULK。</li>
<li>立刻创建监听可写的事件，并设置sendBulkToSlave()函数为可写事件的处理程序。<br>当主节点执行周期性函数时，主节点会先清除之前监听的可写事件，然后立即监听新的可写事件，这样就会触发可写的事件，调用sendBulkToSlave()函数将RDB文件写入到fd中，触发从节点的读事件，从节点调用readSyncBulkPayload()函数，来将RDB文件的数据载入数据库中，至此，就保证了主从同步了。</li>
</ul>
<p>我们来简单介绍sendBulkToSlave()函数在写RDB文件时做了什么：</p>
<ul>
<li>将RDB文件的大小写给从节点，以协议格式的字符串表示的大小。</li>
<li>从RDB文件的repldbfd中读出RDB文件数据，然后写到主从同步的fd中。</li>
<li>写入完成后，又一次取消监听文件可写事件，等待下一次发送缓冲区数据时在监听触发，并且调用putSlaveOnline()函数将从节点client的复制状态设置为SLAVE_STATE_ONLINE。表示已经发送RDB文件完毕，发送缓存更新。</li>
</ul>
<h3 id="2-9-发送输出缓冲区数据"><a href="#2-9-发送输出缓冲区数据" class="headerlink" title="2.9 发送输出缓冲区数据"></a>2.9 发送输出缓冲区数据</h3><p>主节点发送完RDB文件后，调用putSlaveOnline()函数将从节点client的复制状态设置为SLAVE_STATE_ONLINE，表示已经发送RDB文件完毕，要发送缓存更新了。于是会新创建一个事件，监听写事件的发生，设置sendReplyToClient为可写的处理程序，而且会将从节点client当做私有数据闯入sendReplyToClient()当做发送缓冲区的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE,sendReplyToClient, slave)</div></pre></td></tr></table></figure></p>
<p>创建可写事件的时候，就会触发第一次可写，执行sendReplyToClient()，该函数还直接调用了riteToClient(fd,privdata,1)函数，于是将从节点client输出缓冲区的数据发送给了从节点服务器。</p>
<p>riteToClient()函数数据Redis网络连接库的函数，定义在network.c中，具体分析请看：Redis 网络连接库源码分析</p>
<p>这样就保证主从服务器的数据库状态一致了。</p>
<h3 id="2-10-命令传播"><a href="#2-10-命令传播" class="headerlink" title="2.10 命令传播"></a>2.10 命令传播</h3><p>主从节点在第一次全量同步之后就达到了一致，但是之后主节点如果执行了写命令，主节点的数据库状态就又可能发生变化，导致主从再次不一致。为了让主从节点回到一致状态，主机的执行命令后都需要将命令传播到从节点。</p>
<p>传播时会调用server.c中的propagate()函数，如果传播到从节点会调用replicationFeedSlaves(server.slaves,dbid,argv,argc)函数，该函数则会将执行的命令以协议的传输格式写到从节点client的输出缓冲区中，这就是为什么主节点会将从节点client的输出缓冲区发送到从节点（具体见标题2.9），也会添加到server.repl_backlog中。</p>
<p>我们来看看replicationFeedSlaves()函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">// 将参数列表中的参数发送给从服务器</div><div class="line">void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) &#123;</div><div class="line">    listNode *ln;</div><div class="line">    listIter li;</div><div class="line">    int j, len;</div><div class="line">    char llstr[LONG_STR_SIZE];</div><div class="line"></div><div class="line">    // 如果没有backlog且没有从节点服务器，直接返回</div><div class="line">    if (server.repl_backlog == NULL &amp;&amp; listLength(slaves) == 0) return;</div><div class="line"></div><div class="line">    /* We can&apos;t have slaves attached and no backlog. */</div><div class="line">    serverAssert(!(listLength(slaves) != 0 &amp;&amp; server.repl_backlog == NULL));</div><div class="line"></div><div class="line">    // 如果当前从节点使用的数据库不是目标的数据库，则要生成一个select命令</div><div class="line">    if (server.slaveseldb != dictid) &#123;</div><div class="line">        robj *selectcmd;</div><div class="line"></div><div class="line">        // 0 &lt;= id &lt; 10 ，可以使用共享的select命令对象</div><div class="line">        if (dictid &gt;= 0 &amp;&amp; dictid &lt; PROTO_SHARED_SELECT_CMDS) &#123;</div><div class="line">            selectcmd = shared.select[dictid];</div><div class="line">        // 否则自行按照协议格式构建select命令对象</div><div class="line">        &#125; else &#123;</div><div class="line">            int dictid_len;</div><div class="line"></div><div class="line">            dictid_len = ll2string(llstr,sizeof(llstr),dictid);</div><div class="line">            selectcmd = createObject(OBJ_STRING,</div><div class="line">                sdscatprintf(sdsempty(),</div><div class="line">                &quot;*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n&quot;,</div><div class="line">                dictid_len, llstr));</div><div class="line">        &#125;</div><div class="line">        // 将select 命令添加到backlog中</div><div class="line">        if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);</div><div class="line"></div><div class="line">        // 发送给从服务器</div><div class="line">        listRewind(slaves,&amp;li);</div><div class="line">        // 遍历所有的从服务器节点</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = ln-&gt;value;</div><div class="line">            // 从节点服务器状态为等待BGSAVE的开始，因此跳过回复，遍历下一个节点</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;</div><div class="line">            // 添加select命令到当前从节点的回复中</div><div class="line">            addReply(slave,selectcmd);</div><div class="line">        &#125;</div><div class="line">        // 释放临时对象</div><div class="line">        if (dictid &lt; 0 || dictid &gt;= PROTO_SHARED_SELECT_CMDS)</div><div class="line">            decrRefCount(selectcmd);</div><div class="line">    &#125;</div><div class="line">    // 设置当前从节点使用的数据库ID</div><div class="line">    server.slaveseldb = dictid;</div><div class="line"></div><div class="line">    // 将命令写到backlog中</div><div class="line">    if (server.repl_backlog) &#123;</div><div class="line">        char aux[LONG_STR_SIZE+3];</div><div class="line"></div><div class="line">        // 将参数个数构建成协议标准的字符串</div><div class="line">        // *&lt;argc&gt;\r\n</div><div class="line">        aux[0] = &apos;*&apos;;</div><div class="line">        len = ll2string(aux+1,sizeof(aux)-1,argc);</div><div class="line">        aux[len+1] = &apos;\r&apos;;</div><div class="line">        aux[len+2] = &apos;\n&apos;;</div><div class="line">        // 添加到backlog中</div><div class="line">        feedReplicationBacklog(aux,len+3);</div><div class="line"></div><div class="line">        // 遍历所有的参数</div><div class="line">        for (j = 0; j &lt; argc; j++) &#123;</div><div class="line">            // 返回参数对象的长度</div><div class="line">            long objlen = stringObjectLen(argv[j]);</div><div class="line"></div><div class="line">            // 构建成协议标准的字符串，并添加到backlog中</div><div class="line">            // $&lt;len&gt;\r\n&lt;argv&gt;\r\n</div><div class="line">            aux[0] = &apos;$&apos;;</div><div class="line">            len = ll2string(aux+1,sizeof(aux)-1,objlen);</div><div class="line">            aux[len+1] = &apos;\r&apos;;</div><div class="line">            aux[len+2] = &apos;\n&apos;;</div><div class="line">            // 添加$&lt;len&gt;\r\n</div><div class="line">            feedReplicationBacklog(aux,len+3);</div><div class="line">            // 添加参数对象&lt;argv&gt;</div><div class="line">            feedReplicationBacklogWithObject(argv[j]);</div><div class="line">            // 添加\r\n</div><div class="line">            feedReplicationBacklog(aux+len+1,2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 将命令写到每一个从节点中</div><div class="line">    listRewind(server.slaves,&amp;li);</div><div class="line">    // 遍历从节点链表</div><div class="line">    while((ln = listNext(&amp;li))) &#123;</div><div class="line">        client *slave = ln-&gt;value;</div><div class="line"></div><div class="line">        // 从节点服务器状态为等待BGSAVE的开始，因此跳过回复，遍历下一个节点</div><div class="line">        if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;</div><div class="line"></div><div class="line">        // 将命令写给正在等待初次SYNC的从节点（所以这些命令在输出缓冲区中排队，直到初始SYNC完成），或已经与主节点同步</div><div class="line">        /* Add the multi bulk length. */</div><div class="line">        // 添加回复的长度</div><div class="line">        addReplyMultiBulkLen(slave,argc);</div><div class="line"></div><div class="line">        // 将所有的参数列表添加到从节点的输出缓冲区</div><div class="line">        for (j = 0; j &lt; argc; j++)</div><div class="line">            addReplyBulk(slave,argv[j]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和AOF持久化一样，再给从节点client写命令时，会将SELECT命令强制写入，以保证命令正确读到数据库中。</p>
<p>不仅写入了从节点client的输出缓冲区，而且还会将命令记录到主节点服务器的复制积压缓冲区server.repl_backlog中，这是为了网络闪断后进行部分重同步。</p>
<h2 id="3-部分重同步实现"><a href="#3-部分重同步实现" class="headerlink" title="3. 部分重同步实现"></a>3. 部分重同步实现</h2><p>刚才剖析完全量同步，但是没有考虑特殊的情况。如果在传输RDB文件的过程中，网络发生故障，主节点和从节点的连接中断，Redis会咋么做呢？</p>
<p>Redis 2.8 版本之前会在进行一次连接然后进行全量复制，但是这样效率非常地下，之后的版本都提供了部分重同步的实现。那么我们就分析一下部分重同步的实现过程。</p>
<p>部分重同步在复制的过程中，相当于标题2.8的发送PSYNC命令的部分，其他所有的部分都要进行，他只是主节点回复从节点的命令不同，回复+CONTINUE则执行部分重同步，回复+FULLRESYNC则执行全量同步。</p>
<h3 id="3-1-心跳机制"><a href="#3-1-心跳机制" class="headerlink" title="3.1 心跳机制"></a>3.1 心跳机制</h3><p>主节点是如何发现和从节点连接中断？在主从节点建立连接后，他们之间都维护者长连接并彼此发送心跳命令。主从节点彼此都有心跳机制，各自模拟成对方的客户端进行通信。</p>
<ul>
<li>主节点默认每隔10秒发送PING命令，判断从节点的连接状态。 </li>
<li><p>文件配置项：repl-ping-salve-period，默认是10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 首先，根据当前节点发送PING命令给从节点的频率发送PING命令 </div><div class="line">// 如果当前节点是某以节点的 主节点 ，那么发送PING给从节点</div><div class="line">if ((replication_cron_loops % server.repl_ping_slave_period) == 0) &#123;</div><div class="line">    // 创建PING命令对象</div><div class="line">    ping_argv[0] = createStringObject(&quot;PING&quot;,4);</div><div class="line">    // 将PING发送给从服务器</div><div class="line">    replicationFeedSlaves(server.slaves, server.slaveseldb, ping_argv, 1);</div><div class="line">    decrRefCount(ping_argv[0]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从节点在主线程中每隔1秒发送REPLCONF ACK <offset>命令，给主节点报告自己当前复制偏移量。</offset></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 定期发送ack给主节点，旧版本的Redis除外</div><div class="line">if (server.masterhost &amp;&amp; server.master &amp;&amp; !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</div><div class="line">    // 发送一个REPLCONF ACK命令给主节点去报告关于当前处理的offset。</div><div class="line">    replicationSendAck();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在周期性函数replicationCron()，每次都要检查和主节点处于连接状态的从节点和主节点的交互时间是否超时，如果超时则会调用cancelReplicationHandshake()函数，取消和主节点的连接。等到下一个周期在和主节点重新建立连接，进行复制。</p>
<h3 id="3-2-复制积压缓冲区-backlog"><a href="#3-2-复制积压缓冲区-backlog" class="headerlink" title="3.2 复制积压缓冲区(backlog)"></a>3.2 复制积压缓冲区(backlog)</h3><p>复制积压缓冲区是一个大小为1M的循环队列。主节点在命令传播时，不仅会将命令发送给所有的从节点，还会将命令写入复制积压缓冲区中（具体请看标题2.10）。</p>
<p>也就是说，复制积压缓冲区最多可以备份1M大小的数据，如果主从节点断线时间过长，复制积压缓冲区的数据会被新数据覆盖，那么当从主从中断连接起，主节点接收到的数据超过1M大小，那么从节点就无法进行部分重同步，只能进行全量复制。</p>
<p>在标题2.8，介绍的syncCommand()命令中，调用masterTryPartialResynchronization()函数会进行尝试部分重同步，在我们之前分析的第一次全量同步时，该函数会执行失败，然后返回syncCommand()函数执行全量同步，而在进行恢复主从连接后，则会进行部分重同步，masterTryPartialResynchronization()函数代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">// 该函数从主节点接收到部分重新同步请求的角度处理PSYNC命令</div><div class="line">// 成功返回C_OK，否则返回C_ERR</div><div class="line">int masterTryPartialResynchronization(client *c) &#123;</div><div class="line">    long long psync_offset, psync_len;</div><div class="line">    char *master_runid = c-&gt;argv[1]-&gt;ptr;   //主节点的运行ID</div><div class="line">    char buf[128];</div><div class="line">    int buflen;</div><div class="line"></div><div class="line">    // 主节点的运行ID是否和从节点执行PSYNC的参数提供的运行ID相同。</div><div class="line">    // 如果运行ID发生了改变，则主节点是一个不同的实例，那么就不能进行继续执行原有的复制进程</div><div class="line">    if (strcasecmp(master_runid, server.runid)) &#123;</div><div class="line">        /* Run id &quot;?&quot; is used by slaves that want to force a full resync. */</div><div class="line">        // 如果从节点的运行ID是&quot;?&quot;，表示想要强制进行一个全量同步</div><div class="line">        if (master_runid[0] != &apos;?&apos;) &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Partial resynchronization not accepted: &quot;</div><div class="line">                &quot;Runid mismatch (Client asked for runid &apos;%s&apos;, my runid is &apos;%s&apos;)&quot;,</div><div class="line">                master_runid, server.runid);</div><div class="line">        &#125; else &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Full resync requested by slave %s&quot;,</div><div class="line">                replicationGetSlaveName(c));</div><div class="line">        &#125;</div><div class="line">        goto need_full_resync;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从参数对象中获取psync_offset</div><div class="line">    if (getLongLongFromObjectOrReply(c,c-&gt;argv[2],&amp;psync_offset,NULL) !=</div><div class="line">       C_OK) goto need_full_resync;</div><div class="line">    // 如果psync_offset小于repl_backlog_off，说明backlog所备份的数据的已经太新了，有一些数据被覆盖，则需要进行全量复制</div><div class="line">    // 如果psync_offset大于(server.repl_backlog_off + server.repl_backlog_histlen)，表示当前backlog的数据不够全，则需要进行全量复制</div><div class="line">    if (!server.repl_backlog ||</div><div class="line">        psync_offset &lt; server.repl_backlog_off ||</div><div class="line">        psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_NOTICE,</div><div class="line">            &quot;Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld).&quot;, replicationGetSlaveName(c), psync_offset);</div><div class="line">        if (psync_offset &gt; server.master_repl_offset) &#123;</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Warning: slave %s tried to PSYNC with an offset that is greater than the master replication offset.&quot;, replicationGetSlaveName(c));</div><div class="line">        &#125;</div><div class="line">        goto need_full_resync;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行到这里，则可以进行部分重同步</div><div class="line">    // 1. 设置client状态为从节点</div><div class="line">    // 2. 向从节点发送 +CONTINUE 表示接受 partial resync 被接受</div><div class="line">    // 3. 发送backlog的数据给从节点</div><div class="line"></div><div class="line">    // 设置client状态为从节点</div><div class="line">    c-&gt;flags |= CLIENT_SLAVE;</div><div class="line">    // 设置复制状态为在线，此时RDB文件传输完成，发送差异数据</div><div class="line">    c-&gt;replstate = SLAVE_STATE_ONLINE;</div><div class="line">    // 设置从节点收到ack的时间</div><div class="line">    c-&gt;repl_ack_time = server.unixtime;</div><div class="line">    // slave向master发送ack标志设置为0</div><div class="line">    c-&gt;repl_put_online_on_ack = 0;</div><div class="line">    // 将当前client加入到从节点链表中</div><div class="line">    listAddNodeTail(server.slaves,c);</div><div class="line">    // 向从节点发送 +CONTINUE</div><div class="line">    buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE\r\n&quot;);</div><div class="line">    if (write(c-&gt;fd,buf,buflen) != buflen) &#123;</div><div class="line">        freeClientAsync(c);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">    // 将backlog的数据发送从节点</div><div class="line">    psync_len = addReplyReplicationBacklog(c,psync_offset);</div><div class="line">    serverLog(LL_NOTICE,</div><div class="line">        &quot;Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.&quot;, replicationGetSlaveName(c), psync_len, psync_offset);</div><div class="line">    // 计算延迟值小于min-slaves-max-lag的从节点的个数</div><div class="line">    refreshGoodSlavesCount();</div><div class="line">    return C_OK; /* The caller can return, no full resync needed. */</div><div class="line"></div><div class="line">need_full_resync:</div><div class="line">    return C_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果可以进行部分重同步，主节点则会发送”+CONTINUE\r\n”作为从节点发送PSYNC回复（看标题2.8）。然后调用addReplyReplicationBacklog()函数，将backlog中的数据发送给从节点。于是就完成了部分重同步。</p>
<p>addReplyReplicationBacklog()函数所做的就是将backlog写到从节点的client的输出缓冲区中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/23/redis-analysis-replicate/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/23/redis-analysis-replicate/" itemprop="url">
                  Redis源码剖析和注释（十二）--- Redis 复制(replicate)源码详细解析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T18:34:50+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-复制介绍"><a href="#1-复制介绍" class="headerlink" title="1. 复制介绍"></a>1. 复制介绍</h2><p>分布式数据库为了获取更大的存储容量和更高的并发访问量，会将原来集中式数据库中的数据分散存储到多个通过网络连接的数据存储节点上。Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="2-复制的建立"><a href="#2-复制的建立" class="headerlink" title="2. 复制的建立"></a>2. 复制的建立</h2><p>建立复制的配置方式有三种。</p>
<ul>
<li>在redis.conf文件中配置slaveof <masterip> <masterport>选项，然后指定该配置文件启动Redis生效。</masterport></masterip></li>
<li>在redis-server启动命令后加上–slaveof <masterip> <masterport>启动生效。</masterport></masterip></li>
<li><p>直接使用 slaveof <masterip> <masterport>命令在从节点执行生效。<br>我们以最简单的一主一从模型，使用第2种方式建立复制。</masterport></masterip></p>
</li>
<li><p>首先先开启主节点master实例，端口8888</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --port 8888</div></pre></td></tr></table></figure>
</li>
<li><p>接着开启从节点slave实例，端口9999，并指定指定主节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis-server --port 9999 --slaveof 127.0.0.1 8888</div><div class="line">//命令行开启Redis服务器后，会打印如下日志信息，已经开启复制了</div><div class="line">Connecting to MASTER 127.0.0.1:8888</div><div class="line">MASTER &lt;-&gt; SLAVE sync started</div><div class="line">Non blocking connect for SYNC fired the event.</div><div class="line">Master replied to PING, replication can continue...</div><div class="line">Partial resynchronization not possible (no cached master)</div><div class="line">Full resync from master: 1aff09ecd70ca640e33083f8422018b29883b9d1:1</div><div class="line">MASTER &lt;-&gt; SLAVE sync: receiving 76 bytes from master</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Flushing old data</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Finished with success</div></pre></td></tr></table></figure>
</li>
<li><p>开启一个client，连接上从节点服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  ~ redis-cli -p 9999</div><div class="line">127.0.0.1:9999&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:slave                      //节点角色</div><div class="line">master_host:127.0.0.1           //主节点的IP</div><div class="line">master_port:8888                //主节点的端口</div><div class="line">master_link_status:up           //与主节点的连接状态</div><div class="line">master_last_io_seconds_ago:0    //主节点最后与从节点的通信时间间隔，单位秒</div><div class="line">master_sync_in_progress:0       //从节点是否正在全量同步主节点的RDB文件</div><div class="line">slave_repl_offset:407           //复制偏移量</div><div class="line">slave_priority:100              //从节点的优先级</div><div class="line">slave_read_only:1               //从节点是否只读</div><div class="line">connected_slaves:0              //连接从节点的个数</div><div class="line">master_repl_offset:0            //当前从节点作为其他从节点的主节点时的复制偏移量</div><div class="line">//以下四种信息为通用的配置</div><div class="line">repl_backlog_active:0           //复制缓冲区的状态</div><div class="line">repl_backlog_size:1048576       //复制缓冲区的大小</div><div class="line">repl_backlog_first_byte_offset:0//复制缓冲区起始偏移量，标识当前缓冲区可用的范围</div><div class="line">repl_backlog_histlen:0          //标识复制缓冲区已存在的有效数据长度</div><div class="line">127.0.0.1:9999&gt; KEYS *          //由于主节点的键空间为空，所以从节点的键空间也为空。</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，我们查看主节点的INFO replication 信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//通过INFO replication命令可以查看当前的复制信息</div><div class="line">127.0.0.1:6380&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:master                                                     //节点角色</div><div class="line">connected_slaves:1                                              //连接从节点的个数</div><div class="line">slave0:ip=127.0.0.1,port=9999,state=online,offset=631,lag=0     //连接从节点的信息</div><div class="line">master_repl_offset:631                                          //主节点的偏移量</div><div class="line">//以下四种信息为通用的配置  </div><div class="line">repl_backlog_active:1                                           //复制缓冲区的状态</div><div class="line">repl_backlog_size:1048576                                       //复制缓冲区的大小</div><div class="line">repl_backlog_first_byte_offset:2                                //复制缓冲区起始偏移量，标识当前缓冲区可用的范围</div><div class="line">repl_backlog_histlen:630                                        //由于主节点的键空间为空，所以从节点的键空间也为空。</div></pre></td></tr></table></figure></p>
<p>到此，一主一从模型的复制就建立成功了。我们可以在主节点建立一些新的键，然后查看从节点的键空间的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//根据端口区别主从节点</div><div class="line">127.0.0.1:8888&gt; HSET hash_key hello world</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:9999&gt; KEYS *  //从节点的键空间已经更新</div><div class="line">1) &quot;hash_key&quot;</div></pre></td></tr></table></figure></p>
<p>我们在查看从节点的INFO replication信息时，可以知道slave_read_only:1，从节点默认只能读不能写，因此执行写命令会得到如下回复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; SET key value</div><div class="line">(error) READONLY You can&apos;t write against a read only slave.</div></pre></td></tr></table></figure></p>
<p>只读模式由 redis.conf 文件中的 slave-read-only 选项控制，也可以通过 CONFIG SET命令来开启或关闭这个模式。</p>
<p>我们在查看从节点的INFO replication信息时，还发现有connected_slaves:0选项 ，说明Redis的复制拓扑结构支持单层或多层复制关系，从节点还可以作为其他从节点的主节点进行复制。</p>
<p>根据拓扑关系可以分为三种：</p>
<ul>
<li><p>一主一从<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication01.jpg" alt="replicate01"></p>
</li>
<li><p>一主多从<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication02.jpg" alt="replicate01"></p>
</li>
<li><p>树型主从结构<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication03.jpg" alt="replicate01"></p>
</li>
</ul>
<h2 id="3-复制的断开"><a href="#3-复制的断开" class="headerlink" title="3. 复制的断开"></a>3. 复制的断开</h2><p>复制断开也是在从节点执行命令slaveof no one来断开于主节点的复制关系。例如，将刚才端口为9999的从节点断开复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; SLAVEOF no one</div><div class="line">OK</div><div class="line">//从节点服务器会打印如下日志</div><div class="line">Connection with master lost.</div><div class="line">Caching the disconnected master state.</div><div class="line">Discarding previously cached master state.</div><div class="line">MASTER MODE enabled (user request from &apos;id=3 addr=127.0.0.1:40218 fd=7 name= age=2218 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=slaveof&apos;)</div><div class="line">//主节点服务器也会打印断开的信息</div><div class="line">Connection with slave 127.0.0.1:9999 lost.</div></pre></td></tr></table></figure></p>
<p>从节点服务器断开后，从节点会晋升为主节点。从日志中可以看到MASTER MODE enabled，也可以从INFO命令查看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:master     //角色发生变化</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="4-min-slaves配置选项"><a href="#4-min-slaves配置选项" class="headerlink" title="4. min-slaves配置选项"></a>4. min-slaves配置选项</h2><p>Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主节点在不安全的情况下执行写命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">min-slaves-to-write 3   //从节点数量少于3个，主节点拒绝执行写命令</div><div class="line">min-slaves-max-lag 10   //3个从节点的延迟(lag)值，大于或等于10，主节点拒绝执行写命令</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/10/redis-analysis-t-string/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/10/redis-analysis-t-string/" itemprop="url">
                  Redis源码剖析和注释（九）--- 字符串命令的实现(t_string)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T22:52:18+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-字符串命令介绍"><a href="#1-字符串命令介绍" class="headerlink" title="1. 字符串命令介绍"></a>1. 字符串命令介绍</h2><table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET key value：设置指定 key 的值</td>
</tr>
<tr>
<td>2</td>
<td>GET key： 获取指定 key 的值。</td>
</tr>
<tr>
<td>3</td>
<td>GETRANGE key start end： 返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>4</td>
<td>GETSET key value：将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td>5</td>
<td>GETBIT key offset：对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>6</td>
<td>MGET key1 [key2..]：获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td>7</td>
<td>SETBIT key offset value：对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>8</td>
<td>SETEX key seconds value：将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td>9</td>
<td>SETNX key value：只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td>10</td>
<td>SETRANGE key offset value：用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td>11</td>
<td>STRLEN key：返回 key 所储存的字符串值的长度。</td>
</tr>
<tr>
<td>12</td>
<td>MSET key value [key value …]：同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td>13</td>
<td>MSETNX key value [key value …]：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td>14</td>
<td>PSETEX key milliseconds value：这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td>15</td>
<td>INCR key：将 key 中储存的数字值增一。</td>
</tr>
<tr>
<td>16</td>
<td>INCRBY key increment将 key： 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td>17</td>
<td>INCRBYFLOAT key increment：将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td>18</td>
<td>DECR key：将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td>19</td>
<td>DECRBY key decrementkey： 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td>20</td>
<td>APPEND key value：如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</td>
</tr>
</tbody>
</table>
<h2 id="2-字符串命令的实现"><a href="#2-字符串命令的实现" class="headerlink" title="2. 字符串命令的实现"></a>2. 字符串命令的实现</h2><p>字符串命令底层数据结构为 简单动态字符串SDS 。对于字符串命令，无论是命令本身还是参数，都是作为成一个对象对待的。关于redis的对象系统，请参考文章：redis对象系统源码剖析和注释。</p>
<p>在redis的对象系统中，字符串对象的底层实现类型有如下三种：</p>
<table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串实现的字符串对象</td>
</tr>
</tbody>
</table>
<p>因此，一个字符串对象的结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，字符串对象应该为 OBJ_STRING</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，分别为OBJ_STRING、OBJ_ENCODING_INT或OBJ_ENCODING_EMBSTR</div><div class="line">    unsigned encoding:4;</div><div class="line">    //暂且不关心该成员</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<p>我们假设一个key的值为”Hello World” ，因此它的空间结构如图所示：<br>[url01]</p>
<h2 id="3-字符串命令源码注释"><a href="#3-字符串命令源码注释" class="headerlink" title="3. 字符串命令源码注释"></a>3. 字符串命令源码注释</h2><p>这里列出几个重要的命令。</p>
<h3 id="3-1-SET-一类命令的最底层实现"><a href="#3-1-SET-一类命令的最底层实现" class="headerlink" title="3.1 SET 一类命令的最底层实现"></a>3.1 SET 一类命令的最底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#define OBJ_SET_NO_FLAGS 0</div><div class="line">#define OBJ_SET_NX (1&lt;&lt;0)     /* Set if key not exists. */          //在key不存在的情况下才会设置</div><div class="line">#define OBJ_SET_XX (1&lt;&lt;1)     /* Set if key exists. */              //在key存在的情况下才会设置</div><div class="line">#define OBJ_SET_EX (1&lt;&lt;2)     /* Set if time in seconds is given */ //以秒(s)为单位设置键的key过期时间</div><div class="line">#define OBJ_SET_PX (1&lt;&lt;3)     /* Set if time in ms in given */      //以毫秒(ms)为单位设置键的key过期时间</div><div class="line"></div><div class="line">//setGenericCommand()函数是以下命令: SET, SETEX, PSETEX, SETNX.的最底层实现</div><div class="line">//flags 可以是NX或XX，由上面的宏提供</div><div class="line">//expire 定义key的过期时间，格式由unit指定</div><div class="line">//ok_reply和abort_reply保存着回复client的内容，NX和XX也会改变回复</div><div class="line">//如果ok_reply为空，则使用 &quot;+OK&quot;</div><div class="line">//如果abort_reply为空，则使用 &quot;$-1&quot;</div><div class="line">void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) &#123;</div><div class="line">    long long milliseconds = 0; /* initialized to avoid any harmness warning */ //初始化，避免错误</div><div class="line"></div><div class="line">    //如果定义了key的过期时间</div><div class="line">    if (expire) &#123;</div><div class="line">        //从expire对象中取出值，保存在milliseconds中，如果出错发送默认的信息给client</div><div class="line">        if (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) != C_OK)</div><div class="line">            return;</div><div class="line">        // 如果过期时间小于等于0，则发送错误信息给client</div><div class="line">        if (milliseconds &lt;= 0) &#123;</div><div class="line">            addReplyErrorFormat(c,&quot;invalid expire time in %s&quot;,c-&gt;cmd-&gt;name);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //如果unit的单位是秒，则需要转换为毫秒保存</div><div class="line">        if (unit == UNIT_SECONDS) milliseconds *= 1000;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //lookupKeyWrite函数是为执行写操作而取出key的值对象</div><div class="line">    //如果设置了NX(不存在)，并且在数据库中 找到 该key，或者</div><div class="line">    //设置了XX(存在)，并且在数据库中 没有找到 该key</div><div class="line">    //回复abort_reply给client</div><div class="line">    if ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != NULL) ||</div><div class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == NULL))</div><div class="line">    &#123;</div><div class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //在当前db设置键为key的值为val</div><div class="line">    setKey(c-&gt;db,key,val);</div><div class="line"></div><div class="line">    //设置数据库为脏(dirty)，服务器每次修改一个key后，都会对脏键(dirty)增1</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //设置key的过期时间</div><div class="line">    //mstime()返回毫秒为单位的格林威治时间</div><div class="line">    if (expire) setExpire(c-&gt;db,key,mstime()+milliseconds);</div><div class="line"></div><div class="line">    //发送&quot;set&quot;事件的通知，用于发布订阅模式，通知客户端接受发生的事件</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;set&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //发送&quot;expire&quot;事件通知</div><div class="line">    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</div><div class="line">        &quot;expire&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //设置成功，则向客户端发送ok_reply</div><div class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-GET-一类命令的最底层实现"><a href="#3-2-GET-一类命令的最底层实现" class="headerlink" title="3.2 GET 一类命令的最底层实现"></a>3.2 GET 一类命令的最底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GET 命令的底层实现</div><div class="line">int getGenericCommand(client *c) &#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    //lookupKeyReadOrReply函数是为执行读操作而返回key的值对象，找到返回该对象，找不到会发送信息给client</div><div class="line">    //如果key不存在直接，返回0表示GET命令执行成功</div><div class="line">    if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.nullbulk)) == NULL)</div><div class="line">        return C_OK;</div><div class="line"></div><div class="line">    //如果key的值的编码类型不是字符串对象</div><div class="line">    if (o-&gt;type != OBJ_STRING) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);    //返回类型错误的信息给client，返回-1表示GET命令执行失败</div><div class="line">        return C_ERR;</div><div class="line">    &#125; else &#123;</div><div class="line">        addReplyBulk(c,o);  //返回之前找到的对象作为回复给client，返回0表示GET命令执行成功</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-DECR-和-INCR-底层实现"><a href="#3-3-DECR-和-INCR-底层实现" class="headerlink" title="3.3 DECR 和 INCR 底层实现"></a>3.3 DECR 和 INCR 底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">// DECR key</div><div class="line">// INCR key</div><div class="line">//INCR和DECR命令的底层实现</div><div class="line">void incrDecrCommand(client *c, long long incr) &#123;</div><div class="line">    long long value, oldvalue;</div><div class="line">    robj *o, *new;</div><div class="line"></div><div class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);   //以写操作获取key的value对象</div><div class="line"></div><div class="line">    //找到了value对象但是value对象不是字符串类型，直接返回</div><div class="line">    if (o != NULL &amp;&amp; checkType(c,o,OBJ_STRING)) return;</div><div class="line"></div><div class="line">    //将字符串类型的value转换为longlong类型保存在value中</div><div class="line">    if (getLongLongFromObjectOrReply(c,o,&amp;value,NULL) != C_OK) return;</div><div class="line"></div><div class="line">    oldvalue = value;   //备份旧的value</div><div class="line"></div><div class="line">    //如果incr超出longlong类型所能表示的范围，发送错误信息</div><div class="line">    if ((incr &lt; 0 &amp;&amp; oldvalue &lt; 0 &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</div><div class="line">        (incr &gt; 0 &amp;&amp; oldvalue &gt; 0 &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</div><div class="line">        addReplyError(c,&quot;increment or decrement would overflow&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    value += incr;  //计算新的value值</div><div class="line"></div><div class="line">    //value对象目前非共享，编码为整型类型，且新value值不在共享范围，且value处于long类型所表示的范围内</div><div class="line">    if (o &amp;&amp; o-&gt;refcount == 1 &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</div><div class="line">        (value &lt; 0 || value &gt;= OBJ_SHARED_INTEGERS) &amp;&amp;</div><div class="line">        value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX)</div><div class="line">    &#123;</div><div class="line">        new = o;</div><div class="line">        o-&gt;ptr = (void*)((long)value);  //设置vlaue对象的值</div><div class="line">    &#125; else &#123;</div><div class="line">        //当不满足以上任意条件，则新创建一个字符串对象</div><div class="line">        new = createStringObjectFromLongLong(value);</div><div class="line"></div><div class="line">        //如果之前的value对象存在</div><div class="line">        if (o) &#123;</div><div class="line">            dbOverwrite(c-&gt;db,c-&gt;argv[1],new);  //用new对象去重写key的值</div><div class="line">        &#125; else &#123;</div><div class="line">            dbAdd(c-&gt;db,c-&gt;argv[1],new);        //如果之前的value不存在，将key和new组成新的key-value对</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);    //当数据库的键被改动，则会调用该函数发送信号</div><div class="line">    //发送&quot;incrby&quot;事件通知</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;incrby&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    //设置脏键</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //回复信息给client</div><div class="line">    addReply(c,shared.colon);</div><div class="line">    addReply(c,new);</div><div class="line">    addReply(c,shared.crlf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-APPEND-实现"><a href="#4-APPEND-实现" class="headerlink" title=".4 APPEND 实现"></a>.4 APPEND 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// APPEND key value</div><div class="line">// APPEND命令的实现</div><div class="line">void appendCommand(client *c) &#123;</div><div class="line">    size_t totlen;</div><div class="line">    robj *o, *append;</div><div class="line"></div><div class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);   //以写操作获取key的value对象</div><div class="line"></div><div class="line">    //如果没有获取到vlaue，则要创建一个</div><div class="line">    if (o == NULL) &#123;</div><div class="line">        /* Create the key */</div><div class="line">        c-&gt;argv[2] = tryObjectEncoding(c-&gt;argv[2]); //对参数value进行优化编码</div><div class="line">        dbAdd(c-&gt;db,c-&gt;argv[1],c-&gt;argv[2]); //将key和value组成新的key-value对</div><div class="line">        incrRefCount(c-&gt;argv[2]);           //增加value的引用计数</div><div class="line">        totlen = stringObjectLen(c-&gt;argv[2]);   //返回vlaue的长度</div><div class="line">    &#125; else &#123;    //获取到value</div><div class="line">        /* Key exists, check type */</div><div class="line">        if (checkType(c,o,OBJ_STRING))  //如果value不是字符串类型的对象直接返回</div><div class="line">            return;</div><div class="line"></div><div class="line">        /* &quot;append&quot; is an argument, so always an sds */</div><div class="line">        //获得追加的值对象</div><div class="line">        append = c-&gt;argv[2];</div><div class="line">        //计算追加后的长度</div><div class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</div><div class="line">        //如果追加后的长度超出范围，则返回</div><div class="line">        if (checkStringLength(c,totlen) != C_OK)</div><div class="line">            return;</div><div class="line"></div><div class="line">        /* Append the value */</div><div class="line">        //因为要根据value修改key的值，因此如果key原来的值是共享的，需要解除共享，新创建一个值对象与key组对</div><div class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);</div><div class="line">        //将vlaue对象的值后面追加上append的值</div><div class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</div><div class="line">        //计算出追加后值的长度</div><div class="line">        totlen = sdslen(o-&gt;ptr);</div><div class="line">    &#125;</div><div class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);//当数据库的键被改动，则会调用该函数发送信号</div><div class="line">    //发送&quot;append&quot;事件通知</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;append&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    //设置脏键</div><div class="line">    server.dirty++;</div><div class="line">    //发送追加后value的长度给client</div><div class="line">    addReplyLongLong(c,totlen);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/10/redis-analysis-standalone/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/10/redis-analysis-standalone/" itemprop="url">
                  Redis源码剖析和注释（二十一）--- 单机服务器实现
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T18:39:02+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Redis-服务器"><a href="#1-Redis-服务器" class="headerlink" title="1. Redis 服务器"></a>1. Redis 服务器</h2><p>Redis服务器负责与客户端建立网络连接，处理发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并且通过一系列资源管理措施来维持服务器自身的正常运转。本次主要剖析server.c文件，本文主要介绍Redis服务器的一下几个实现：</p>
<ul>
<li>命令的执行过程</li>
<li>Redis服务器的周期性任务</li>
<li>maxmemory的策略</li>
<li>Redis服务器的main函数</li>
</ul>
<h2 id="2-命令的执行过程"><a href="#2-命令的执行过程" class="headerlink" title="2. 命令的执行过程"></a>2. 命令的执行过程</h2><p>Redis一个命令的完整执行过程如下：</p>
<ul>
<li>客户端发送命令请求</li>
<li>服务器接收命令请求</li>
<li>服务器执行命令请求</li>
<li>将回复发送给客户端<br>关于命令接收与命令回复，在Redis 网络连接库剖析一文已经详细剖析过，本篇主要针对第三步，也就是服务器执行命令的过程进行剖析。</li>
</ul>
<p>服务器在接收到命令后，会将命令以对象的形式保存在服务器client的参数列表robj **argv中，因此服务器执行命令请求时，服务器已经读入了一套命令参数保存在参数列表中。执行命令的过程对应的函数是processCommand()，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div></pre></td><td class="code"><pre><div class="line">// 如果client没有被关闭则返回C_OK，调用者可以继续执行其他的操作，否则返回C_ERR，表示client被销毁</div><div class="line">int processCommand(client *c) &#123;</div><div class="line">    // 如果是 quit 命令，则单独处理</div><div class="line">    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;quit&quot;)) &#123;</div><div class="line">        addReply(c,shared.ok);</div><div class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;   //设置client的状态为回复后立即关闭，返回C_ERR</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从数据库的字典中查找该命令</div><div class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</div><div class="line">    // 不存在的命令</div><div class="line">    if (!c-&gt;cmd) &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReplyErrorFormat(c,&quot;unknown command &apos;%s&apos;&quot;,</div><div class="line">            (char*)c-&gt;argv[0]-&gt;ptr);</div><div class="line">        return C_OK;</div><div class="line">    // 参数数量不匹配</div><div class="line">    &#125; else if ((c-&gt;cmd-&gt;arity &gt; 0 &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</div><div class="line">               (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReplyErrorFormat(c,&quot;wrong number of arguments for &apos;%s&apos; command&quot;,</div><div class="line">            c-&gt;cmd-&gt;name);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if the user is authenticated */</div><div class="line">    // 如果服务器设置了密码，但是没有认证成功</div><div class="line">    if (server.requirepass &amp;&amp; !c-&gt;authenticated &amp;&amp; c-&gt;cmd-&gt;proc != authCommand)</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReply(c,shared.noautherr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果开启了集群模式，则执行集群的重定向操作，下面的两种情况例外：</div><div class="line">    /*</div><div class="line">        1. 命令的发送是主节点服务器</div><div class="line">        2. 命令没有key</div><div class="line">    */</div><div class="line">    if (server.cluster_enabled &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</div><div class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0 &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != execCommand))</div><div class="line">    &#123;</div><div class="line">        int hashslot;</div><div class="line">        int error_code;</div><div class="line">        // 从集群中返回一个能够执行命令的节点</div><div class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</div><div class="line">                                        &amp;hashslot,&amp;error_code);</div><div class="line">        // 返回的节点不合格</div><div class="line">        if (n == NULL || n != server.cluster-&gt;myself) &#123;</div><div class="line">            // 如果是执行事务的命令，则取消事务</div><div class="line">            if (c-&gt;cmd-&gt;proc == execCommand) &#123;</div><div class="line">                discardTransaction(c);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 将事务状态设置为失败</div><div class="line">                flagTransaction(c);</div><div class="line">            &#125;</div><div class="line">            // 执行client的重定向操作</div><div class="line">            clusterRedirectClient(c,n,hashslot,error_code);</div><div class="line">            return C_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器有最大内存的限制</div><div class="line">    if (server.maxmemory) &#123;</div><div class="line">        // 按需释放一部分内存</div><div class="line">        int retval = freeMemoryIfNeeded();</div><div class="line">        // freeMemoryIfNeeded()函数之后需要冲洗从节点的输出缓冲区，这可能导致被释放的从节点是一个活跃的client</div><div class="line">        // 如果当前的client被释放，返回C_ERR</div><div class="line">        if (server.current_client == NULL) return C_ERR;</div><div class="line"></div><div class="line">        // 如果命令会耗费大量的内存但是释放内存失败</div><div class="line">        if ((c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM) &amp;&amp; retval == C_ERR) &#123;</div><div class="line">            // 将事务状态设置为失败</div><div class="line">            flagTransaction(c);</div><div class="line">            addReply(c, shared.oomerr);</div><div class="line">            return C_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果 BGSAVE 命令执行错误而且服务器是一个主节点，那么不接受写命令</div><div class="line">    if (((server.stop_writes_on_bgsave_err &amp;&amp;</div><div class="line">          server.saveparamslen &gt; 0 &amp;&amp;</div><div class="line">          server.lastbgsave_status == C_ERR) ||</div><div class="line">          server.aof_last_write_status == C_ERR) &amp;&amp;</div><div class="line">        server.masterhost == NULL &amp;&amp;</div><div class="line">        (c-&gt;cmd-&gt;flags &amp; CMD_WRITE ||</div><div class="line">         c-&gt;cmd-&gt;proc == pingCommand))</div><div class="line">    &#123;</div><div class="line">        // 将事务状态设置为失败</div><div class="line">        flagTransaction(c);</div><div class="line">        // 如果上一次执行AOF成功回复BGSAVE错误回复</div><div class="line">        if (server.aof_last_write_status == C_OK)</div><div class="line">            addReply(c, shared.bgsaveerr);</div><div class="line">        else</div><div class="line">            addReplySds(c,</div><div class="line">                sdscatprintf(sdsempty(),</div><div class="line">                &quot;-MISCONF Errors writing to the AOF file: %s\r\n&quot;,</div><div class="line">                strerror(server.aof_last_write_errno)));</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有足够的良好的从节点而且用户配置了 min-slaves-to-write，那么不接受写命令</div><div class="line">    if (server.masterhost == NULL &amp;&amp;</div><div class="line">        server.repl_min_slaves_to_write &amp;&amp;</div><div class="line">        server.repl_min_slaves_max_lag &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;flags &amp; CMD_WRITE &amp;&amp;</div><div class="line">        server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</div><div class="line">    &#123;</div><div class="line">        // 将事务状态设置为失败</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.noreplicaserr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果这是一个只读的从节点服务器，则不接受写命令</div><div class="line">    if (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;flags &amp; CMD_WRITE)</div><div class="line">    &#123;</div><div class="line">        addReply(c, shared.roslaveerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果处于发布订阅模式，但是执行的不是发布订阅命令，返回</div><div class="line">    if (c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != punsubscribeCommand) &#123;</div><div class="line">        addReplyError(c,&quot;only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context&quot;);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果是从节点且和主节点断开了连接，不允许从服务器带有过期数据，返回</div><div class="line">    if (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</div><div class="line">        server.repl_serve_stale_data == 0 &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;flags &amp; CMD_STALE))</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.masterdownerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器处于载入状态，如果命令不是CMD_LOADING标识，则不执行，返回</div><div class="line">    if (server.loading &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING)) &#123;</div><div class="line">        addReply(c, shared.loadingerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果lua脚本超时，限制执行一部分命令，如shutdown、scriptCommand</div><div class="line">    if (server.lua_timedout &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</div><div class="line">          c-&gt;argc == 2 &amp;&amp;</div><div class="line">          tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == &apos;n&apos;) &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</div><div class="line">          c-&gt;argc == 2 &amp;&amp;</div><div class="line">          tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == &apos;k&apos;))</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.slowscripterr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行命令</div><div class="line">    // client处于事务环境中，但是执行命令不是exec、discard、multi和watch</div><div class="line">    if (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</div><div class="line">    &#123;</div><div class="line">        // 除了上述的四个命令，其他的命令添加到事务队列中</div><div class="line">        queueMultiCommand(c);</div><div class="line">        addReply(c,shared.queued);</div><div class="line">    // 执行普通的命令</div><div class="line">    &#125; else &#123;</div><div class="line">        call(c,CMD_CALL_FULL);</div><div class="line">        // 保存写全局的复制偏移量</div><div class="line">        c-&gt;woff = server.master_repl_offset;</div><div class="line">        // 如果因为BLPOP而阻塞的命令已经准备好，则处理client的阻塞状态</div><div class="line">        if (listLength(server.ready_keys))</div><div class="line">            handleClientsBlockedOnLists();</div><div class="line">    &#125;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们总结出执行命令的大致过程：</p>
<ul>
<li>查找命令。对应的代码是：c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</li>
<li>执行命令前的准备。对应这些判断语句。</li>
<li>执行命令。对应代码是：call(c,CMD_CALL_FULL);</li>
</ul>
<p>我们就大致就这三个过程详细解释。</p>
<h3 id="2-1-查找命令"><a href="#2-1-查找命令" class="headerlink" title="2.1 查找命令"></a>2.1 查找命令</h3><p>lookupCommand()函数是对dictFetchValue(server.commands, name);的封装。而这个函数的意思是：从server.commands字典中查找name命令。这个保存命令表的字典，键是命令的名称，值是命令表的地址。因此我们介绍服务器初始化时的一个操作，就是创建一张命令表。命令表代码简化表示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct redisCommand redisCommandTable[] = &#123;</div><div class="line">    &#123;&quot;get&quot;,getCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0&#125;,</div><div class="line">    &#123;&quot;set&quot;,setCommand,-3,&quot;wm&quot;,0,NULL,1,1,1,0,0&#125;,</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们只展示了命令表的两条，可以通过COMMAND COUNT命令查看命令的个数。虽然只有两条，但是可以说明问题。</p>
<p>首先命令表是就是一个数组，数组的每个成员都是一个struct redisCommand结构体，对每个数组成员都进行了初始化。我们一次对每个值进行分析：以GET命令为例子。</p>
<ul>
<li>char *name：命令的名字。对应 “get”。</li>
<li>redisCommandProc *proc：命令实现的函数。对应 getCommand。</li>
<li>int arity：参数个数，-N表示大于等于N。对应2。</li>
<li>char *sflags：命令的属性，用以下字符作为标识。对应”rF”。 <ul>
<li>w：写入命令，会修改数据库。</li>
<li>r：读取命令，不会修改数据库。</li>
<li>m：一旦执行会增加内存使用，如果内存短缺则不被允许执行。</li>
<li>a：管理员命令，例如：SAVE or SHUTDOWN。</li>
<li>p：发布订阅有关的命令。</li>
<li>f：强制进行复制的命令，无视服务器的脏键。</li>
<li>s：不能在脚本中执行的命令。</li>
<li>R：随机命令。相同的键有相同的参数，在相同的数据库中，可能会有不同的结果。</li>
<li>S：如果在脚本中调用，那么会对这个命令的输出进行一次排序。</li>
<li>l：当载入数据库时，允许执行该命令。</li>
<li>t：从节点服务器持有过期数据时，允许执行的命令。</li>
<li>M：不能在 MONITOR 下自动传播的命令。</li>
<li>k：为该命令执行一个隐式的ASKING，所以在集群模式下，如果槽被标记为’importing’，那这个命令会被接收。<br>*F：快速执行的命令。时间复杂度为O(1) or O(log(N))的命令只要内核调度为Redis分配时间片，那么就不应该在执行时被延迟。</li>
</ul>
</li>
<li>int flags：sflags的二进制标识形式，可以通过位运算进行组合。对应0。</li>
<li>redisGetKeysProc *getkeys_proc：从命令中获取键的参数，是一个可选的功能，一般用于三个字段不够执行键的参数的情况。对应NULL。</li>
<li>int firstkey：第一个参数是 key。对应1。</li>
<li>int lastkey：最后一个参数是 key。对应1。</li>
<li>int keystep：从第一个 key 到最后一个 key 的步长。MSET 的步长是 2 因为：key,val,key,val,…。对应1。</li>
<li>long long microseconds：记录执行命令的耗费总时长。对应0。</li>
<li>long long calls：记录命令被执行的总次数。对应0。<br>当从命令表中找到命令后，会将找到的命令的地址，返回给struct redisCommand <em>cmd, </em>lastcmd;这两个指针保存起来。到此查找命令的操作就完成。</li>
</ul>
<h2 id="2-2-执行命令前的准备"><a href="#2-2-执行命令前的准备" class="headerlink" title="2.2 执行命令前的准备"></a>2.2 执行命令前的准备</h2><p>此时，命令已经在命令表中查找到，并且保存在了对应的指针中。但是真正执行前，还进行了许多的情况的判断。我们简单列举几种。</p>
<ul>
<li>首先就是判断命令的参数是否匹配。</li>
<li>检查服务器的认证是否通过。</li>
<li>集群模式下的判断。</li>
<li>服务器最大内存限制是否通过。</li>
<li>某些情况下，不接受写命令。</li>
<li>发布订阅模式。</li>
<li>是否是lua脚本中的命令。<br>等等……<br>所以，命令执行的过程还是很复杂的，简单总结一句：命令不易，何况人生。</li>
</ul>
<p>2.3 执行命令<br>执行命令调用了call(c,CMD_CALL_FULL)函数，该函数是执行命令的核心。但是不用想，这个函数一定是对回调函数c-&gt;cmd-&gt;proc(c)的封装，因为proc指向命令的实现函数。我们贴出该函数的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">void call(client *c, int flags) &#123;</div><div class="line">    long long dirty, start, duration;</div><div class="line">    int client_old_flags = c-&gt;flags;    //备份client的flags</div><div class="line"></div><div class="line">    // 将命令发送给 MONITOR</div><div class="line">    if (listLength(server.monitors) &amp;&amp;</div><div class="line">        !server.loading &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</div><div class="line">    &#123;</div><div class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清除一些需要按照命令需求设置的标志，以防干扰</div><div class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line">    // 初始化Redis操作数组，用来追加命令的传播</div><div class="line">    redisOpArrayInit(&amp;server.also_propagate);</div><div class="line"></div><div class="line">    /* Call the command. */</div><div class="line">    // 备份脏键数</div><div class="line">    dirty = server.dirty;</div><div class="line">    // 获取执行命令的开始时间</div><div class="line">    start = ustime();</div><div class="line">    // 执行命令</div><div class="line">    c-&gt;cmd-&gt;proc(c);</div><div class="line">    // 命令的执行时间</div><div class="line">    duration = ustime()-start;</div><div class="line">    // 命令修改的键的个数</div><div class="line">    dirty = server.dirty-dirty;</div><div class="line">    if (dirty &lt; 0) dirty = 0;</div><div class="line"></div><div class="line">    // 当执行 EVAL 命令时正在加载AOF，而且不希望Lua调用的命令进入slowlog或填充统计信息</div><div class="line">    if (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</div><div class="line">        flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);  //取消慢查询和记录统计信息的标志</div><div class="line"></div><div class="line">    // 如果函数调用者是Lua脚本，且命令的flags或客户端的flags指定了强制传播，我们要强制EVAL调用者传播脚本</div><div class="line">    if (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) &#123;</div><div class="line">        // 如果指定了强制将命令传播到从节点</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_REPL)</div><div class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;  //强制执行lua脚本的client要传播命令到从节点</div><div class="line">        // 如果指定了强制将节点传播到AOF中</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_AOF)</div><div class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;   //强制执行lua脚本的client要传播命令到AOF文件</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 命令的flags指定了慢查询标志，要将总的统计信息推入慢查询日志中</div><div class="line">    if (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; c-&gt;cmd-&gt;proc != execCommand) &#123;</div><div class="line">        char *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</div><div class="line">                              &quot;fast-command&quot; : &quot;command&quot;;</div><div class="line">        // 记录将延迟事件和延迟时间关联到延迟诊断的字典中</div><div class="line">        latencyAddSampleIfNeeded(latency_event,duration/1000);</div><div class="line">        // 将总的统计信息推入慢查询日志中</div><div class="line">        slowlogPushEntryIfNeeded(c-&gt;argv,c-&gt;argc,duration);</div><div class="line">    &#125;</div><div class="line">    // 命令的flags指定了CMD_CALL_STATS，更新命令的统计信息</div><div class="line">    if (flags &amp; CMD_CALL_STATS) &#123;</div><div class="line">        c-&gt;lastcmd-&gt;microseconds += duration;</div><div class="line">        c-&gt;lastcmd-&gt;calls++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器或追加到AOF中</div><div class="line">    if (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</div><div class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</div><div class="line">    &#123;</div><div class="line">        // 保存传播的标志，初始化为空</div><div class="line">        int propagate_flags = PROPAGATE_NONE;</div><div class="line"></div><div class="line">        // 如果命令修改了数据库中的键，则要传播到AOF和从节点中</div><div class="line">        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</div><div class="line"></div><div class="line">        // 如果client设置了强制AOF和复制的标志，则设置传播的标志</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</div><div class="line"></div><div class="line">        // 如果client的flags设置了CLIENT_PREVENT_REPL/AOF_PROP，表示阻止命令的传播到从节点或AOF，则取消传播对应标志</div><div class="line">        if (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</div><div class="line">            !(flags &amp; CMD_CALL_PROPAGATE_REPL))</div><div class="line">                propagate_flags &amp;= ~PROPAGATE_REPL;</div><div class="line">        if (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</div><div class="line">            !(flags &amp; CMD_CALL_PROPAGATE_AOF))</div><div class="line">                propagate_flags &amp;= ~PROPAGATE_AOF;</div><div class="line"></div><div class="line">        // 如果至少设置了一种传播，则执行相应传播命令操作</div><div class="line">        if (propagate_flags != PROPAGATE_NONE)</div><div class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清除一些需要按照命令需求设置的标志，以防干扰</div><div class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line">    // 恢复client原始的flags</div><div class="line">    c-&gt;flags |= client_old_flags &amp;</div><div class="line">        (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line"></div><div class="line">    // 传播追加在Redis操作数组中的命令</div><div class="line">    if (server.also_propagate.numops) &#123;</div><div class="line">        int j;</div><div class="line">        redisOp *rop;</div><div class="line">        // 如果命令的flags设置传播的标志</div><div class="line">        if (flags &amp; CMD_CALL_PROPAGATE) &#123;</div><div class="line">            // 遍历所有的命令</div><div class="line">            for (j = 0; j &lt; server.also_propagate.numops; j++) &#123;</div><div class="line">                rop = &amp;server.also_propagate.ops[j];</div><div class="line">                int target = rop-&gt;target;</div><div class="line">                /* Whatever the command wish is, we honor the call() flags. */</div><div class="line">                // 执行相应传播命令操作</div><div class="line">                if (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</div><div class="line">                if (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</div><div class="line">                if (target)</div><div class="line">                    propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 释放Redis操作数组</div><div class="line">        redisOpArrayFree(&amp;server.also_propagate);</div><div class="line">    &#125;</div><div class="line">    // 命令执行的次数加1</div><div class="line">    server.stat_numcommands++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行命令时，可以指定一个flags。这个flags是用于执行完命令之后的一些后续工作。我们说明这些flags的含义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CMD_CALL_NONE：没有指定flags</div><div class="line">CMD_CALL_SLOWLOG：检查命令的执行速度，如果需要记录在慢查询日志中</div><div class="line">CMD_CALL_STATS：记录命令的统计信息</div><div class="line">CMD_CALL_PROPAGATE_AOF：如果client设置了强制传播的标志或修改了数据集，则将命令追加到AOF文件中</div><div class="line">CMD_CALL_PROPAGATE_REPL：如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器中</div><div class="line">CMD_CALL_PROPAGATE：如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器或追加到AOF中</div><div class="line">CMD_CALL_FULL：包含以上所有的含义</div></pre></td></tr></table></figure></p>
<p>执行命令c-&gt;cmd-&gt;proc(c)就相当于执行了命令实现的函数，然后会在执行完成后，由这些函数产生相应的命令回复，根据回复的大小，会将回复保存在输出缓冲区buf或回复链表repl中。然后服务器会调用writeToClient()函数来将回复写到fd中。详细请看：Redis 网络连接库剖析。</p>
<p>至此，一条命令的执行过程就很清楚明了了。</p>
<h2 id="3-Redis服务器的周期性任务"><a href="#3-Redis服务器的周期性任务" class="headerlink" title="3. Redis服务器的周期性任务"></a>3. Redis服务器的周期性任务</h2><p>我们曾经在Redis 事件处理实现一文中说到，Redis的事件分为文件事件（file event）和时间事件（time event）。时间事件虽然是晚于文件事件执行，但是会每隔100ms都会执行一次。话不多说直接上代码：Redis 单机服务器实现源码注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div></pre></td><td class="code"><pre><div class="line">// 使用一个宏定义：run_with_period(milliseconds) &#123; .... &#125;，实现一部分代码有次数限制的被执行</div><div class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;</div><div class="line">    int j;</div><div class="line">    UNUSED(eventLoop);</div><div class="line">    UNUSED(id);</div><div class="line">    UNUSED(clientData);</div><div class="line"></div><div class="line">    // 如果设置了看门狗，则在过期时间内，递达一个 SIGALRM 信号</div><div class="line">    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);</div><div class="line"></div><div class="line">    // 设置服务器的时间缓存</div><div class="line">    updateCachedTime();</div><div class="line"></div><div class="line">    // 更新服务器的一些统计值</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        // 命令执行的次数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);</div><div class="line">        // 从网络读到的字节数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,</div><div class="line">                server.stat_net_input_bytes);</div><div class="line">        // 已经写到网络的字节数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,</div><div class="line">                server.stat_net_output_bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 服务器的LRU时间表示位数为24位，因此最长表示2^24秒，大约1.5年，只要在1.5年内，该对象被访问，那么就不会出现对象的LRU时间比服务器的时钟还要年轻的现象</div><div class="line">    // LRU_CLOCK_RESOLUTION 可以改变LRU时间的精度</div><div class="line"></div><div class="line">    // 获取服务器的LRU时钟</div><div class="line">    server.lruclock = getLRUClock();</div><div class="line"></div><div class="line">    // 更新服务器的最大内存使用量峰值</div><div class="line">    if (zmalloc_used_memory() &gt; server.stat_peak_memory)</div><div class="line">        server.stat_peak_memory = zmalloc_used_memory();</div><div class="line"></div><div class="line">    // 更新常驻内存的大小</div><div class="line">    server.resident_set_size = zmalloc_get_rss();</div><div class="line"></div><div class="line">    // 安全的关闭服务器</div><div class="line">    if (server.shutdown_asap) &#123;</div><div class="line">        // 关闭服务器前的准备动作，成功则关闭服务器</div><div class="line">        if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);</div><div class="line">        // 失败则打印日志</div><div class="line">        serverLog(LL_WARNING,&quot;SIGTERM received but errors trying to shut down the server, check the logs for more information&quot;);</div><div class="line">        // 撤销关闭服务器标志</div><div class="line">        server.shutdown_asap = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 打印数据库的信息到日志中</div><div class="line">    run_with_period(5000) &#123;</div><div class="line">        // 遍历数据库</div><div class="line">        for (j = 0; j &lt; server.dbnum; j++) &#123;</div><div class="line">            long long size, used, vkeys;</div><div class="line"></div><div class="line">            // 获取当前数据库的键值对字典的槽位数，键值对字典已使用的数量，过期键字典已使用的数量</div><div class="line">            size = dictSlots(server.db[j].dict);</div><div class="line">            used = dictSize(server.db[j].dict);</div><div class="line">            vkeys = dictSize(server.db[j].expires);</div><div class="line">            // 打印到日志中</div><div class="line">            if (used || vkeys) &#123;</div><div class="line">                serverLog(LL_VERBOSE,&quot;DB %d: %lld keys (%lld volatile) in %lld slots HT.&quot;,j,used,vkeys,size);</div><div class="line">                /* dictPrintStats(server.dict); */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器不在哨兵模式下，那么周期性打印一些连接client的信息到日志中</div><div class="line">    if (!server.sentinel_mode) &#123;</div><div class="line">        run_with_period(5000) &#123;</div><div class="line">            serverLog(LL_VERBOSE,</div><div class="line">                &quot;%lu clients connected (%lu slaves), %zu bytes in use&quot;,</div><div class="line">                listLength(server.clients)-listLength(server.slaves),</div><div class="line">                listLength(server.slaves),</div><div class="line">                zmalloc_used_memory());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行client的周期性任务</div><div class="line">    clientsCron();</div><div class="line"></div><div class="line">    // 执行数据库的周期性任务</div><div class="line">    databasesCron();</div><div class="line"></div><div class="line">    // 如果当前没有正在进行RDB和AOF持久化操作，且AOF重写操作被提上了日程，那么在后台执行AOF的重写操作</div><div class="line">    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</div><div class="line">        server.aof_rewrite_scheduled)</div><div class="line">    &#123;</div><div class="line">        rewriteAppendOnlyFileBackground();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果正在进行RDB或AOF重写等操作，那么等待接收子进程发来的信息</div><div class="line">    if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||</div><div class="line">        ldbPendingChildren())</div><div class="line">    &#123;</div><div class="line">        int statloc;</div><div class="line">        pid_t pid;</div><div class="line"></div><div class="line">        // 接收所有子进程发送的信号，非阻塞</div><div class="line">        if ((pid = wait3(&amp;statloc,WNOHANG,NULL)) != 0) &#123;</div><div class="line">            // 获取退出码</div><div class="line">            int exitcode = WEXITSTATUS(statloc);</div><div class="line">            int bysignal = 0;</div><div class="line"></div><div class="line">            // 判断子进程是否因为信号而终止，是的话，取得子进程因信号而中止的信号码</div><div class="line">            if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</div><div class="line"></div><div class="line">            // 子进程没有退出，还在进行RDB或AOF重写等操作</div><div class="line">            if (pid == -1) &#123;</div><div class="line">                // 打印日志</div><div class="line">                serverLog(LL_WARNING,&quot;wait3() returned an error: %s. &quot;</div><div class="line">                    &quot;rdb_child_pid = %d, aof_child_pid = %d&quot;,</div><div class="line">                    strerror(errno),</div><div class="line">                    (int) server.rdb_child_pid,</div><div class="line">                    (int) server.aof_child_pid);</div><div class="line">            // RDB持久化完成</div><div class="line">            &#125; else if (pid == server.rdb_child_pid) &#123;</div><div class="line">                // 将RDB文件写入磁盘或网络中</div><div class="line">                backgroundSaveDoneHandler(exitcode,bysignal);</div><div class="line">            // AOF持久化完成</div><div class="line">            &#125; else if (pid == server.aof_child_pid) &#123;</div><div class="line">                // 将重写缓冲区的命令追加AOF文件中，且进行同步操作</div><div class="line">                backgroundRewriteDoneHandler(exitcode,bysignal);</div><div class="line">            // 其他子进程，打印日志</div><div class="line">            &#125; else &#123;</div><div class="line">                if (!ldbRemoveChild(pid)) &#123;</div><div class="line">                    serverLog(LL_WARNING,</div><div class="line">                        &quot;Warning, detected child with unmatched pid: %ld&quot;,</div><div class="line">                        (long)pid);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 更新能否resize哈希的策略</div><div class="line">            updateDictResizePolicy();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    // 没有正在进行RDB或AOF重写等操作，那么检查是否需要执行</div><div class="line">    &#125; else &#123;</div><div class="line">        // 遍历save命令的参数数组</div><div class="line">         for (j = 0; j &lt; server.saveparamslen; j++) &#123;</div><div class="line">            struct saveparam *sp = server.saveparams+j;</div><div class="line"></div><div class="line">            // 数据库的键被修改的次数大于SAVE命令参数指定的修改次数，且已经过了SAVE命令参数指定的秒数</div><div class="line">            if (server.dirty &gt;= sp-&gt;changes &amp;&amp;</div><div class="line">                server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</div><div class="line">                (server.unixtime-server.lastbgsave_try &gt;</div><div class="line">                 CONFIG_BGSAVE_RETRY_DELAY ||</div><div class="line">                 server.lastbgsave_status == C_OK))</div><div class="line">            &#123;</div><div class="line">                serverLog(LL_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;,</div><div class="line">                    sp-&gt;changes, (int)sp-&gt;seconds);</div><div class="line">                // 进行 BGSAVE 操作</div><div class="line">                rdbSaveBackground(server.rdb_filename);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         // 是否触发AOF重写操作</div><div class="line">         if (server.rdb_child_pid == -1 &amp;&amp;</div><div class="line">             server.aof_child_pid == -1 &amp;&amp;</div><div class="line">             server.aof_rewrite_perc &amp;&amp;</div><div class="line">             server.aof_current_size &gt; server.aof_rewrite_min_size)</div><div class="line">         &#123;</div><div class="line">            // 上一次重写后的大小</div><div class="line">            long long base = server.aof_rewrite_base_size ?</div><div class="line">                            server.aof_rewrite_base_size : 1;</div><div class="line">            // AOF文件增长的百分比</div><div class="line">            long long growth = (server.aof_current_size*100/base) - 100;</div><div class="line">            // 大于设置的百分比100则进行AOF后台重写</div><div class="line">            if (growth &gt;= server.aof_rewrite_perc) &#123;</div><div class="line">                serverLog(LL_NOTICE,&quot;Starting automatic rewriting of AOF on %lld%% growth&quot;,growth);</div><div class="line">                rewriteAppendOnlyFileBackground();</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将AOF缓存冲洗到磁盘中</div><div class="line">    if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);</div><div class="line"></div><div class="line">    // 当AOF重写操作，同样将重写缓冲区的数据刷新到AOF文件中</div><div class="line">    run_with_period(1000) &#123;</div><div class="line">        if (server.aof_last_write_status == C_ERR)</div><div class="line">            flushAppendOnlyFile(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 释放被设置为异步释放的client</div><div class="line">    freeClientsInAsyncFreeQueue();</div><div class="line"></div><div class="line">    // 解除client的暂停状态</div><div class="line">    clientsArePaused(); /* Don&apos;t check return value, just use the side effect. */</div><div class="line"></div><div class="line">    // 周期性执行复制的任务</div><div class="line">    run_with_period(1000) replicationCron();</div><div class="line"></div><div class="line">    /* Run the Redis Cluster cron. */</div><div class="line">    // 周期性执行集群任务</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        if (server.cluster_enabled) clusterCron();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //周期性执行哨兵任务</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        if (server.sentinel_mode) sentinelTimer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清理过期的被缓存的sockets连接</div><div class="line">    run_with_period(1000) &#123;</div><div class="line">        migrateCloseTimedoutSockets();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果 BGSAVE 被提上过日程，那么进行BGSAVE操作，因为AOF重写操作在更新</div><div class="line">    // 注意：此代码必须在上面的replicationCron()调用之后，确保在重构此文件以保持此顺序时。 这是有用的，因为我们希望优先考虑RDB节省的复制</div><div class="line">    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</div><div class="line">        server.rdb_bgsave_scheduled &amp;&amp;</div><div class="line">        (server.unixtime-server.lastbgsave_try &gt; CONFIG_BGSAVE_RETRY_DELAY ||</div><div class="line">         server.lastbgsave_status == C_OK))</div><div class="line">    &#123;</div><div class="line">        // 更新执行BGSAVE，成功则清除rdb_bgsave_scheduled标志</div><div class="line">        if (rdbSaveBackground(server.rdb_filename) == C_OK)</div><div class="line">            server.rdb_bgsave_scheduled = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 周期loop计数器加1</div><div class="line">    server.cronloops++;</div><div class="line">    // 返回周期，默认为100ms</div><div class="line">    return 1000/server.hz;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也是大致总结列出部分：</p>
<ul>
<li>主动删除过期的键（也可以在读数据库时被动删除）</li>
<li>喂看门狗 watchdog</li>
<li>更新一些统计值</li>
<li>渐进式rehash</li>
<li>触发 BGSAVE / AOF 的重写操作，并处理子进程的中断</li>
<li>不同状态的client的超时</li>
<li>复制重连<br>等……<br>我们重点看两个函数，一个是关于客户端资源管理的clientsCron()，一个是关于数据库资源管理的databasesCron()。</li>
</ul>
<h3 id="3-1客户端资源管理"><a href="#3-1客户端资源管理" class="headerlink" title="3.1客户端资源管理"></a>3.1客户端资源管理</h3><p>服务器要定时检查client是否与服务器有交互，如果超过了设置的限制时间，则要释放client所占用的资源。具体的函数是clientsCronHandleTimeout()，它被clientsCron()函数所调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 检查超时，如果client中断超时返回非零值，函数获取当前时间作为参数因为他被一个循环中调用多次。所以调用gettimeofday()为每一次迭代都是昂贵的，而没有任何实际的效益</div><div class="line">// client被关闭则返回1，没有关闭返回0</div><div class="line">int clientsCronHandleTimeout(client *c, mstime_t now_ms) &#123;</div><div class="line">    // 当前时间，单位秒</div><div class="line">    time_t now = now_ms/1000;</div><div class="line"></div><div class="line">    // 当前时间 - client上一次和服务器交互的时间 如果大于 服务器中设置client超过的最大时间</div><div class="line">    // 不检查这四类client的超时时间：slaves从节点服务器、masters主节点服务器、BLPOP被阻塞的client、订阅状态的client</div><div class="line">    if (server.maxidletime &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp;    /* no timeout for slaves */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;   /* no timeout for masters */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_BLOCKED) &amp;&amp;  /* no timeout for BLPOP */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_PUBSUB) &amp;&amp;   /* no timeout for Pub/Sub clients */</div><div class="line">        (now - c-&gt;lastinteraction &gt; server.maxidletime))</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_VERBOSE,&quot;Closing idle client&quot;);</div><div class="line">        freeClient(c);</div><div class="line">        return 1;</div><div class="line">    // 如果client处于BLPOP被阻塞</div><div class="line">    &#125; else if (c-&gt;flags &amp; CLIENT_BLOCKED) &#123;</div><div class="line">        // 如果阻塞的client的超时时间已经到达</div><div class="line">        if (c-&gt;bpop.timeout != 0 &amp;&amp; c-&gt;bpop.timeout &lt; now_ms) &#123;</div><div class="line">            // 回复client一个空回复</div><div class="line">            replyToBlockedClientTimedOut(c);</div><div class="line">            // 接触client的阻塞状态</div><div class="line">            unblockClient(c);</div><div class="line">        // 如果服务器处于集群模式</div><div class="line">        &#125; else if (server.cluster_enabled) &#123;</div><div class="line">            // 重定向client的阻塞到其他的服务器</div><div class="line">            if (clusterRedirectBlockedClientIfNeeded(c))</div><div class="line">                // 解除阻塞</div><div class="line">                unblockClient(c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-数据库资源管理"><a href="#3-2-数据库资源管理" class="headerlink" title="3.2 数据库资源管理"></a>3.2 数据库资源管理</h3><p>服务器要定时检查数据库的输入缓冲区是否可以resize，以节省内存资源。而resize输入缓冲区的两个条件：</p>
<ul>
<li>输入缓冲区的大小大于32K以及超过缓冲区的峰值的2倍。</li>
<li>client超过时间大于2秒，且输入缓冲区的大小超过1k<br>实现的函数是clientsCronResizeQueryBuffer()，被databasesCron()函数所调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// resize客户端的输入缓冲区</div><div class="line">int clientsCronResizeQueryBuffer(client *c) &#123;</div><div class="line">    // 获取输入缓冲区的大小</div><div class="line">    size_t querybuf_size = sdsAllocSize(c-&gt;querybuf);</div><div class="line">    // 计算服务器对于client的空转时间，也就是client的超时时间</div><div class="line">    time_t idletime = server.unixtime - c-&gt;lastinteraction;</div><div class="line"></div><div class="line">    // resize输入缓冲区的两个条件：</div><div class="line">    //      1. 输入缓冲区的大小大于32K以及超过缓冲区的峰值的2倍</div><div class="line">    //      2. client超过时间大于2秒，且输入缓冲区的大小超过1k</div><div class="line">    if (((querybuf_size &gt; PROTO_MBULK_BIG_ARG) &amp;&amp;</div><div class="line">         (querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2) ||</div><div class="line">         (querybuf_size &gt; 1024 &amp;&amp; idletime &gt; 2))</div><div class="line">    &#123;</div><div class="line">        // 只有输入缓冲区的未使用大小超过1k，则会释放未使用的空间</div><div class="line">        if (sdsavail(c-&gt;querybuf) &gt; 1024) &#123;</div><div class="line">            c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 清空输入缓冲区的峰值</div><div class="line">    c-&gt;querybuf_peak = 0;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-maxmemory的策略"><a href="#4-maxmemory的策略" class="headerlink" title="4. maxmemory的策略"></a>4. maxmemory的策略</h2><p>Redis 服务器对内存使用会有一个server.maxmemory的限制，如果超过这个限制，就要通过删除一些键空间来释放一些内存，具体函数对应freeMemoryIfNeeded()。</p>
<p>释放内存时，可以指定不同的策略。策略保存在maxmemory_policy中，他可以指定以下的几个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define MAXMEMORY_VOLATILE_LRU 0</div><div class="line">#define MAXMEMORY_VOLATILE_TTL 1</div><div class="line">#define MAXMEMORY_VOLATILE_RANDOM 2</div><div class="line">#define MAXMEMORY_ALLKEYS_LRU 3</div><div class="line">#define MAXMEMORY_ALLKEYS_RANDOM 4</div><div class="line">#define MAXMEMORY_NO_EVICTION 5</div></pre></td></tr></table></figure></p>
<p>可以看出主要分为三种，</p>
<ul>
<li>LRU：优先删除最近最少使用的键。</li>
<li>TTL：优先删除生存时间最短的键。</li>
<li>RANDOM：随机删除。<br>而ALLKEYS和VOLATILE的不同之处就是要确定是从数据库的键值对字典还是过期键字典中删除。</li>
</ul>
<p>了解了以上这些，我们贴出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line">// 按需释放内存空间</div><div class="line">int freeMemoryIfNeeded(void) &#123;</div><div class="line">    size_t mem_used, mem_tofree, mem_freed;</div><div class="line">    int slaves = listLength(server.slaves);</div><div class="line">    mstime_t latency, eviction_latency;</div><div class="line"></div><div class="line">    // 计算出服务器总的内存使用量，但是有两部分要减去</div><div class="line">    /*</div><div class="line">        1、从节点的输出缓冲区</div><div class="line">        2、AOF缓冲区</div><div class="line">    */</div><div class="line">    mem_used = zmalloc_used_memory();</div><div class="line">    // 存在从节点</div><div class="line">    if (slaves) &#123;</div><div class="line">        listIter li;</div><div class="line">        listNode *ln;</div><div class="line"></div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = listNodeValue(ln);</div><div class="line">            // 获取当前从节点的输出缓冲区的大小，不包含静态的固定回复缓冲区，因为他总被分配</div><div class="line">            unsigned long obuf_bytes = getClientOutputBufferMemoryUsage(slave);</div><div class="line">            // 减去当前从节点的输出缓冲区的大小</div><div class="line">            if (obuf_bytes &gt; mem_used)</div><div class="line">                mem_used = 0;</div><div class="line">            else</div><div class="line">                mem_used -= obuf_bytes;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 如果开启了AOF操作</div><div class="line">    if (server.aof_state != AOF_OFF) &#123;</div><div class="line">        // 减去AOF缓冲区的大小</div><div class="line">        mem_used -= sdslen(server.aof_buf);</div><div class="line">        // 减去AOF重写缓冲区的大小</div><div class="line">        mem_used -= aofRewriteBufferSize();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有超过服务器设置的最大内存限制，则返回C_OK</div><div class="line">    if (mem_used &lt;= server.maxmemory) return C_OK;</div><div class="line">    // 如果内存回收策略为不回收，则返回C_ERR</div><div class="line">    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</div><div class="line">        return C_ERR; /* We need to free memory, but policy forbids. */</div><div class="line"></div><div class="line">    // 计算需要回收的大小</div><div class="line">    mem_tofree = mem_used - server.maxmemory;</div><div class="line">    // 已回收的大小</div><div class="line">    mem_freed = 0;</div><div class="line">    // 设置回收延迟检测开始的时间</div><div class="line">    latencyStartMonitor(latency);</div><div class="line">    // 循环回收，直到到达需要回收大小</div><div class="line">    while (mem_freed &lt; mem_tofree) &#123;</div><div class="line">        int j, k, keys_freed = 0;</div><div class="line"></div><div class="line">        // 遍历所有的数据库</div><div class="line">        for (j = 0; j &lt; server.dbnum; j++) &#123;</div><div class="line">            long bestval = 0; /* just to prevent warning */</div><div class="line">            sds bestkey = NULL;</div><div class="line">            dictEntry *de;</div><div class="line">            redisDb *db = server.db+j;</div><div class="line">            dict *dict;</div><div class="line">            // 如果回收策略有ALLKEYS_LRU或RANDOM，从键值对字典中选择回收</div><div class="line">            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM)</div><div class="line">            &#123;</div><div class="line">                // 则从键值对字典中选择回收的键。选择样品字典</div><div class="line">                dict = server.db[j].dict;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则从过期键字典中选择回收的键。选择样品字典</div><div class="line">                dict = server.db[j].expires;</div><div class="line">            &#125;</div><div class="line">            if (dictSize(dict) == 0) continue;  //跳过空字典</div><div class="line"></div><div class="line">            /* volatile-random and allkeys-random policy */</div><div class="line">            // 如果回收策略有 ALLKEYS_RANDOM 或 VOLATILE_RANDOM，则是随机挑选</div><div class="line">            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</div><div class="line">            &#123;</div><div class="line">                // 随机返回一个key</div><div class="line">                de = dictGetRandomKey(dict);</div><div class="line">                bestkey = dictGetKey(de);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* volatile-lru and allkeys-lru policy */</div><div class="line">            // 如果回收策略有 ALLKEYS_LRU 或 VOLATILE_LRU，则使用LRU策略</div><div class="line">            else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_LRU)</div><div class="line">            &#123;</div><div class="line">                // 回收池</div><div class="line">                struct evictionPoolEntry *pool = db-&gt;eviction_pool;</div><div class="line"></div><div class="line">                while(bestkey == NULL) &#123;</div><div class="line">                    // evictionPoolPopulate()用于在每次我们想要过期一个键的时候，用几个节点填充evictionPool。 空闲时间小于当前key的之一的key被添加。 如果有free的节点，则始终添加key。 我们按升序插入key，所以空闲时间越短的键在左边，右边的空闲时间越长。</div><div class="line">                    // 从样品字典dict中随机选择样品</div><div class="line">                    evictionPoolPopulate(dict, db-&gt;dict, db-&gt;eviction_pool);</div><div class="line">                    // 从空转时间最长的开始遍历</div><div class="line">                    for (k = MAXMEMORY_EVICTION_POOL_SIZE-1; k &gt;= 0; k--) &#123;</div><div class="line">                        // 跳过空位置</div><div class="line">                        if (pool[k].key == NULL) continue;</div><div class="line">                        // 从样品字典dict中查找当前key</div><div class="line">                        de = dictFind(dict,pool[k].key);</div><div class="line"></div><div class="line">                        // 从收回池中删除</div><div class="line">                        sdsfree(pool[k].key);</div><div class="line">                        // 释放位置</div><div class="line">                        memmove(pool+k,pool+k+1,</div><div class="line">                            sizeof(pool[0])*(MAXMEMORY_EVICTION_POOL_SIZE-k-1));</div><div class="line">                        // 重置key和空转时间</div><div class="line">                        pool[MAXMEMORY_EVICTION_POOL_SIZE-1].key = NULL;</div><div class="line">                        pool[MAXMEMORY_EVICTION_POOL_SIZE-1].idle = 0;</div><div class="line"></div><div class="line">                        // 如果从样品字典中可以找到，则保存键</div><div class="line">                        if (de) &#123;</div><div class="line">                            bestkey = dictGetKey(de);</div><div class="line">                            break;</div><div class="line">                        // 没找到，则继续找下一个样品空间所保存的键</div><div class="line">                        &#125; else &#123;</div><div class="line">                            /* Ghost... */</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // 如果当前选出的所有的样品都没找到，则重新选择一批样品，知道找到一个可以释放的键</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* volatile-ttl */</div><div class="line">            // 如果回收策略有 VOLATILE_TTL，则选择生存时间最短的键</div><div class="line">            else if (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</div><div class="line">                // 抽样个数为maxmemory_samples个</div><div class="line">                for (k = 0; k &lt; server.maxmemory_samples; k++) &#123;</div><div class="line">                    sds thiskey;</div><div class="line">                    long thisval;</div><div class="line"></div><div class="line">                    // 返回一个键，获取他的生存时间</div><div class="line">                    de = dictGetRandomKey(dict);</div><div class="line">                    thiskey = dictGetKey(de);</div><div class="line">                    thisval = (long) dictGetVal(de);</div><div class="line"></div><div class="line">                    // 如果当前键的生存时间更短，则保存</div><div class="line">                    if (bestkey == NULL || thisval &lt; bestval) &#123;</div><div class="line">                        bestkey = thiskey;</div><div class="line">                        bestval = thisval;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Finally remove the selected key. */</div><div class="line">            // 删除所有被选择的键</div><div class="line">            if (bestkey) &#123;</div><div class="line">                long long delta;</div><div class="line"></div><div class="line">                robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</div><div class="line">                // 当一个键在主节点中过期时，主节点会发送del命令给从节点和AOF文件</div><div class="line">                propagateExpire(db,keyobj);</div><div class="line">                // 单独计算dbDelete()所释放的空间大小， 在AOF和复制链接中传播DEL的内存实际上大于我们释放的key的内存</div><div class="line">                // 但是无法解释，窦泽不会退出循环</div><div class="line">                // AOF和输出缓冲区的内存最终被释放，所以我们只关心键空间使用的内存</div><div class="line">                delta = (long long) zmalloc_used_memory();</div><div class="line">                // 设置删除key对象的开始时间</div><div class="line">                latencyStartMonitor(eviction_latency);</div><div class="line">                dbDelete(db,keyobj);</div><div class="line">                // 保存删除key对象时间</div><div class="line">                latencyEndMonitor(eviction_latency);</div><div class="line">                // 添加到延迟诊断字典中</div><div class="line">                latencyAddSampleIfNeeded(&quot;eviction-del&quot;,eviction_latency);</div><div class="line">                // 删除嵌套的延迟事件</div><div class="line">                latencyRemoveNestedEvent(latency,eviction_latency);</div><div class="line">                // 计算删除这个键的大小</div><div class="line">                delta -= (long long) zmalloc_used_memory();</div><div class="line">                // 更新内存释放量</div><div class="line">                mem_freed += delta;</div><div class="line">                // 服务器总的回收键的个数计数器加1</div><div class="line">                server.stat_evictedkeys++;</div><div class="line">                // 事件通知</div><div class="line">                notifyKeyspaceEvent(NOTIFY_EVICTED, &quot;evicted&quot;,</div><div class="line">                    keyobj, db-&gt;id);</div><div class="line">                // 释放键对象</div><div class="line">                decrRefCount(keyobj);</div><div class="line">                // 释放键的个数加1</div><div class="line">                keys_freed++;</div><div class="line"></div><div class="line">                // 如果有从节点，则刷新所有的输出缓冲区数据</div><div class="line">                if (slaves) flushSlavesOutputBuffers();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 如果所有数据库都没有释放键，返回C_ERR</div><div class="line">        if (!keys_freed) &#123;</div><div class="line">            latencyEndMonitor(latency);</div><div class="line">            latencyAddSampleIfNeeded(&quot;eviction-cycle&quot;,latency);</div><div class="line">            return C_ERR; /* nothing to free... */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 计算回收延迟的时间</div><div class="line">    latencyEndMonitor(latency);</div><div class="line">    latencyAddSampleIfNeeded(&quot;eviction-cycle&quot;,latency);</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-Redis服务器的main函数"><a href="#5-Redis服务器的main函数" class="headerlink" title="5. Redis服务器的main函数"></a>5. Redis服务器的main函数</h2><p>Redis 服务器的main()主要执行了一下操作：</p>
<ul>
<li>初始化服务器状态</li>
<li>载入服务器的配置</li>
<li>初始化服务器数据结构</li>
<li>载入持久化文件还原数据库状态</li>
<li>执行事件循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char **argv) &#123;</div><div class="line">    struct timeval tv;</div><div class="line">    int j;</div><div class="line"></div><div class="line">#ifdef INIT_SETPROCTITLE_REPLACEMENT</div><div class="line">    spt_init(argc, argv);</div><div class="line">#endif</div><div class="line">    // 本函数用来配置地域的信息，设置当前程序使用的本地化信息，LC_COLLATE 配置字符串比较</div><div class="line">    setlocale(LC_COLLATE,&quot;&quot;);</div><div class="line">    // 设置线程安全</div><div class="line">    zmalloc_enable_thread_safeness();</div><div class="line">    // 设置内存溢出的处理函数</div><div class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</div><div class="line">    // 初始化随机数发生器</div><div class="line">    srand(time(NULL)^getpid());</div><div class="line">    // 保存当前信息</div><div class="line">    gettimeofday(&amp;tv,NULL);</div><div class="line">    // 设置哈希函数的种子</div><div class="line">    dictSetHashFunctionSeed(tv.tv_sec^tv.tv_usec^getpid());</div><div class="line">    // 检查开启哨兵模式的两种方式</div><div class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</div><div class="line">    // 初始化服务器配置</div><div class="line">    initServerConfig();</div><div class="line"></div><div class="line">    // 设置可执行文件的绝对路径</div><div class="line">    server.executable = getAbsolutePath(argv[0]);</div><div class="line">    // 分配执行executable文件的参数列表的空间</div><div class="line">    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</div><div class="line">    server.exec_argv[argc] = NULL;</div><div class="line">    // 保存当前参数</div><div class="line">    for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</div><div class="line"></div><div class="line">    // 如果已开启哨兵模式</div><div class="line">    if (server.sentinel_mode) &#123;</div><div class="line">        // 初始化哨兵的配置</div><div class="line">        initSentinelConfig();</div><div class="line">        initSentinel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 检查是否执行&quot;redis-check-rdb&quot;检查程序</div><div class="line">    if (strstr(argv[0],&quot;redis-check-rdb&quot;) != NULL)</div><div class="line">        redis_check_rdb_main(argc,argv);    //该函数不会返回</div><div class="line"></div><div class="line">    // 解析参数</div><div class="line">    if (argc &gt;= 2) &#123;</div><div class="line">        j = 1; /* First option to parse in argv[] */</div><div class="line">        sds options = sdsempty();</div><div class="line">        char *configfile = NULL;</div><div class="line"></div><div class="line">        /* Handle special options --help and --version */</div><div class="line">        // 指定了打印版本信息，然后退出</div><div class="line">        if (strcmp(argv[1], &quot;-v&quot;) == 0 ||</div><div class="line">            strcmp(argv[1], &quot;--version&quot;) == 0) version();</div><div class="line">        // 执行帮助信息，然后退出</div><div class="line">        if (strcmp(argv[1], &quot;--help&quot;) == 0 ||</div><div class="line">            strcmp(argv[1], &quot;-h&quot;) == 0) usage();</div><div class="line">        // 执行内存测试程序</div><div class="line">        if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) &#123;</div><div class="line">            if (argc == 3) &#123;</div><div class="line">                memtest(atoi(argv[2]),50);</div><div class="line">                exit(0);</div><div class="line">            &#125; else &#123;</div><div class="line">                fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);</div><div class="line">                fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);</div><div class="line">                exit(1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* First argument is the config file name? */</div><div class="line">        // 如果第1个参数不是&apos;-&apos;，那么是配置文件</div><div class="line">        if (argv[j][0] != &apos;-&apos; || argv[j][1] != &apos;-&apos;) &#123;</div><div class="line">            configfile = argv[j];</div><div class="line">            // 设置配置文件的绝对路径</div><div class="line">            server.configfile = getAbsolutePath(configfile);</div><div class="line">            /* Replace the config file in server.exec_argv with</div><div class="line">             * its absoulte path. */</div><div class="line">            zfree(server.exec_argv[j]);</div><div class="line">            // 设置可执行的参数列表</div><div class="line">            server.exec_argv[j] = zstrdup(server.configfile);</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 解析指定的对象</div><div class="line">        while(j != argc) &#123;</div><div class="line">            // 如果是以&apos;-&apos;开头</div><div class="line">            if (argv[j][0] == &apos;-&apos; &amp;&amp; argv[j][1] == &apos;-&apos;) &#123;</div><div class="line">                /* Option name */</div><div class="line">                // 跳过&quot;--check-rdb&quot;</div><div class="line">                if (!strcmp(argv[j], &quot;--check-rdb&quot;)) &#123;</div><div class="line">                    /* Argument has no options, need to skip for parsing. */</div><div class="line">                    j++;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                // 每个选项之间用&apos;\n&apos;隔开</div><div class="line">                if (sdslen(options)) options = sdscat(options,&quot;\n&quot;);</div><div class="line">                // 将选项追加在sds中</div><div class="line">                options = sdscat(options,argv[j]+2);</div><div class="line">                // 选项和参数用 &quot; &quot;隔开</div><div class="line">                options = sdscat(options,&quot; &quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                /* Option argument */</div><div class="line">                // 追加选项参数</div><div class="line">                options = sdscatrepr(options,argv[j],strlen(argv[j]));</div><div class="line">                options = sdscat(options,&quot; &quot;);</div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        // 如果开启哨兵模式，哨兵模式配置文件不正确</div><div class="line">        if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == &apos;-&apos;) &#123;</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Sentinel config from STDIN not allowed.&quot;);</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Sentinel needs config file on disk to save state.  Exiting...&quot;);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        // 重置save命令的参数</div><div class="line">        resetServerSaveParams();</div><div class="line">        // 载入配置文件</div><div class="line">        loadServerConfig(configfile,options);</div><div class="line">        sdsfree(options);</div><div class="line">    &#125; else &#123;</div><div class="line">        serverLog(LL_WARNING, &quot;Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf&quot;, argv[0], server.sentinel_mode ? &quot;sentinel&quot; : &quot;redis&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 是否被监视</div><div class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</div><div class="line">    // 是否以守护进程的方式运行</div><div class="line">    int background = server.daemonize &amp;&amp; !server.supervised;</div><div class="line">    if (background) daemonize();</div><div class="line"></div><div class="line">    // 初始化服务器</div><div class="line">    initServer();</div><div class="line">    // 创建保存pid的文件</div><div class="line">    if (background || server.pidfile) createPidFile();</div><div class="line">    // 为服务器进程设置标题</div><div class="line">    redisSetProcTitle(argv[0]);</div><div class="line">    // 打印Redis的logo</div><div class="line">    redisAsciiArt();</div><div class="line">    // 检查backlog队列</div><div class="line">    checkTcpBacklogSettings();</div><div class="line"></div><div class="line">    // 如果不是哨兵模式</div><div class="line">    if (!server.sentinel_mode) &#123;</div><div class="line">        /* Things not needed when running in Sentinel mode. */</div><div class="line">        serverLog(LL_WARNING,&quot;Server started, Redis version &quot; REDIS_VERSION);</div><div class="line">    #ifdef __linux__</div><div class="line">        // 打印内存警告</div><div class="line">        linuxMemoryWarnings();</div><div class="line">    #endif</div><div class="line">        // 从AOF文件或RDB文件载入数据</div><div class="line">        loadDataFromDisk();</div><div class="line">        // 如果开启了集群模式</div><div class="line">        if (server.cluster_enabled) &#123;</div><div class="line">            // 集群模式下验证载入的数据</div><div class="line">            if (verifyClusterConfigWithData() == C_ERR) &#123;</div><div class="line">                serverLog(LL_WARNING,</div><div class="line">                    &quot;You can&apos;t have keys in a DB different than DB 0 when in &quot;</div><div class="line">                    &quot;Cluster mode. Exiting.&quot;);</div><div class="line">                exit(1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 打印端口号</div><div class="line">        if (server.ipfd_count &gt; 0)</div><div class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections on port %d&quot;, server.port);</div><div class="line">        // 打印本地套接字fd</div><div class="line">        if (server.sofd &gt; 0)</div><div class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections at %s&quot;, server.unixsocket);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 开启哨兵模式，哨兵模式和集群模式只能开启一种</div><div class="line">        sentinelIsRunning();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Warning the user about suspicious maxmemory setting. */</div><div class="line">    // 最大内存限制是否配置正确</div><div class="line">    if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&quot;, server.maxmemory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 进入事件循环之前执行beforeSleep()函数</div><div class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</div><div class="line">    // 运行事件循环，一直到服务器关闭</div><div class="line">    aeMain(server.el);</div><div class="line">    // 服务器关闭，删除事件循环</div><div class="line">    aeDeleteEventLoop(server.el);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/10/redis-analysis-redisobject/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/10/redis-analysis-redisobject/" itemprop="url">
                  Redis源码剖析和注释（八）--- redis对象(redisObject)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T18:39:02+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>redis中基于双端链表、简单动态字符串(sds)、字典、跳跃表、整数集合、压缩列表、快速列表等等数据结构实现了一个对象系统，并且实现了5种不同的对象，每种对象都使用了至少一种前面的数据结构，优化对象在不同场合下的使用效率。</p>
<h2 id="2-对象的系统的实现"><a href="#2-对象的系统的实现" class="headerlink" title="2. 对象的系统的实现"></a>2. 对象的系统的实现</h2><h3 id="2-1-对象的结构"><a href="#2-1-对象的结构" class="headerlink" title="2.1 对象的结构"></a>2.1 对象的结构</h3><p>对象结构robj功能：</p>
<ul>
<li>为5种不同的对象类型提供同一的表示形式。</li>
<li>为不同的对象适用于不同的场景，支持同一种对象类型采用多种的数据结构方式。</li>
<li>支持引用计数，实现对象共享机制。</li>
<li>记录对象的访问时间，便于删除对象。</li>
</ul>
<p>对象结构定义在redis 3.2版本的server.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#define LRU_BITS 24</div><div class="line">#define LRU_CLOCK_MAX ((1&lt;&lt;LRU_BITS)-1) /* Max value of obj-&gt;lru */</div><div class="line">#define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */</div><div class="line"></div><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，占4bits，共5种类型</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，占4bits，共10种类型</div><div class="line">    unsigned encoding:4;</div><div class="line"></div><div class="line">    //least recently used</div><div class="line">    //实用LRU算法计算相对server.lruclock的LRU时间</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line"></div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line"></div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div><div class="line"></div><div class="line">//type的占5种类型：</div><div class="line">/* Object types */</div><div class="line">#define OBJ_STRING 0    //字符串对象</div><div class="line">#define OBJ_LIST 1      //列表对象</div><div class="line">#define OBJ_SET 2       //集合对象</div><div class="line">#define OBJ_ZSET 3      //有序集合对象</div><div class="line">#define OBJ_HASH 4      //哈希对象</div><div class="line"></div><div class="line">/* Objects encoding. Some kind of objects like Strings and Hashes can be</div><div class="line"> * internally represented in multiple ways. The &apos;encoding&apos; field of the object</div><div class="line"> * is set to one of this fields for this object. */</div><div class="line">// encoding 的10种类型</div><div class="line">#define OBJ_ENCODING_RAW 0     /* Raw representation */     //原始表示方式，字符串对象是简单动态字符串</div><div class="line">#define OBJ_ENCODING_INT 1     /* Encoded as integer */         //long类型的整数</div><div class="line">#define OBJ_ENCODING_HT 2      /* Encoded as hash table */      //字典</div><div class="line">#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */          //不在使用</div><div class="line">#define OBJ_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */  //双端链表,不在使用</div><div class="line">#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */         //压缩列表</div><div class="line">#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */          //整数集合</div><div class="line">#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */      //跳跃表和字典</div><div class="line">#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */   //embstr编码的简单动态字符串</div><div class="line">#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */   //由压缩列表组成</div></pre></td></tr></table></figure></p>
<h3 id="2-2-字符串对象的底层实现类型"><a href="#2-2-字符串对象的底层实现类型" class="headerlink" title="2.2 字符串对象的底层实现类型"></a>2.2 字符串对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串实现的字符串对象</td>
</tr>
</tbody>
</table>
<h3 id="2-3-列表对象的底层实现类型"><a href="#2-3-列表对象的底层实现类型" class="headerlink" title="2.3 列表对象的底层实现类型"></a>2.3 列表对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>快速列表实现的列表对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的列表对象</td>
</tr>
</tbody>
</table>
<h3 id="2-4-集合对象的底层实现类型"><a href="#2-4-集合对象的底层实现类型" class="headerlink" title="2.4 集合对象的底层实现类型"></a>2.4 集合对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典实现的集合对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合实现的集合对象</td>
</tr>
</tbody>
</table>
<h3 id="2-5-哈希对象的底层实现类型"><a href="#2-5-哈希对象的底层实现类型" class="headerlink" title="2.5 哈希对象的底层实现类型"></a>2.5 哈希对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的哈希对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典实现的哈希对象</td>
</tr>
</tbody>
</table>
<h3 id="2-6-有序集合对象的底层实现类型"><a href="#2-6-有序集合对象的底层实现类型" class="headerlink" title="2.6 有序集合对象的底层实现类型"></a>2.6 有序集合对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳跃表和字典实现的有序集合对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的有序集合对象</td>
</tr>
</tbody>
</table>
<h2 id="3-对象系统的重要操作"><a href="#3-对象系统的重要操作" class="headerlink" title="3. 对象系统的重要操作"></a>3. 对象系统的重要操作</h2><h3 id="3-1创建一个字符串对象"><a href="#3-1创建一个字符串对象" class="headerlink" title="3.1创建一个字符串对象"></a>3.1创建一个字符串对象</h3><ul>
<li><p>编码为OBJ_ENCODING_RAW</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">robj *createObject(int type, void *ptr) &#123;   //创建一个对象</div><div class="line">    robj *o = zmalloc(sizeof(*o));          //分配空间</div><div class="line">    o-&gt;type = type;                         //设置对象类型</div><div class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;         //设置编码方式为OBJ_ENCODING_RAW</div><div class="line">    o-&gt;ptr = ptr;                           //设置</div><div class="line">    o-&gt;refcount = 1;                        //引用计数为1</div><div class="line"></div><div class="line">    /* Set the LRU to the current lruclock (minutes resolution). */</div><div class="line">    o-&gt;lru = LRU_CLOCK();                   //计算设置当前LRU时间</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编码为OBJ_ENCODING_EMBSTR</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is</div><div class="line"> * an object where the sds string is actually an unmodifiable string</div><div class="line"> * allocated in the same chunk as the object itself. */</div><div class="line">//创建一个embstr编码的字符串对象</div><div class="line">robj *createEmbeddedStringObject(const char *ptr, size_t len) &#123;</div><div class="line">    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);   //分配空间</div><div class="line">    struct sdshdr8 *sh = (void*)(o+1);  //o+1刚好就是struct sdshdr8的地址</div><div class="line"></div><div class="line">    o-&gt;type = OBJ_STRING;               //类型为字符串对象</div><div class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;  //设置编码类型OBJ_ENCODING_EMBSTR</div><div class="line">    o-&gt;ptr = sh+1;                      //指向分配的sds对象，分配的len+1的空间首地址</div><div class="line">    o-&gt;refcount = 1;                    //设置引用计数</div><div class="line">    o-&gt;lru = LRU_CLOCK();               //计算设置当前LRU时间</div><div class="line"></div><div class="line">    sh-&gt;len = len;                      //设置字符串长度</div><div class="line">    sh-&gt;alloc = len;                    //设置最大容量</div><div class="line">    sh-&gt;flags = SDS_TYPE_8;             //设置sds的类型</div><div class="line">    if (ptr) &#123;                          //如果传了字符串参数</div><div class="line">        memcpy(sh-&gt;buf,ptr,len);        //将传进来的ptr保存到对象中</div><div class="line">        sh-&gt;buf[len] = &apos;\0&apos;;            //结束符标志</div><div class="line">    &#125; else &#123;</div><div class="line">        memset(sh-&gt;buf,0,len+1);        //否则将对象的空间初始化为0</div><div class="line">    &#125;</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>两种字符串对象编码方式的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* Create a string object with EMBSTR encoding if it is smaller than</div><div class="line"> * REIDS_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is</div><div class="line"> * used.</div><div class="line"> *</div><div class="line"> * The current limit of 39 is chosen so that the biggest string object</div><div class="line"> * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */</div><div class="line"></div><div class="line">//sdshdr8的大小为3个字节，加上1个结束符共4个字节</div><div class="line">//redisObject的大小为16个字节</div><div class="line">//redis使用jemalloc内存分配器，且jemalloc会分配8，16，32，64等字节的内存</div><div class="line">//一个embstr固定的大小为16+3+1 = 20个字节，因此一个最大的embstr字符串为64-20 = 44字节</div><div class="line">#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</div><div class="line"></div><div class="line">// 创建字符串对象，根据长度使用不同的编码类型</div><div class="line">// createRawStringObject和createEmbeddedStringObject的区别是：</div><div class="line">// createRawStringObject是当字符串长度大于44字节时，robj结构和sdshdr结构在内存上是分开的</div><div class="line">// createEmbeddedStringObject是当字符串长度小于等于44字节时，robj结构和sdshdr结构在内存上是连续的</div><div class="line">robj *createStringObject(const char *ptr, size_t len) &#123;</div><div class="line">    if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</div><div class="line">        return createEmbeddedStringObject(ptr,len);</div><div class="line">    else</div><div class="line">        return createRawStringObject(ptr,len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-字符串对象编码的优化"><a href="#3-2-字符串对象编码的优化" class="headerlink" title="3.2 字符串对象编码的优化"></a>3.2 字符串对象编码的优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">/* Try to encode a string object in order to save space */</div><div class="line">//尝试优化字符串对象的编码方式以节约空间</div><div class="line">robj *tryObjectEncoding(robj *o) &#123;</div><div class="line">    long value;</div><div class="line">    sds s = o-&gt;ptr;</div><div class="line">    size_t len;</div><div class="line"></div><div class="line">    /* Make sure this is a string object, the only type we encode</div><div class="line">     * in this function. Other types use encoded memory efficient</div><div class="line">     * representations but are handled by the commands implementing</div><div class="line">     * the type. */</div><div class="line">    serverAssertWithInfo(NULL,o,o-&gt;type == OBJ_STRING);</div><div class="line"></div><div class="line">    /* We try some specialized encoding only for objects that are</div><div class="line">     * RAW or EMBSTR encoded, in other words objects that are still</div><div class="line">     * in represented by an actually array of chars. */</div><div class="line">    //如果字符串对象的编码类型为RAW或EMBSTR时，才对其重新编码</div><div class="line">    if (!sdsEncodedObject(o)) return o;</div><div class="line"></div><div class="line">    /* It&apos;s not safe to encode shared objects: shared objects can be shared</div><div class="line">     * everywhere in the &quot;object space&quot; of Redis and may end in places where</div><div class="line">     * they are not handled. We handle them only as values in the keyspace. */</div><div class="line">    //如果refcount大于1，则说明对象的ptr指向的值是共享的，不对共享对象进行编码</div><div class="line">     if (o-&gt;refcount &gt; 1) return o;</div><div class="line"></div><div class="line">    /* Check if we can represent this string as a long integer.</div><div class="line">     * Note that we are sure that a string larger than 20 chars is not</div><div class="line">     * representable as a 32 nor 64 bit integer. */</div><div class="line">    len = sdslen(s);            //获得字符串s的长度</div><div class="line"></div><div class="line">    //如果len小于等于20，表示符合long long可以表示的范围，且可以转换为long类型的字符串进行编码</div><div class="line">    if (len &lt;= 20 &amp;&amp; string2l(s,len,&amp;value)) &#123;</div><div class="line">        /* This object is encodable as a long. Try to use a shared object.</div><div class="line">         * Note that we avoid using shared integers when maxmemory is used</div><div class="line">         * because every object needs to have a private LRU field for the LRU</div><div class="line">         * algorithm to work well. */</div><div class="line">        if ((server.maxmemory == 0 ||</div><div class="line">             (server.maxmemory_policy != MAXMEMORY_VOLATILE_LRU &amp;&amp;</div><div class="line">              server.maxmemory_policy != MAXMEMORY_ALLKEYS_LRU)) &amp;&amp;</div><div class="line">            value &gt;= 0 &amp;&amp;</div><div class="line">            value &lt; OBJ_SHARED_INTEGERS)    //如果value处于共享整数的范围内</div><div class="line">        &#123;</div><div class="line">            decrRefCount(o);                //原对象的引用计数减1，释放对象</div><div class="line">            incrRefCount(shared.integers[value]); //增加共享对象的引用计数</div><div class="line">            return shared.integers[value];      //返回一个编码为整数的字符串对象</div><div class="line">        &#125; else &#123;        //如果不处于共享整数的范围</div><div class="line">            if (o-&gt;encoding == OBJ_ENCODING_RAW) sdsfree(o-&gt;ptr);   //释放编码为OBJ_ENCODING_RAW的对象</div><div class="line">            o-&gt;encoding = OBJ_ENCODING_INT;     //转换为OBJ_ENCODING_INT编码</div><div class="line">            o-&gt;ptr = (void*) value;             //指针ptr指向value对象</div><div class="line">            return o;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If the string is small and is still RAW encoded,</div><div class="line">     * try the EMBSTR encoding which is more efficient.</div><div class="line">     * In this representation the object and the SDS string are allocated</div><div class="line">     * in the same chunk of memory to save space and cache misses. */</div><div class="line">    //如果len小于44，44是最大的编码为EMBSTR类型的字符串对象长度</div><div class="line">    if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123;</div><div class="line">        robj *emb;</div><div class="line"></div><div class="line">        if (o-&gt;encoding == OBJ_ENCODING_EMBSTR) return o;   //将RAW对象转换为OBJ_ENCODING_EMBSTR编码类型</div><div class="line">        emb = createEmbeddedStringObject(s,sdslen(s)); //创建一个编码类型为OBJ_ENCODING_EMBSTR的字符串对象</div><div class="line">        decrRefCount(o);    //释放之前的对象</div><div class="line">        return emb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* We can&apos;t encode the object...</div><div class="line">     *</div><div class="line">     * Do the last try, and at least optimize the SDS string inside</div><div class="line">     * the string object to require little space, in case there</div><div class="line">     * is more than 10% of free space at the end of the SDS string.</div><div class="line">     *</div><div class="line">     * We do that only for relatively large strings as this branch</div><div class="line">     * is only entered if the length of the string is greater than</div><div class="line">     * OBJ_ENCODING_EMBSTR_SIZE_LIMIT. */</div><div class="line">    //无法进行编码，但是如果s的未使用的空间大于使用空间的10分之1</div><div class="line">    if (o-&gt;encoding == OBJ_ENCODING_RAW &amp;&amp;</div><div class="line">        sdsavail(s) &gt; len/10)</div><div class="line">    &#123;</div><div class="line">        o-&gt;ptr = sdsRemoveFreeSpace(o-&gt;ptr);    //释放所有的未使用空间</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Return the original object. */</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-引用计数管理对象"><a href="#3-3-引用计数管理对象" class="headerlink" title="3.3 引用计数管理对象"></a>3.3 引用计数管理对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//引用计数加1</div><div class="line">void incrRefCount(robj *o) &#123;</div><div class="line">    o-&gt;refcount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//引用计数减1</div><div class="line">void decrRefCount(robj *o) &#123;</div><div class="line">    if (o-&gt;refcount &lt;= 0) serverPanic(&quot;decrRefCount against refcount &lt;= 0&quot;);</div><div class="line"></div><div class="line">    //当引用对象等于1时，在操作引用计数减1，直接释放对象的ptr和对象空间</div><div class="line">    if (o-&gt;refcount == 1) &#123;</div><div class="line">        switch(o-&gt;type) &#123;</div><div class="line">        case OBJ_STRING: freeStringObject(o); break;</div><div class="line">        case OBJ_LIST: freeListObject(o); break;</div><div class="line">        case OBJ_SET: freeSetObject(o); break;</div><div class="line">        case OBJ_ZSET: freeZsetObject(o); break;</div><div class="line">        case OBJ_HASH: freeHashObject(o); break;</div><div class="line">        default: serverPanic(&quot;Unknown object type&quot;); break;</div><div class="line">        &#125;</div><div class="line">        zfree(o);</div><div class="line">    &#125; else &#123;</div><div class="line">        o-&gt;refcount--;  //否则减1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-对象的复制，创建的对象非共享"><a href="#3-4-对象的复制，创建的对象非共享" class="headerlink" title="3.4 对象的复制，创建的对象非共享"></a>3.4 对象的复制，创建的对象非共享</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//返回 复制的o对象的副本的地址，且创建的对象非共享</div><div class="line">robj *dupStringObject(robj *o) &#123;</div><div class="line">    robj *d;</div><div class="line"></div><div class="line">    serverAssert(o-&gt;type == OBJ_STRING);    //一定是OBJ_STRING类型</div><div class="line"></div><div class="line">    switch(o-&gt;encoding) &#123;                   //根据不同的编码类型</div><div class="line">    case OBJ_ENCODING_RAW:</div><div class="line">        return createRawStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));        //创建的对象非共享</div><div class="line">    case OBJ_ENCODING_EMBSTR:</div><div class="line">        return createEmbeddedStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));   //创建的对象非共享</div><div class="line">    case OBJ_ENCODING_INT:                  //整数编码类型</div><div class="line">        d = createObject(OBJ_STRING, NULL); //即使是共享整数范围内的整数，创建的对象也是非共享的</div><div class="line">        d-&gt;encoding = OBJ_ENCODING_INT;</div><div class="line">        d-&gt;ptr = o-&gt;ptr;</div><div class="line">        return d;</div><div class="line">    default:</div><div class="line">        serverPanic(&quot;Wrong encoding.&quot;);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-5-对象的解码操作"><a href="#3-5-对象的解码操作" class="headerlink" title="3.5 对象的解码操作"></a>3.5 对象的解码操作</h3><p>将保存的整数值解码成字符串对象返回回来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/* Get a decoded version of an encoded object (returned as a new object).</div><div class="line"> * If the object is already raw-encoded just increment the ref count. */</div><div class="line">//将对象是整型的解码为字符串并返回，如果是字符串编码则直接返回输入对象，只需增加引用计数</div><div class="line">robj *getDecodedObject(robj *o) &#123;</div><div class="line">    robj *dec;</div><div class="line"></div><div class="line">    if (sdsEncodedObject(o)) &#123;  //如果是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR类型的对象</div><div class="line">        incrRefCount(o);        //增加引用计数，返回一个共享的对象</div><div class="line">        return o;</div><div class="line">    &#125;</div><div class="line">    if (o-&gt;type == OBJ_STRING &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT) &#123; //如果是整数对象</div><div class="line">        char buf[32];</div><div class="line"></div><div class="line">        ll2string(buf,32,(long)o-&gt;ptr); //将整数转换为字符串</div><div class="line">        dec = createStringObject(buf,strlen(buf));  //创建一个字符串对象</div><div class="line">        return dec;</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown encoding type&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/10/redis-analysis-eventhanding/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/10/redis-analysis-eventhanding/" itemprop="url">
                  Redis源码剖析和注释（十九）--- Redis 事件处理实现
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T18:39:02+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Redis事件介绍"><a href="#1-Redis事件介绍" class="headerlink" title="1. Redis事件介绍"></a>1. Redis事件介绍</h2><p>Redis服务器是一个事件驱动程序。下面先来简单介绍什么是事件驱动。</p>
<p>所谓事件驱动，就是当你输入一条命令并且按下回车，然后消息被组装成Redis协议的格式发送给Redis服务器，这就会产生一个事件，Redis服务器会接收该命令，处理该命令和发送回复，而当你没有与服务器进行交互时，那么服务器就会处于阻塞等待状态，会让出CPU从而进入睡眠状态，当事件触发时，就会被操作系统唤醒。事件驱动使CPU更高效的利用。</p>
<p>事件驱动是一种概括和抽象，也可以称为I/O多路复用（I/O multiplexing），它的实现方式各个系统都不同，一会会说到Redis的方式。</p>
<p>在redis服务器中，处理了两类事件：</p>
<ul>
<li>文件事件（file event）：Redis服务器通过套接字于客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。</li>
<li>时间事件（time event）：Redis服务器的一些操作需要在给定的事件点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h2 id="2-事件的抽象"><a href="#2-事件的抽象" class="headerlink" title="2. 事件的抽象"></a>2. 事件的抽象</h2><p>Redis将这两个事件分别抽象成一个数据结构来管理。</p>
<h3 id="2-1-文件事件结构"><a href="#2-1-文件事件结构" class="headerlink" title="2.1 文件事件结构"></a>2.1 文件事件结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* File event structure */</div><div class="line">typedef struct aeFileEvent &#123;</div><div class="line">    // 文件时间类型：AE_NONE，AE_READABLE，AE_WRITABLE</div><div class="line">    int mask; /* one of AE_(READABLE|WRITABLE) */</div><div class="line">    // 可读处理函数</div><div class="line">    aeFileProc *rfileProc;</div><div class="line">    // 可写处理函数</div><div class="line">    aeFileProc *wfileProc;</div><div class="line">    // 客户端传入的数据</div><div class="line">    void *clientData;</div><div class="line">&#125; aeFileEvent;  //文件事件</div></pre></td></tr></table></figure>
<p>其中rfileProc和wfileProc成员分别为两个函数指针，他们的原型为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask)</div></pre></td></tr></table></figure></p>
<p>这个函数是回调函数，如果当前文件事件所指定的事件类型发生时，则会调用对应的回调函数处理该事件。函数指针与回调函数详解</p>
<p>当事件就绪时，我们需要知道文件事件的文件描述符还有事件类型才能锁定该事件，因此定义了aeFiredEvent结构统一管理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* A fired event */</div><div class="line">typedef struct aeFiredEvent &#123;</div><div class="line">    // 就绪事件的文件描述符</div><div class="line">    int fd;</div><div class="line">    // 就绪事件类型：AE_NONE，AE_READABLE，AE_WRITABLE</div><div class="line">    int mask;</div><div class="line">&#125; aeFiredEvent; //就绪事件</div></pre></td></tr></table></figure></p>
<h3 id="2-2-时间事件结构"><a href="#2-2-时间事件结构" class="headerlink" title="2.2 时间事件结构"></a>2.2 时间事件结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* Time event structure */</div><div class="line">typedef struct aeTimeEvent &#123;</div><div class="line">    // 时间事件的id</div><div class="line">    long long id; /* time event identifier. */</div><div class="line">    // 时间事件到达的时间的秒数</div><div class="line">    long when_sec; /* seconds */</div><div class="line">    // 时间事件到达的时间的毫秒数</div><div class="line">    long when_ms; /* milliseconds */</div><div class="line">    // 时间事件处理函数</div><div class="line">    aeTimeProc *timeProc;</div><div class="line">    // 时间事件终结函数</div><div class="line">    aeEventFinalizerProc *finalizerProc;</div><div class="line">    // 客户端传入的数据</div><div class="line">    void *clientData;</div><div class="line">    // 指向下一个时间事件</div><div class="line">    struct aeTimeEvent *next;</div><div class="line">&#125; aeTimeEvent;  //时间事件</div></pre></td></tr></table></figure>
<p>从这个结构中可以看出，时间事件表是一个链表，因为它有一个next指针域，指向下一个时间事件。</p>
<p>和文件事件一样，当时间事件所指定的事件发生时，也会调用对应的回调函数，结构成员timeProc和finalizerProc都是回调函数，函数原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);</div><div class="line">typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);</div></pre></td></tr></table></figure></p>
<p>虽然对文件事件和时间事件都做了抽象，Redis仍然需要对事件做整体抽象，于是定义了aeEventLoop结构。</p>
<h3 id="2-3-事件状态结构"><a href="#2-3-事件状态结构" class="headerlink" title="2.3 事件状态结构"></a>2.3 事件状态结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* State of an event based program */</div><div class="line">typedef struct aeEventLoop &#123;</div><div class="line">    // 当前已注册的最大的文件描述符</div><div class="line">    int maxfd;   /* highest file descriptor currently registered */</div><div class="line">    // 文件描述符监听集合的大小</div><div class="line">    int setsize; /* max number of file descriptors tracked */</div><div class="line">    // 下一个时间事件的ID</div><div class="line">    long long timeEventNextId;</div><div class="line">    // 最后一次执行事件的时间</div><div class="line">    time_t lastTime;     /* Used to detect system clock skew */</div><div class="line">    // 注册的文件事件表</div><div class="line">    aeFileEvent *events; /* Registered events */</div><div class="line">    // 已就绪的文件事件表</div><div class="line">    aeFiredEvent *fired; /* Fired events */</div><div class="line">    // 时间事件的头节点指针</div><div class="line">    aeTimeEvent *timeEventHead;</div><div class="line">    // 事件处理开关</div><div class="line">    int stop;</div><div class="line">    // 多路复用库的事件状态数据</div><div class="line">    void *apidata; /* This is used for polling API specific data */</div><div class="line">    // 执行处理事件之前的函数</div><div class="line">    aeBeforeSleepProc *beforesleep;</div><div class="line">&#125; aeEventLoop;  //事件轮询的状态结构</div></pre></td></tr></table></figure>
<p>aeEventLoop结构保存了一个void *类型的万能指针apidata，是用来保存轮询事件的状态的，也就是保存底层调用的多路复用库的事件状态，关于Redis的多路复用库的选择，Redis包装了常见的select epoll evport kqueue，他们在编译阶段，根据不同的系统选择性能最高的一个多路复用库作为Redis的多路复用程序的实现，而且所有库实现的接口名称都是相同的，因此Redis多路复用程序底层实现是可以互换的。具体选择库的源码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// IO复用的选择，性能依次下降，Linux支持 &quot;ae_epoll.c&quot; 和 &quot;ae_select.c&quot;</div><div class="line">#ifdef HAVE_EVPORT</div><div class="line">#include &quot;ae_evport.c&quot;</div><div class="line">#else</div><div class="line">    #ifdef HAVE_EPOLL</div><div class="line">    #include &quot;ae_epoll.c&quot;</div><div class="line">    #else</div><div class="line">        #ifdef HAVE_KQUEUE</div><div class="line">        #include &quot;ae_kqueue.c&quot;</div><div class="line">        #else</div><div class="line">        #include &quot;ae_select.c&quot;</div><div class="line">        #endif</div><div class="line">    #endif</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>也可以通过Redis客户端的命令来查看当前选择的多路复用库，INFO server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; INFO server</div><div class="line"># Server</div><div class="line">……</div><div class="line">multiplexing_api:epoll</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>那么，既然知道了多路复用库的选择，那么我们来查看一下apidata保存的epoll模型的事件状态结构：ae_epoll.c文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct aeApiState &#123;</div><div class="line">    // epoll事件的文件描述符</div><div class="line">    int epfd;</div><div class="line">    // 事件表</div><div class="line">    struct epoll_event *events;</div><div class="line">&#125; aeApiState;   //事件的状态</div></pre></td></tr></table></figure></p>
<p>epoll模型的struct epoll_event的结构中定义这自己的事件类型，例如EPOLLIN POLLOUT等等，但是Redis的文件事件结构aeFileEvent中也在mask中定义了自己的事件类型，例如：AE_READABLE AE_WRITABLE等，于是，就需要实现一个中间层将两者的事件类型相联系起来，这也就是之前提到的ae_epoll.c文件中实现的相同的API，我们列出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 创建一个epoll实例，保存到eventLoop中</div><div class="line">static int aeApiCreate(aeEventLoop *eventLoop)</div><div class="line">// 调整事件表的大小</div><div class="line">static int aeApiResize(aeEventLoop *eventLoop, int setsize)  </div><div class="line">// 释放epoll实例和事件表空间</div><div class="line">static void aeApiFree(aeEventLoop *eventLoop)</div><div class="line">// 在epfd标识的事件表上注册fd的事件</div><div class="line">static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask)</div><div class="line">// 在epfd标识的事件表上注删除fd的事件</div><div class="line">static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask)</div><div class="line">// 等待所监听文件描述符上有事件发生</div><div class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp)</div><div class="line">// 返回正在使用的IO多路复用库的名字</div><div class="line">static char *aeApiName(void)</div></pre></td></tr></table></figure></p>
<p>这些API都是调用相应的底层多路复用库来将Redis事件状态结构aeEventLoop所关联，就是将epoll的底层函数封装起来，Redis实现事件时，只需调用这些接口即可。我们查看两个重要的函数的源码，看看是如何实现的</p>
<ul>
<li><p>向Redis事件状态结构aeEventLoop的事件表event注册一个事件，对应的是epoll_ctl函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 在epfd标识的事件表上注册fd的事件</div><div class="line">static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) &#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    struct epoll_event ee = &#123;0&#125;; /* avoid valgrind warning */</div><div class="line">    /* If the fd was already monitored for some event, we need a MOD</div><div class="line">     * operation. Otherwise we need an ADD operation. */</div><div class="line">    // EPOLL_CTL_ADD，向epfd注册fd的上的event</div><div class="line">    // EPOLL_CTL_MOD，修改fd已注册的event</div><div class="line">    // #define AE_NONE 0           //未设置</div><div class="line">    // #define AE_READABLE 1       //事件可读</div><div class="line">    // #define AE_WRITABLE 2       //事件可写</div><div class="line">    // 判断fd事件的操作，如果没有设置事件，则进行关联mask类型事件，否则进行修改</div><div class="line">    int op = eventLoop-&gt;events[fd].mask == AE_NONE ?</div><div class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</div><div class="line"></div><div class="line">    // struct epoll_event &#123;</div><div class="line">    //      uint32_t     events;      /* Epoll events */</div><div class="line">    //      epoll_data_t data;        /* User data variable */</div><div class="line">    // &#125;;</div><div class="line">    ee.events = 0;</div><div class="line">    // 如果是修改事件，合并之前的事件类型</div><div class="line">    mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */</div><div class="line">    // 根据mask映射epoll的事件类型</div><div class="line">    if (mask &amp; AE_READABLE) ee.events |= EPOLLIN;   //读事件</div><div class="line">    if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;  //写事件</div><div class="line">    ee.data.fd = fd;    //设置事件所从属的目标文件描述符</div><div class="line">    // 将ee事件注册到epoll中</div><div class="line">    if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>等待所监听文件描述符上有事件发生，对应着底层epoll_wait函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 等待所监听文件描述符上有事件发生</div><div class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    int retval, numevents = 0;</div><div class="line"></div><div class="line">    // 监听事件表上是否有事件发生</div><div class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</div><div class="line">            tvp ? (tvp-&gt;tv_sec*1000 + tvp-&gt;tv_usec/1000) : -1);</div><div class="line">    // 至少有一个就绪的事件</div><div class="line">    if (retval &gt; 0) &#123;</div><div class="line">        int j;</div><div class="line"></div><div class="line">        numevents = retval;</div><div class="line">        // 遍历就绪的事件表，将其加入到eventLoop的就绪事件表中</div><div class="line">        for (j = 0; j &lt; numevents; j++) &#123;</div><div class="line">            int mask = 0;</div><div class="line">            struct epoll_event *e = state-&gt;events+j;</div><div class="line"></div><div class="line">            // 根据就绪的事件类型，设置mask</div><div class="line">            if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</div><div class="line">            // 添加到就绪事件表中</div><div class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</div><div class="line">            eventLoop-&gt;fired[j].mask = mask;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 返回就绪的事件个数</div><div class="line">    return numevents;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-事件的源码实现"><a href="#3-事件的源码实现" class="headerlink" title="3. 事件的源码实现"></a>3. 事件的源码实现</h2><p>Redis事件的源码全部定义在ae.c文件中，我们从事件的主函数aeMain说起，一步一步深入剖析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 事件轮询的主函数</div><div class="line">void aeMain(aeEventLoop *eventLoop) &#123;</div><div class="line">    eventLoop-&gt;stop = 0;</div><div class="line">    // 一直处理事件</div><div class="line">    while (!eventLoop-&gt;stop) &#123;</div><div class="line">        // 执行处理事件之前的函数</div><div class="line">        if (eventLoop-&gt;beforesleep != NULL)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line">        //处理到时的时间事件和就绪的文件事件</div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个事件的主函数aeMain很清楚的可以看到，如果服务器一直处理事件，那么就是一个死循环，而一个最典型的事件驱动，就是一个死循环。调用处理事件的函数aeProcessEvents，他们参数是一个事件状态结构aeEventLoop和AE_ALL_EVENTS，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">// 处理到时的时间事件和就绪的文件事件</div><div class="line">// 函数返回执行的事件个数</div><div class="line">int aeProcessEvents(aeEventLoop *eventLoop, int flags)</div><div class="line">&#123;</div><div class="line">    int processed = 0, numevents;</div><div class="line"></div><div class="line">    /* Nothing to do? return ASAP */</div><div class="line">    // 如果什么事件都没有设置则直接返回</div><div class="line">    if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0;</div><div class="line"></div><div class="line">    /* Note that we want call select() even if there are no</div><div class="line">     * file events to process as long as we want to process time</div><div class="line">     * events, in order to sleep until the next time event is ready</div><div class="line">     * to fire. */</div><div class="line">    // 请注意，既然我们要处理时间事件，即使没有要处理的文件事件，我们仍要调用select（），以便在下一次事件准备启动之前进行休眠</div><div class="line"></div><div class="line">    // 当前还没有要处理的文件事件，或者设置了时间时间但是没有设置不阻塞标识</div><div class="line">    if (eventLoop-&gt;maxfd != -1 ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        int j;</div><div class="line">        aeTimeEvent *shortest = NULL;</div><div class="line">        struct timeval tv, *tvp;</div><div class="line"></div><div class="line">        // 如果设置了时间事件而没有设置不阻塞标识</div><div class="line">        if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            // 获取最近到时的时间事件</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        // 获取到了最早到时的时间事件</div><div class="line">        if (shortest) &#123;</div><div class="line">            long now_sec, now_ms;</div><div class="line">            // 获取当前时间</div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line"></div><div class="line">            /* How many milliseconds we need to wait for the next</div><div class="line">             * time event to fire? */</div><div class="line">            // 等待该时间事件到时所需要的时长</div><div class="line">            long long ms =</div><div class="line">                (shortest-&gt;when_sec - now_sec)*1000 +</div><div class="line">                shortest-&gt;when_ms - now_ms;</div><div class="line"></div><div class="line">            // 如果没到时</div><div class="line">            if (ms &gt; 0) &#123;</div><div class="line">                // 保存时长到tvp中</div><div class="line">                tvp-&gt;tv_sec = ms/1000;</div><div class="line">                tvp-&gt;tv_usec = (ms % 1000)*1000;</div><div class="line">            // 如果已经到时，则将tvp的时间设置为0</div><div class="line">            &#125; else &#123;</div><div class="line">                tvp-&gt;tv_sec = 0;</div><div class="line">                tvp-&gt;tv_usec = 0;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        // 没有获取到了最早到时的时间事件，时间事件链表为空</div><div class="line">        &#125; else &#123;</div><div class="line">            /* If we have to check for events but need to return</div><div class="line">             * ASAP because of AE_DONT_WAIT we need to set the timeout</div><div class="line">             * to zero */</div><div class="line">            // 如果设置了不阻塞标识</div><div class="line">            if (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                // 将tvp的时间设置为0，就不会阻塞</div><div class="line">                tv.tv_sec = tv.tv_usec = 0;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 阻塞到第一个时间事件的到来</div><div class="line">                /* Otherwise we can block */</div><div class="line">                tvp = NULL; /* wait forever */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 等待所监听文件描述符上有事件发生</div><div class="line">        // 如果tvp为NULL，则阻塞在此，否则等待tvp设置阻塞的时间，就会有时间事件到时</div><div class="line">        // 返回了就绪文件事件的个数</div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        // 遍历就绪文件事件表</div><div class="line">        for (j = 0; j &lt; numevents; j++) &#123;</div><div class="line">            // 获取就绪文件事件的地址</div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line">            // 获取就绪文件事件的类型，文件描述符</div><div class="line">            int mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            int fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            int rfired = 0;</div><div class="line"></div><div class="line">        /* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</div><div class="line">             * event removed an element that fired and we still didn&apos;t</div><div class="line">             * processed, so we check if the event is still valid. */</div><div class="line">            // 如果是文件可读事件发生</div><div class="line">            if (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                // 设置读事件标识 且 调用读事件方法处理读事件</div><div class="line">                rfired = 1;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            // 如果是文件可写事件发生</div><div class="line">            if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line">                // 读写事件的执行发法不同，则执行写事件，避免重复执行相同的方法</div><div class="line">                if (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            processed++;    //执行的事件次数加1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /* Check time events */</div><div class="line">    // 执行时间事件</div><div class="line">    if (flags &amp; AE_TIME_EVENTS)</div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    return processed; /* return the number of processed file/time events */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>刚才提到该函数的一个参数是AE_ALL_EVENTS，他的定义在ae.h中，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define AE_FILE_EVENTS 1                                //文件事件</div><div class="line">#define AE_TIME_EVENTS 2                                //时间事件</div><div class="line">#define AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)   //文件和时间事件</div><div class="line">#define AE_DONT_WAIT 4                                  //不阻塞等待标识</div></pre></td></tr></table></figure></p>
<p>很明显，flags是AE_FILE_EVENTS和AE_TIME_EVENTS或的结果，他们的含义如下：</p>
<ul>
<li>如果flags = 0，函数什么都不做，直接返回</li>
<li>如果flags设置了 AE_ALL_EVENTS ，则执行所有类型的事件</li>
<li>如果flags设置了 AE_FILE_EVENTS ，则执行文件事件</li>
<li>如果flags设置了 AE_TIME_EVENTS ，则执行时间事件</li>
<li>如果flags设置了 AE_DONT_WAIT ，那么函数处理完事件后直接返回，不阻塞等待<br>Redis服务器在没有被事件触发时，就会阻塞等待，因为没有设置AE_DONT_WAIT标识。但是他不会一直的死等待，等待文件事件的到来，因为他还要处理时间时间，因此，在调用aeApiPoll进行监听之前，先从时间事件表中获取一个最近到达的时间时间，根据要等待的时间构建一个struct timeval tv, *tvp结构的变量，这个变量保存着服务器阻塞等待文件事件的最长时间，一旦时间到达而没有触发文件事件，aeApiPoll函数就会停止阻塞，进而调用processTimeEvents处理时间事件，因为Redis服务器设定一个对自身资源和状态进行检查的周期性检查的时间事件，而该函数就是timeProc所指向的回调函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果在阻塞等待的最长时间之间，触发了文件事件，就会先执行文件事件，后执行时间事件，因此处理时间事件通常比预设的会晚一点。</p>
<p>而执行文件事件rfileProc和wfileProc也是调用了回调函数，Redis将文件事件的处理分为了好几种，用于处理不同的网络通信需求，下面列出回调函数的原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask)</div></pre></td></tr></table></figure></p>
<ul>
<li>acceptTcpHandler：用于accept client的connect。</li>
<li>acceptUnixHandler：用于acceptclient的本地connect。</li>
<li>sendReplyToClient：用于向client发送命令回复。</li>
<li>readQueryFromClient：用于读入client发送的请求。<br>接下来，我们查看获取最快达到的时间事件的函数aeSearchNearestTimer实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 寻找第一个快到时的时间事件</div><div class="line">// 这个操作是有用的知道有多少时间可以选择该事件设置为不用推迟任何事件的睡眠中。</div><div class="line">// 如果事件链表没有时间将返回NULL。</div><div class="line">static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)</div><div class="line">&#123;</div><div class="line">    // 时间事件头节点地址</div><div class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</div><div class="line">    aeTimeEvent *nearest = NULL;</div><div class="line"></div><div class="line">    // 遍历所有的时间事件</div><div class="line">    while(te) &#123;</div><div class="line">        // 寻找第一个快到时的时间事件，保存到nearest中</div><div class="line">        if (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</div><div class="line">                (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</div><div class="line">                 te-&gt;when_ms &lt; nearest-&gt;when_ms))</div><div class="line">            nearest = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    return nearest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数没什么，就是遍历链表，找到最小值。我们重点看执行时间事件的函数processTimeEvents实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">/* Process time events */</div><div class="line">// 执行时间事件</div><div class="line">static int processTimeEvents(aeEventLoop *eventLoop) &#123;</div><div class="line">    int processed = 0;</div><div class="line">    aeTimeEvent *te, *prev;</div><div class="line">    long long maxId;</div><div class="line">    time_t now = time(NULL);</div><div class="line"></div><div class="line">    // 这里尝试发现时间混乱的情况，上一次处理事件的时间比当前时间还要大</div><div class="line">    // 重置最近一次处理事件的时间</div><div class="line">    if (now &lt; eventLoop-&gt;lastTime) &#123;</div><div class="line">        te = eventLoop-&gt;timeEventHead;</div><div class="line">        while(te) &#123;</div><div class="line">            te-&gt;when_sec = 0;</div><div class="line">            te = te-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 设置上一次时间事件处理的时间为当前时间</div><div class="line">    eventLoop-&gt;lastTime = now;</div><div class="line"></div><div class="line">    prev = NULL;</div><div class="line">    te = eventLoop-&gt;timeEventHead;</div><div class="line">    maxId = eventLoop-&gt;timeEventNextId-1;   //当前时间事件表中的最大ID</div><div class="line">    // 遍历时间事件链表</div><div class="line">    while(te) &#123;</div><div class="line">        long now_sec, now_ms;</div><div class="line">        long long id;</div><div class="line"></div><div class="line">        /* Remove events scheduled for deletion. */</div><div class="line">        // 如果时间事件已被删除了</div><div class="line">        if (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</div><div class="line">            aeTimeEvent *next = te-&gt;next;</div><div class="line">            // 从事件链表中删除事件的节点</div><div class="line">            if (prev == NULL)</div><div class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</div><div class="line">            else</div><div class="line">                prev-&gt;next = te-&gt;next;</div><div class="line">            // 调用时间事件终结方法清楚该事件</div><div class="line">            if (te-&gt;finalizerProc)</div><div class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</div><div class="line">            zfree(te);</div><div class="line">            te = next;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 确保我们不处理在此迭代中由时间事件创建的时间事件。 请注意，此检查目前无效：我们总是在头节点添加新的计时器，但是如果我们更改实施细节，则该检查可能会再次有用：我们将其保留在未来的防御</div><div class="line">        if (te-&gt;id &gt; maxId) &#123;</div><div class="line">            te = te-&gt;next;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        // 获取当前时间</div><div class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">        // 找到已经到时的时间事件</div><div class="line">        if (now_sec &gt; te-&gt;when_sec ||</div><div class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</div><div class="line">        &#123;</div><div class="line">            int retval;</div><div class="line"></div><div class="line">            id = te-&gt;id;</div><div class="line">            // 调用时间事件处理方法</div><div class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</div><div class="line">            // 时间事件次数加1</div><div class="line">            processed++;</div><div class="line">            // 如果不是定时事件，则继续设置它的到时时间</div><div class="line">            if (retval != AE_NOMORE) &#123;</div><div class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</div><div class="line">            // 如果是定时时间，则retval为-1，则将其时间事件删除，惰性删除</div><div class="line">            &#125; else &#123;</div><div class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 更新前驱节点指针和后继节点指针</div><div class="line">        prev = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    return processed;   //返回执行事件的次数</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果时间事件不存在，则就调用finalizerProc指向的回调函数，删除当前的时间事件。如果存在，就调用timeProc指向的回调函数处理时间事件。Redis的时间事件分为两类</p>
<ul>
<li>定时事件：让一段程序在指定的时间后执行一次。</li>
<li>周期性事件：让一段程序每隔指定的时间后执行一次。<br>如果当前的时间事件是周期性，那么就会在将时间周期添加到周期事件的到时时间中。如果是定时事件，则将该时间事件删除。</li>
</ul>
<p>至此，Redis事件的实现就剖析完毕，但是事件的其他API，例如：创建事件，删除事件，调整事件表的大小等等都没有列出。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/08/redis-analysis-ziplist/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/redis-analysis-ziplist/" itemprop="url">
                  Redis源码剖析和注释（六）--- 压缩列表(ziplist)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-08T05:42:34+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>压缩列表(ziplist)是哈希键的底层实现之一。它是经过特殊编码的双向链表，和整数集合(intset)一样，是为了提高内存的存储效率而设计的。当保存的对象是小整数值，或者是长度较短的字符串，那么redis就会使用压缩列表来作为哈希键的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HMSET hash name mike age 28 sex male</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; HGETALL hash</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;mike&quot;</div><div class="line">3) &quot;age&quot;</div><div class="line">4) &quot;28&quot;</div><div class="line">5) &quot;sex&quot;</div><div class="line">6) &quot;male&quot;</div><div class="line">127.0.0.1:6379&gt; OBJECT ENCODING hash    //编码格式为ziplist</div><div class="line">&quot;ziplist&quot;</div></pre></td></tr></table></figure></p>
<p>注：redis 3.2以后，quicklist作为列表键的实现底层实现之一，代替了压缩列表。</p>
<p>通过命令来查看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; RPUSH list 1 2</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">127.0.0.1:6379&gt; OBJECT ENCODING list    //是quicklist而非ziplist</div><div class="line">&quot;quicklist&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-压缩列表的结构"><a href="#2-压缩列表的结构" class="headerlink" title="2. 压缩列表的结构"></a>2. 压缩列表的结构</h2><p>压缩列表是一系列特殊编码的连续内存块组成的顺序序列数据结构，可以包含任意多个节点(entry)，每一个节点可以保存一个字节数组或者一个整数值。</p>
<p>空间中的结构组成如下图所示：<br>[url01]</p>
<p>这里写图片描述</p>
<ul>
<li>zlbytes：占4个字节，记录整个压缩列表占用的内存字节数。</li>
<li>zltail_offset：占4个字节，记录压缩列表尾节点entryN距离压缩列表的起始地址的字节数。</li>
<li>zllength：占2个字节，记录了压缩列表的节点数量。</li>
<li>entry[1-N]：长度不定，保存数据。</li>
<li><p>zlend：占1个字节，保存一个常数255(0xFF)，标记压缩列表的末端。<br>redis没有提供一个结构体来保存压缩列表的信息，而是提供了一组宏来定位每个成员的地址，定义在ziplist.c文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">由于压缩列表对数据的信息访问都是以字节为单位的，所以参数zl的类型是char *类型的，因此对zl指针进行一系列的强制类型转换，以便对不用长度成员的访问。</div><div class="line">/* Utility macros */</div><div class="line">//  ziplist的成员宏定义</div><div class="line">//  (*((uint32_t*)(zl))) 先对char *类型的zl进行强制类型转换成uint32_t *类型，</div><div class="line">//  然后在用*运算符进行取内容运算，此时zl能访问的内存大小为4个字节。</div><div class="line"></div><div class="line">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</div><div class="line">//将zl定位到前4个字节的bytes成员，记录这整个压缩列表的内存字节数</div><div class="line"></div><div class="line">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</div><div class="line">//将zl定位到4字节到8字节的tail_offset成员，记录着压缩列表尾节点距离列表的起始地址的偏移字节量</div><div class="line"></div><div class="line">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</div><div class="line">//将zl定位到8字节到10字节的length成员，记录着压缩列表的节点数量</div><div class="line"></div><div class="line">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</div><div class="line">//压缩列表表头（以上三个属性）的大小10个字节</div><div class="line"></div><div class="line">#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</div><div class="line">//返回压缩列表首节点的地址</div><div class="line"></div><div class="line">#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</div><div class="line">//返回压缩列表尾节点的地址</div><div class="line"></div><div class="line">#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</div><div class="line">//返回end成员的地址，一个字节。</div></pre></td></tr></table></figure>
</li>
<li><p>intrev32ifbe()是封装的宏，用来根据主机的字节序按需要进行字节大小端的转换。</p>
</li>
</ul>
<h2 id="3-创建一个空的压缩列表"><a href="#3-创建一个空的压缩列表" class="headerlink" title="3. 创建一个空的压缩列表"></a>3. 创建一个空的压缩列表</h2><p>空的压缩列表就是没有节点的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* Create a new empty ziplist. */</div><div class="line">unsigned char *ziplistNew(void) &#123;   //创建并返回一个新的压缩列表</div><div class="line">    //ZIPLIST_HEADER_SIZE是压缩列表的表头大小，1字节是末端的end大小</div><div class="line">    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;</div><div class="line"></div><div class="line">    unsigned char *zl = zmalloc(bytes); //为表头和表尾end成员分配空间</div><div class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);    //将bytes成员初始化为bytes=11</div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);    //空列表的tail_offset成员为表头大小为10</div><div class="line">    ZIPLIST_LENGTH(zl) = 0;     //节点数量为0</div><div class="line">    zl[bytes-1] = ZIP_END;      //将表尾end成员设置成默认的255</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如下图所示：<br>[url02]</p>
<h2 id="4-压缩列表节点结构"><a href="#4-压缩列表节点结构" class="headerlink" title="4. 压缩列表节点结构"></a>4. 压缩列表节点结构</h2><p>redis对于压缩列表节点定义了一个zlentry的结构，用来管理节点的所有信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct zlentry &#123;</div><div class="line">    //prevrawlen 前驱节点的长度</div><div class="line">    //prevrawlensize 编码前驱节点的长度prevrawlen所需要的字节大小</div><div class="line">    unsigned int prevrawlensize, prevrawlen;</div><div class="line"></div><div class="line">    //len 当前节点值长度</div><div class="line">    //lensize 编码当前节点长度len所需的字节数</div><div class="line">    unsigned int lensize, len;</div><div class="line"></div><div class="line">    //当前节点header的大小 = lensize + prevrawlensize</div><div class="line">    unsigned int headersize;</div><div class="line"></div><div class="line">    //当前节点的编码格式</div><div class="line">    unsigned char encoding;</div><div class="line"></div><div class="line">    //指向当前节点的指针，以char *类型保存</div><div class="line">    unsigned char *p;</div><div class="line">&#125; zlentry;                  //压缩列表节点信息的结构</div></pre></td></tr></table></figure></p>
<p>虽然定义了这个结构体，但是根本就没有使用zlentry结构来作为压缩列表中用来存储数据节点中的结构，但是。因为，这个结构存小整数或短字符串实在是太浪费空间了。这个结构总共在32位机占用了28个字节(32位机)，在64位机占用了32个字节。这不符合压缩列表的设计目的：提高内存的利用率。因此，在redis中，并没有定义结构体来进行操作，也是定义了一些宏，压缩列表的节点真正的结构如下图所示：<br>[url03]</p>
<ul>
<li>prev_entry_len：记录前驱节点的长度。</li>
<li>encoding：记录当前节点的value成员的数据类型以及长度。</li>
<li>value：根据encoding来保存字节数组或整数。<br>接下来就分别讨论这三个成员：</li>
</ul>
<p>接下来就分别讨论这三个成员：</p>
<h3 id="4-1-prev-entry-len成员"><a href="#4-1-prev-entry-len成员" class="headerlink" title="4.1 prev_entry_len成员"></a>4.1 prev_entry_len成员</h3><p>prev_entry_len成员实际上就是zlentry结构中prevrawlensize,和prevrawlen这两个成员的压缩版。</p>
<p>prevrawlen：记录着上一个节点的长度。<br>prevrawlensize：记录编码prevrawlen值的所需的字节个数。<br>而这两个成员都是int类型，因此将两者压缩为一个成员prev_entry_len，而且分别对不同长度的前驱节点使用不同的字节数来表示。</p>
<p>当前驱节点的长度小于254字节，那么prev_entry_len使用1字节表示。<br>当前驱节点的长度大于等于255字节，那么prev_entry_len使用5个字节表示。并且用5个字节中的最高8位(最高1个字节)用 0xFE 标示prev_entry_len占用了5个字节，后四个字节才是真正保存前驱节点的长度值。<br>因为，对于访问的指针都是char 类型，它能访问的范围1个字节，如果这个字节的大小等于0xFE，那么就会继续访问四个字节来获取前驱节点的长度，如果该字节的大小小于0xFE，那么该字节就是要获取的前驱节点的长度。因此这样就使prev_entry_len同时具有了prevrawlen和prevrawlensize的功能，而且更加节约内存。*</p>
<p>redis中的代码这样描述，定义在ziplist.c中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#define ZIP_BIGLEN 254 </div><div class="line"></div><div class="line">//对前驱节点的长度len进行编码，并写入p中，如果p为空，则仅仅返回编码len所需要的字节数</div><div class="line">static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) &#123;</div><div class="line">    if (p == NULL) &#123;</div><div class="line">        return (len &lt; ZIP_BIGLEN) ? 1 : sizeof(len)+1;  //如果前驱节点的长度len字节小于254则返回1个字节，否则返回5个</div><div class="line">    &#125; else &#123;</div><div class="line">        if (len &lt; ZIP_BIGLEN) &#123; //如果前驱节点的长度len字节小于254</div><div class="line">            p[0] = len;         //将len保存在p[0]中</div><div class="line">            return 1;           //返回所需的编码数1字节</div><div class="line">        &#125; else &#123;                //前驱节点的长度len大于等于255字节</div><div class="line">            p[0] = ZIP_BIGLEN;  //添加5字节的标示，0xFE</div><div class="line">            memcpy(p+1,&amp;len,sizeof(len));   //从p+1的起始地址开始拷贝len，拷贝四个字节</div><div class="line">            memrev32ifbe(p+1);</div><div class="line">            return 1+sizeof(len);   //返回所需的编码数5字节</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-2-encoding成员"><a href="#4-2-encoding成员" class="headerlink" title="4.2 encoding成员"></a>4.2 encoding成员</h3><p>和prev_entry_len一样，encoding成员同样可以看做成zlentry结构中lensize和len的压缩版。</p>
<p>len：当前节点值长度。<br>lensize： 编码当前节点长度len所需的字节数。<br>同样的lensize和len都是占4个字节的，因此将两者压缩为一个成员encoding，只要encoding能够同时具有lensize和len成员的功能，而且对当前节点保存的是字节数组还是整数分别编码。</p>
<p>redis对字节数组和整数编码提供了一组宏定义，定义在ziplist.c中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Different encoding/length possibilities */</div><div class="line">#define ZIP_STR_MASK 0xc0               //1100 0000     字节数组的掩码</div><div class="line">#define ZIP_STR_06B (0 &lt;&lt; 6)            //0000 0000</div><div class="line">#define ZIP_STR_14B (1 &lt;&lt; 6)            //0100 0000</div><div class="line">#define ZIP_STR_32B (2 &lt;&lt; 6)            //1000 0000</div><div class="line"></div><div class="line">#define ZIP_INT_MASK 0x30               //0011 0000     整数的掩码</div><div class="line">#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)       //1100 0000</div><div class="line">#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)       //1101 0000</div><div class="line">#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)       //1110 0000</div><div class="line">#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)       //1111 0000</div><div class="line">#define ZIP_INT_8B 0xfe                 //1111 1110</div><div class="line"></div><div class="line">//掩码个功能就是区分一个encoding是字节数组编码还是整数编码</div><div class="line">//如果这个宏返回 1 就代表该enc是字节数组，如果是 0 就代表是整数的编码</div><div class="line">#define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/08/redis-analysis-intset/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/redis-analysis-intset/" itemprop="url">
                  Redis源码剖析和注释（五）--- 整数集合(intset)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-08T03:42:50+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>整数集合（intset）是集合键底层实现之一。集合键另一实现是值为空的散列表（hash table），虽然使用散列表对集合的加入删除元素，判断元素是否存在等等操作时间复杂度为O(1)，但是当存储的元素是整型且元素数目较少时，如果使用散列表存储，就会比较浪费内存，因此整数集合（intset）类型因为节约内存就存在。</p>
<p>散列表的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SADD set1 1 2 3</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; SADD set1 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SMEMBERS set1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">127.0.0.1:6379&gt; SISMEMBER set1 2</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SREM set1 1</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SMEMBERS set1</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-整数集合结构的实现"><a href="#2-整数集合结构的实现" class="headerlink" title="2. 整数集合结构的实现"></a>2. 整数集合结构的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis根目录下的intset.h文件</div><div class="line"></div><div class="line">typedef struct intset &#123;</div><div class="line">    uint32_t encoding;  //编码格式，有如下三种格式，初始值默认为INTSET_ENC_INT16</div><div class="line">    uint32_t length;    //集合元素数量</div><div class="line">    int8_t contents[];  //保存元素的数组，元素类型并不一定是ini8_t类型，柔性数组不占intset结构体大小，并且数组中的元素从小到大排列。</div><div class="line">&#125; intset;               //整数集合结构</div><div class="line"></div><div class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))   //16位，2个字节，表示范围-32,768~32,767</div><div class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))   //32位，4个字节，表示范围-2,147,483,648~2,147,483,647</div><div class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))   //64位，8个字节，表示范围-9,223,372,036,854,775</div></pre></td></tr></table></figure>
<h2 id="3-升级"><a href="#3-升级" class="headerlink" title="3. 升级"></a>3. 升级</h2><p>intset整数集合之所以有三种表示编码格式的宏定义，是因为根据存储的元素数值大小，能够选取一个最”合适”的类型存储，”合适”可以理解为：既能够表示元素的大小，又可以节省空间。</p>
<p>因此，当新添加的元素，例如：65535，超过当前集合编码格式所能表示的范围，就要进行升级操作。</p>
<p>我们使用刚才命令中的集合，它在结构如下图：<br>[url01]</p>
<h3 id="3-1获得新元素的编码格式"><a href="#3-1获得新元素的编码格式" class="headerlink" title="3.1获得新元素的编码格式"></a>3.1获得新元素的编码格式</h3><p>当前新元素要插入到集合中时，首先就要判获得新元素的编码格式，所以调用_intsetValueEncoding()来返回一个”适合”该元素的编码格式。65535的最”适合”的编码格式是INTSET_ENC_INT32。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;    //返回合适v的编码方式</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)             //如果超出32位所能表示数值的范围则返回INTSET_ENC_INT64</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)        //如果超出16位所能表示数值的范围则返回INTSET_ENC_INT32</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;                    //否则返回用16位表示的INTSET_ENC_INT16</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-调整内存空间"><a href="#3-2-调整内存空间" class="headerlink" title="3.2 调整内存空间"></a>3.2 调整内存空间</h3><p>当得到新元素的编码格式后，就要将集合中所有元素的编码格式都要变成升级后的编码格式，因此，需要调整集合数组contents的内存空间大小，调用intsetResize()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Resize the intset */</div><div class="line">static intset *intsetResize(intset *is, uint32_t len) &#123; //调整集合的内存空间大小</div><div class="line">    uint32_t size = len*intrev32ifbe(is-&gt;encoding);     //计算数组的大小</div><div class="line">    is = zrealloc(is,sizeof(intset)+size);  </div><div class="line">    //分配空间，如果新空间的大小比原来的空间大，那么数组的元素会被保留</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>intrev32ifbe()是一个宏定义，定义和实现在redis根目录下的endianconv.h和endianconv.c中根据主机字节序用来做整数大小端的转换。<br>已经获知65535的编码格式，因此调整内存空间的大小等于编码格式的大小乘以集合元素的个数。如果图：<br>[url02]<br>注意：encoding成员已经发生变化，但是length并没有更新。</li>
</ul>
<h3 id="3-3-根据编码格式设置对应的值"><a href="#3-3-根据编码格式设置对应的值" class="headerlink" title="3.3 根据编码格式设置对应的值"></a>3.3 根据编码格式设置对应的值</h3><p>调整好内存空间后就根据编码格式来设置集合元素的值和最后将新元素添加到集合中，都调用_intsetSet()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Set the value at pos, using the configured encoding. */</div><div class="line">//根据集合is设置的编码方式，设置下标为pos的值为value</div><div class="line">static void _intsetSet(intset *is, int pos, int64_t value) &#123;    </div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获取集合设置的编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;             //如果是64位</div><div class="line">        ((int64_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev64ifbe(((int64_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;      //如果是32位</div><div class="line">        ((int32_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev32ifbe(((int32_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else &#123;</div><div class="line">        ((int16_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev16ifbe(((int16_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>memrev16ifbe()是一个宏定义，定义和实现在redis根目录下的endianconv.h和endianconv.c中根据主机字节序用来做内存大小端的转换。</li>
</ul>
<p>将集合中原来的元素和新插入的元素以”合适”的编码格式INTSET_ENC_INT32写到数组中，顺序过程如下图：<br>[url03]</p>
<p>最后要更新length。</p>
<h3 id="3-4-升级实现源码"><a href="#3-4-升级实现源码" class="headerlink" title="3.4 升级实现源码"></a>3.4 升级实现源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123; //根据value的编码方式，对整数集合is的编码格式升级</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);    //当前集合的编码方式</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);   //得到value合适的编码方式</div><div class="line">    int length = intrev32ifbe(is-&gt;length);          //集合元素数量</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;                //如果value小于0，则要将value添加到数组最前端，因此为移动1个编码长度</div><div class="line">    //集合的编码格式要升级，也就是内存增大</div><div class="line">    //因为 value 的编码比集合原有的其他元素的编码都要大，所以value如果是负数，就是最小值，如果是正数则是最大值</div><div class="line">    //索引value要么放在数组集合的最前端，要么最后端，根据prepend判断</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);    //更新集合is的编码方式</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //根据新的编码方式重新设置内存空间大小</div><div class="line"></div><div class="line">    /* Upgrade back-to-front so we don&apos;t overwrite values.</div><div class="line">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</div><div class="line">     * space at either the beginning or the end of the intset. */</div><div class="line">    //_intsetGetEncoded()得到下标为length的值</div><div class="line">    //_intsetSet设置下标为prepend+length的值为_intsetGetEncoded返回的值</div><div class="line">    //但是，编码格式已经发生改变，数组元素没变但是内存大小改变</div><div class="line">    while(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)    //value是负数，要放在最前端</div><div class="line">        _intsetSet(is,0,value); //设置下标为0的值为value</div><div class="line">    else</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);  //value为正数，设置最末尾+1的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //数组元素加1</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-5-升级的特点"><a href="#3-5-升级的特点" class="headerlink" title="3.5 升级的特点"></a>3.5 升级的特点</h3><ul>
<li>提升灵活性：因为C语言是静态类型的语言，通常在在数组中只是用一种类型保存数据，例如，要么只用int16_t类型，要么只用int32_t类型。通过自动升级底层数组来适应不同类型的新元素，不必担心类型的错误。</li>
<li>节约内存：整数集合既可以让集合保存三种不同类型的值，又可以确保升级操作只在有需要的时候进行，这样就节省了内存。</li>
<li>不支持降级：一旦对数组进行升级，编码就会一直保存升级后的状态。</li>
</ul>
<h2 id="4-整数集合的其他操作"><a href="#4-整数集合的其他操作" class="headerlink" title="4.整数集合的其他操作"></a>4.整数集合的其他操作</h2><p>源代码注释下载：redis源码注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div></pre></td><td class="code"><pre><div class="line">intset *intsetNew(void);    //创建一个空集合</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success);//将value添加到is集合中，如果成功success被设置为1否则为0</div><div class="line">intset *intsetRemove(intset *is, int64_t value, int *success);//从集合中删除value，删除成功success设置为1，失败为0</div><div class="line">uint8_t intsetFind(intset *is, int64_t value);//返回1表示value是集合中的元素，否则返回0</div><div class="line">int64_t intsetRandom(intset *is);//随机返回一个元素</div><div class="line">uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);//获得下标为pos的值并保存在value中</div><div class="line">uint32_t intsetLen(intset *is);//返回集合的元素个数</div><div class="line">size_t intsetBlobLen(intset *is);//返回集合所占用的字节总量</div><div class="line"></div><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;    //返回合适v的编码方式</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)         //如果超出32位所能表示数值的范围则返回INTSET_ENC_INT64</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)    //如果超出16位所能表示数值的范围则返回INTSET_ENC_INT32</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;                //返回用16位表示的INTSET_ENC_INT16</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return the value at pos, given an encoding. */</div><div class="line">static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) &#123;    //根据编码方式enc，返回在集合is中下标为pos的元素</div><div class="line">    int64_t v64;</div><div class="line">    int32_t v32;</div><div class="line">    int16_t v16;</div><div class="line"></div><div class="line">    if (enc == INTSET_ENC_INT64) &#123;  //64位编码</div><div class="line">        memcpy(&amp;v64,((int64_t*)is-&gt;contents)+pos,sizeof(v64));  //从下标pos开始的内存空间拷贝64bit的数据到v64</div><div class="line">        memrev64ifbe(&amp;v64); //如果是大端序，就会转换成小端序</div><div class="line">        return v64;</div><div class="line">    &#125; else if (enc == INTSET_ENC_INT32) &#123;//32位编码</div><div class="line">        memcpy(&amp;v32,((int32_t*)is-&gt;contents)+pos,sizeof(v32));//从下标pos开始的内存空间拷贝32bit的数据到v32</div><div class="line">        memrev32ifbe(&amp;v32); //32位大小端转换</div><div class="line">        return v32;</div><div class="line">    &#125; else &#123;//16位编码</div><div class="line">        memcpy(&amp;v16,((int16_t*)is-&gt;contents)+pos,sizeof(v16));//从下标pos开始的内存空间拷贝16bit的数据到v16</div><div class="line">        memrev16ifbe(&amp;v16); //16位大小端转换</div><div class="line">        return v16;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return the value at pos, using the configured encoding. */</div><div class="line">static int64_t _intsetGet(intset *is, int pos) &#123;    //根据集合is设置的编码方式，返回下标为pos的值</div><div class="line">    return _intsetGetEncoded(is,pos,intrev32ifbe(is-&gt;encoding));</div><div class="line">    //intrev32ifbe()函数返回参数的编码格式并且根据需求转换大小端</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Set the value at pos, using the configured encoding. */</div><div class="line">static void _intsetSet(intset *is, int pos, int64_t value) &#123;    //根据集合is设置的编码方式，设置下标为pos的值为value</div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获取集合设置的编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;             //如果是64位</div><div class="line">        ((int64_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev64ifbe(((int64_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;      //如果是32位</div><div class="line">        ((int32_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev32ifbe(((int32_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else &#123;</div><div class="line">        ((int16_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev16ifbe(((int16_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Create an empty intset. */</div><div class="line">intset *intsetNew(void) &#123;           //创建一个空集合</div><div class="line">    intset *is = zmalloc(sizeof(intset));   //分配空间</div><div class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);  //设置编码方式</div><div class="line">    is-&gt;length = 0; //集合为空</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Resize the intset */</div><div class="line">static intset *intsetResize(intset *is, uint32_t len) &#123; //调整集合的内存空间大小</div><div class="line">    uint32_t size = len*intrev32ifbe(is-&gt;encoding); //计算数组的大小</div><div class="line">    is = zrealloc(is,sizeof(intset)+size);  //分配空间，如果新空间的大小比原来的空间大，那么数组的元素会被保留</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and</div><div class="line"> * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when</div><div class="line"> * the value is not present in the intset and sets &quot;pos&quot; to the position</div><div class="line"> * where &quot;value&quot; can be inserted. */</div><div class="line">//找到is集合中值为value的下标，返回1，并保存在pos中，没有找到返回0，并将pos设置为value可以插入到数组的位置</div><div class="line">static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) &#123;</div><div class="line">    int min = 0, max = intrev32ifbe(is-&gt;length)-1, mid = -1;</div><div class="line">    int64_t cur = -1;</div><div class="line"></div><div class="line">    /* The value can never be found when the set is empty */</div><div class="line">    if (intrev32ifbe(is-&gt;length) == 0) &#123;    //如果为空集合</div><div class="line">        if (pos) *pos = 0;                  //pos设置为0</div><div class="line">        return 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Check for the case where we know we cannot find the value,</div><div class="line">         * but do know the insert position. */</div><div class="line">        if (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)-1)) &#123;    //因为数组是有序的，如果value大于数组最大值</div><div class="line">            if (pos) *pos = intrev32ifbe(is-&gt;length);       //可以将pos设置为数组末尾</div><div class="line">            return 0;</div><div class="line">        &#125; else if (value &lt; _intsetGet(is,0)) &#123;  //如果小于数组的最小值</div><div class="line">            if (pos) *pos = 0;          //pos可以是下标为0的位置</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while(max &gt;= min) &#123; //有序集合中进行二分查找</div><div class="line">        mid = ((unsigned int)min + (unsigned int)max) &gt;&gt; 1; //(min+max)/2，找到中间数的下标</div><div class="line">        cur = _intsetGet(is,mid);   //等到下标为mid的值cur</div><div class="line">        if (value &gt; cur) &#123;  //value大于当前值cur</div><div class="line">            min = mid+1;    //后一半找</div><div class="line">        &#125; else if (value &lt; cur) &#123;   //value小于当前值cur</div><div class="line">            max = mid-1;    //前一半找</div><div class="line">        &#125; else &#123;</div><div class="line">            break;  //找到退出循环</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (value == cur) &#123; //确认找到</div><div class="line">        if (pos) *pos = mid;    //设置pos为找到的位置，返回1</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (pos) *pos = min;    //此时min和max相等，所以pos可以设置为min或max，返回0</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123; //根据value的编码方式，对整数集合is的编码格式升级</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);    //当前集合的编码方式</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);   //得到value合适的编码方式</div><div class="line">    int length = intrev32ifbe(is-&gt;length);          //集合元素数量</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;                //如果value小于0，则要将value添加到数组最前端，因此为移动1个编码长度</div><div class="line">    //集合的编码格式要升级，也就是内存增大</div><div class="line">    //因为 value 的编码比集合原有的其他元素的编码都要大，所以value如果是负数，就是最小值，如果是正数则是最大值</div><div class="line">    //索引value要么放在数组集合的最前端，要么最后端，根据prepend判断</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);    //更新集合is的编码方式</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //根据新的编码方式重新设置内存空间大小</div><div class="line"></div><div class="line">    /* Upgrade back-to-front so we don&apos;t overwrite values.</div><div class="line">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</div><div class="line">     * space at either the beginning or the end of the intset. */</div><div class="line">    //_intsetGetEncoded()得到下标为length的值</div><div class="line">    //_intsetSet设置下标为prepend+length的值为_intsetGetEncoded返回的值</div><div class="line">    //但是，编码格式已经发生改变，数组元素没变但是内存大小改变</div><div class="line">    while(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)    //value是负数，要放在最前端</div><div class="line">        _intsetSet(is,0,value); //设置下标为0的值为value</div><div class="line">    else</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);  //value为正数，设置最末尾+1的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //数组元素加1</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) &#123;    //向前或向后移动指定下标范围内的数组元素</div><div class="line">    void *src, *dst;</div><div class="line">    uint32_t bytes = intrev32ifbe(is-&gt;length)-from; //获得要移动的元素的个数</div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获得集合is的默认编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;         //判断不同的编码格式</div><div class="line">        src = (int64_t*)is-&gt;contents+from;      //获得要被移动范围的起始地址</div><div class="line">        dst = (int64_t*)is-&gt;contents+to;        //获得要被移动到的目的地址</div><div class="line">        bytes *= sizeof(int64_t);               //计算要移动多少个字节</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;</div><div class="line">        src = (int32_t*)is-&gt;contents+from;</div><div class="line">        dst = (int32_t*)is-&gt;contents+to;</div><div class="line">        bytes *= sizeof(int32_t);</div><div class="line">    &#125; else &#123;</div><div class="line">        src = (int16_t*)is-&gt;contents+from;</div><div class="line">        dst = (int16_t*)is-&gt;contents+to;</div><div class="line">        bytes *= sizeof(int16_t);</div><div class="line">    &#125;</div><div class="line">    memmove(dst,src,bytes); //从src开始移动bytes个字节到dst</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Insert an integer in the intset */</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123;//将value添加到is集合中，如果成功success被设置为1否则为0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 1;  //设置success默认为1</div><div class="line"></div><div class="line">    /* Upgrade encoding if necessary. If we need to upgrade, we know that</div><div class="line">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</div><div class="line">     * because it lies outside the range of existing values. */</div><div class="line">    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;  //如果value的编码类型大于集合的编码类型</div><div class="line">        /* This always succeeds, so we don&apos;t need to curry *success. */</div><div class="line">        return intsetUpgradeAndAdd(is,value);   //升级集合，并且将value加入集合，一定成功</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Abort if the value is already present in the set.</div><div class="line">         * This call will populate &quot;pos&quot; with the right position to insert</div><div class="line">         * the value when it cannot be found. */</div><div class="line">        if (intsetSearch(is,value,&amp;pos)) &#123;  //查找value，若果value已经存在，intsetSearch返回1,如果不存在，pos保存value可以插入的位置</div><div class="line">            if (success) *success = 0;  //value存在，success设置为0</div><div class="line">            return is;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //value在集合中不存在，且pos保存可以插入的位置</div><div class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //调整集合大小</div><div class="line">        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1);   //如果pos不是在数组末尾则要移动调整集合</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _intsetSet(is,pos,value);   //设置pos下标的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //集合节点数量加1</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Delete integer from intset */</div><div class="line">intset *intsetRemove(intset *is, int64_t value, int *success) &#123; //从集合中删除value，删除成功success设置为1，失败为0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 0;  //设置success默认为0</div><div class="line"></div><div class="line">    //如果value的编码格式小于集合的编码格式且value在集合中已存在，pos保存着下标</div><div class="line">    if (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">        uint32_t len = intrev32ifbe(is-&gt;length);    //备份当前集合元素数量</div><div class="line"></div><div class="line">        /* We know we can delete */</div><div class="line">        if (success) *success = 1;  //删除成功，设置success为1</div><div class="line"></div><div class="line">        /* Overwrite value with tail and update length */</div><div class="line">        if (pos &lt; (len-1)) intsetMoveTail(is,pos+1,pos);    //如果不是最后一个元素，则移动元素覆盖掉被删除的元素</div><div class="line">        is = intsetResize(is,len-1);    //缩小大小</div><div class="line">        is-&gt;length = intrev32ifbe(len-1);   //更新集合元素个数</div><div class="line">    &#125;</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Determine whether a value belongs to this set */</div><div class="line">uint8_t intsetFind(intset *is, int64_t value) &#123;     //返回1表示value是集合中的元素，否则返回0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    return valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL);</div><div class="line">    //如果value的编码格式小于集合的编码格式且value在集合中已存在，返回1，其中任何一个不成立返回0</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return random member */</div><div class="line">int64_t intsetRandom(intset *is) &#123;  //随机返回一个元素</div><div class="line">    return _intsetGet(is,rand()%intrev32ifbe(is-&gt;length));  //随机生成一个下标，返回该下标的值</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Sets the value to the value at the given position. When this position is</div><div class="line"> * out of range the function returns 0, when in range it returns 1. */</div><div class="line">uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) &#123;   //获得下标为pos的值并保存在value中</div><div class="line">    if (pos &lt; intrev32ifbe(is-&gt;length)) &#123;   //如果pos小于数组长度</div><div class="line">        *value = _intsetGet(is,pos);        //返回pos下标的值，保存在value中</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return intset length */</div><div class="line">uint32_t intsetLen(intset *is) &#123;    //返回集合的元素个数</div><div class="line">    return intrev32ifbe(is-&gt;length);    //返回length成员</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return intset blob size in bytes. */</div><div class="line">size_t intsetBlobLen(intset *is) &#123;  //返回集合所占用的字节总量</div><div class="line">    return sizeof(intset)+intrev32ifbe(is-&gt;length)*intrev32ifbe(is-&gt;encoding);  //编码格式×元素个数+集合大小</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/05/redis-analysis-skiplist/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/05/redis-analysis-skiplist/" itemprop="url">
                  Redis源码剖析和注释（六）--- 压缩列表(ziplist)
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-05T08:43:29+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-跳跃表（skiplist）介绍"><a href="#1-跳跃表（skiplist）介绍" class="headerlink" title="1. 跳跃表（skiplist）介绍"></a>1. 跳跃表（skiplist）介绍</h2><p>定义：跳跃表是一个有序链表，其中每个节点包含不定数量的链接，节点中的第i个链接构成的单向链表跳过含有少于i个链接的节点。</p>
<ul>
<li>跳跃表支持平均O(logN)，最坏O(N)</li>
<li>复杂度的节点查找，大部分情况下，跳跃表的效率可以和平衡树相媲美。</li>
<li>跳跃表在redis中当数据较多时作为有序集合键的实现方式之一。</li>
</ul>
<p>接下来，还是举个有序集合键的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; ZADD score 95.5 Mike 98 Li 96 Wang  //socre是一个有序集合键</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; ZRANGE score 0 -1 WITHSCORES//所有分数按从小到大排列，每一个成员都保存了一个分数</div><div class="line">1) &quot;Mike&quot;</div><div class="line">2) &quot;95.5&quot;</div><div class="line">3) &quot;Wang&quot;</div><div class="line">4) &quot;96&quot; </div><div class="line">5) &quot;Li&quot;</div><div class="line">6) &quot;98&quot;</div><div class="line">127.0.0.1:6379&gt; ZSCORE score Mike       //查询Mike的分值</div><div class="line">&quot;95.5&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-跳跃表的实现"><a href="#2-跳跃表的实现" class="headerlink" title="2. 跳跃表的实现"></a>2. 跳跃表的实现</h2><p>redis 3.0版本将跳跃表定义在redis.h文件中，而3.2版本定义在server.h文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">跳跃表节点 zskiplistNode</div><div class="line">typedef struct zskiplistNode &#123;</div><div class="line">    robj *obj;                          //保存成员对象的地址</div><div class="line">    double score;                       //分值</div><div class="line">    struct zskiplistNode *backward;     //后退指针</div><div class="line">    struct zskiplistLevel &#123;</div><div class="line">        struct zskiplistNode *forward;  //前进指针</div><div class="line">        unsigned int span;              //跨度</div><div class="line">    &#125; level[];                          //层级，柔型数组</div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">跳跃表表头 zskiplist（记录跳跃表信息）</div><div class="line">typedef struct zskiplist &#123;</div><div class="line">    struct zskiplistNode *header, *tail;//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</div><div class="line">    unsigned long length;       //跳跃表的长度或跳跃表节点数量计数器，除去第一个节点</div><div class="line">    int level;                  //跳跃表中节点的最大层数，除了第一个节点</div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h2 id="3-幂次定律"><a href="#3-幂次定律" class="headerlink" title="3. 幂次定律"></a>3. 幂次定律</h2><p>在redis中，返回一个随机层数值，随机算法所使用的幂次定律。</p>
<ul>
<li>含义是：如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律。</li>
<li>表现是：少数几个事件的发生频率占了整个发生频率的大部分， 而其余的大多数事件只占整个发生频率的一个小部分。</li>
</ul>
<p>在文件t_set.c中，zslRandomLevel函数的定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int zslRandomLevel(void) &#123;          //返回一个随机层数值</div><div class="line">    int level = 1;</div><div class="line">    //(random()&amp;0xFFFF)只保留低两个字节的位值，其他高位全部清零，所以该值范围为0到0xFFFF</div><div class="line">    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))  //ZSKIPLIST_P（0.25）所以level+1的概率为0.25</div><div class="line">        level += 1;         //返回一个1到ZSKIPLIST_MAXLEVEL（32）之间的值</div><div class="line">    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^32 elements */</div><div class="line">#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */</div></pre></td></tr></table></figure></p>
<p>算法性能分析：</p>
<p>层数至少为1，所以层数恰好等于1（不执行while循环体）的概率为 1−p.</p>
<ul>
<li>层数恰好等于2的概率为 p(1−p)（执行1次while循环体）。</li>
<li>层数恰好等于3的概率为 p^2(1−p)（执行2次while循环体）。</li>
<li>层数恰好等于4的概率为 p^3(1−p)（执行3次while循环体）。</li>
<li>层数恰好等于k的概率为 p^k−1(1−p)（执行k-1次while循环体）。（k &lt;= ZSKIPLIST_MAXLEVEL）<br>因此，一个节点的平均层数，或平均指针数为：</li>
</ul>
<p>​ 1×(1−p)+2p(1−p)+3p^2(1−p)+…+kp^(k−1)(1−p)<br>​ =1/(1−p)</p>
<p>因此，<br>当 p = 1/2 时，每个节点的平均指针为2；<br>当 p = 1/4 时，每个节点的平均指针为1.33；<br>而redis的概率 ZSKIPLIST_P 取值就为0.25，所以跳跃表的指针开销为1.33</p>
<h2 id="4-跳跃表与哈希表和平衡树的比较"><a href="#4-跳跃表与哈希表和平衡树的比较" class="headerlink" title="4. 跳跃表与哈希表和平衡树的比较"></a>4. 跳跃表与哈希表和平衡树的比较</h2><p>跳跃表和平衡树的元素都是有序排列，而哈希表不是有序的。因此在哈希表上的查找只能是单个key的查找，不适合做范围查找。</p>
<ul>
<li>跳跃表和平衡树做范围查找时，跳跃表算法简单，实现方便，而平衡树逻辑复杂。</li>
<li>查找单个key，跳跃表和平衡树的平均时间复杂度都为O(logN)，而哈希表的时间复杂度为O(1)。</li>
<li>跳跃表平均每个节点包含1.33个指针，而平衡树每个节点包含2个指针，更加节约内存。</li>
</ul>
<p>因此，在redis中实现有序集合的办法是：跳跃表+哈希表</p>
<ul>
<li>跳跃表元素有序，而且可以范围查找，且比平衡树简单。</li>
<li>哈希表查找单个key时间复杂度性能高。</li>
</ul>
<h2 id="5-跳跃表基本操作"><a href="#5-跳跃表基本操作" class="headerlink" title="5 跳跃表基本操作"></a>5 跳跃表基本操作</h2><p>redis关于跳跃表的API都定义在t_zset.c文件中。</p>
<h3 id="5-1-创建跳跃表-zslCreate"><a href="#5-1-创建跳跃表-zslCreate" class="headerlink" title="5.1 创建跳跃表 zslCreate()"></a>5.1 创建跳跃表 zslCreate()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">zskiplist *zslCreate(void) &#123;        //创建返回一个跳跃表 表头zskiplist</div><div class="line">    int j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    zsl = zmalloc(sizeof(*zsl));       //分配空间</div><div class="line">    zsl-&gt;level = 1;                     //设置默认层数</div><div class="line">    zsl-&gt;length = 0;                    //设置跳跃表长度</div><div class="line">    //创建一个层数为32，分数为0，没有obj的跳跃表头节点</div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</div><div class="line"></div><div class="line">    //跳跃表头节点初始化</div><div class="line">    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = NULL;   //将跳跃表头节点的所有前进指针forward设置为NULL</div><div class="line">        zsl-&gt;header-&gt;level[j].span = 0;         //将跳跃表头节点的所有跨度span设置为0</div><div class="line">    &#125;</div><div class="line">    zsl-&gt;header-&gt;backward = NULL;           //跳跃表头节点的后退指针backward置为NULL</div><div class="line"></div><div class="line">    zsl-&gt;tail = NULL;                       //表头指向跳跃表尾节点的指针置为NULL</div><div class="line">    return zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-2-插入节点-zslInsert"><a href="#5-2-插入节点-zslInsert" class="headerlink" title="5.2 插入节点 zslInsert()"></a>5.2 插入节点 zslInsert()</h3><p>//创建一个节点，分数为score，对象为obj，插入到zsl表头管理的跳跃表中，并返回新节点的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    int i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line"></div><div class="line">    x = zsl-&gt;header;            //获取跳跃表头结点地址，从头节点开始一层一层遍历</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;       //遍历头节点的每个level，从下标最大层减1到0</div><div class="line">        /* store rank that is crossed to reach the insert position */</div><div class="line">        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];  //更新rank[i]为i+1所跨越的节点数，但是最外一层为0</div><div class="line"></div><div class="line">        //这个while循环是查找的过程，沿着x指针遍历跳跃表，满足以下条件则要继续在当层往前走</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;       //当前层的前进指针不为空且</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||  //当前的要插入的score大于当前层的score或</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp; //当前score等于要插入的score且</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; 0))) &#123;//当前层的对象与要插入的obj不等</div><div class="line"></div><div class="line">            rank[i] += x-&gt;level[i].span;   //记录该层一共跨越了多少节点 加上 上一层遍历所跨越的节点数</div><div class="line">            x = x-&gt;level[i].forward;       //指向下一个节点</div><div class="line">        &#125;</div><div class="line">        //while循环跳出时，用update[i]记录第i层所遍历到的最后一个节点，遍历到i=0时，就要在该节点后要插入节点</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* we assume the key is not already inside, since we allow duplicated</div><div class="line">     * scores, and the re-insertion of score and redis object should never</div><div class="line">     * happen since the caller of zslInsert() should test in the hash table</div><div class="line">     * if the element is already inside or not.</div><div class="line">     * zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</div><div class="line">     * 所以这里不需要进一步进行检查，可以直接创建新元素。</div><div class="line">     */</div><div class="line"></div><div class="line">    level = zslRandomLevel();       //获得一个随机的层数</div><div class="line">    if (level &gt; zsl-&gt;level) &#123;       //如果大于当前所有节点最大的层数时</div><div class="line">        for (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = 0;            //将大于等于原来zsl-&gt;level层以上的rank[]设置为0</div><div class="line">            update[i] = zsl-&gt;header;    //将大于等于原来zsl-&gt;level层以上update[i]指向头结点</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length; //update[i]已经指向头结点，将第i层的跨度设置为length</div><div class="line">                                                    //length代表跳跃表的节点数量</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;     //更新表中的最大成数值</div><div class="line">    &#125;</div><div class="line">    x = zslCreateNode(level,score,obj);     //创建一个节点</div><div class="line">    for (i = 0; i &lt; level; i++) &#123;       //遍历每一层</div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;  //设置新节点的前进指针为查找时（while循环）每一层最后一个节点的的前进指针</div><div class="line">        update[i]-&gt;level[i].forward = x;//再把查找时每层的最后一个节点的前进指针设置为新创建的节点地址</div><div class="line"></div><div class="line">        /* update span covered by update[i] as x is inserted here */</div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);  //更新插入节点的跨度值</div><div class="line">        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;               //更新插入节点前一个节点的跨度值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* increment span for untouched levels */</div><div class="line">    for (i = level; i &lt; zsl-&gt;level; i++) &#123;  //如果插入节点的level小于原来的zsl-&gt;level才会执行</div><div class="line">        update[i]-&gt;level[i].span++;             //因为高度没有达到这些层，所以只需将查找时每层最后一个节点的值的跨度加1</div><div class="line">    &#125;</div><div class="line">    //设置插入节点的后退指针，就是查找时最下层的最后一个节点，该节点的地址记录在update[0]中</div><div class="line">    //如果插入在第二个节点，也就是头结点后的位置就将后退指针设置为NULL</div><div class="line">    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</div><div class="line"></div><div class="line">    if (x-&gt;level[0].forward)    //如果x节点不是最尾部的节点</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x;  //就将x节点后面的节点的后退节点设置成为x地址</div><div class="line">    else</div><div class="line">        zsl-&gt;tail = x;  //否则更新表头的tail指针，指向最尾部的节点x</div><div class="line">    zsl-&gt;length++;      //跳跃表节点计数器加1</div><div class="line">    return x;           //返回x地址</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-3-删除节点"><a href="#4-3-删除节点" class="headerlink" title="4.3 删除节点"></a>4.3 删除节点</h3><p>//被zslDelete, zslDeleteByScore and zslDeleteByRank使用的内部函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123;  //删除节点</div><div class="line">    int i;</div><div class="line"></div><div class="line">    //设置前进指针和跨度</div><div class="line">    for (i = 0; i &lt; zsl-&gt;level; i++) &#123;              //遍历下标为0到跳跃表最大层数-1的层</div><div class="line">        if (update[i]-&gt;level[i].forward == x) &#123;     //如果找到该节点</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;   //将前一个节点的跨度减1</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">            //前一个节点的前进指针指向被删除的节点的后一个节点，跳过该节点</div><div class="line">        &#125; else &#123;</div><div class="line">            update[i]-&gt;level[i].span -= 1;  //在第i层没找到，只将该层的最后一个节点的跨度减1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //设置后退指针</div><div class="line">    if (x-&gt;level[0].forward) &#123;      //如果被删除的前进节点不为空，后面还有节点</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;    //就将后面节点的后退指针指向被删除节点x的回退指针</div><div class="line">    &#125; else &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;       //否则直接将被删除的x节点的后退节点设置为表头的tail指针</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //更新跳跃表最大层数</div><div class="line">    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    zsl-&gt;length--;  //节点计数器减1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-4-获取节点排名"><a href="#4-4-获取节点排名" class="headerlink" title="4.4 获取节点排名"></a>4.4 获取节点排名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) &#123;   //查找score和o对象在跳跃表中的排位</div><div class="line">    zskiplistNode *x;</div><div class="line">    unsigned long rank = 0;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;        //遍历头结点的每一层</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||          //只要分值还小于给定的score或者</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;     //分值相等但是对象小于给定对象o</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= 0))) &#123;</div><div class="line">            rank += x-&gt;level[i].span;   //更新排位值</div><div class="line">            x = x-&gt;level[i].forward;    //指向下一个节点</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</div><div class="line">        //确保在第i层找到分值相同，且对象相同时才会返回排位值</div><div class="line">        if (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            return rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;   //没找到</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-5-区间操作"><a href="#4-5-区间操作" class="headerlink" title="4.5 区间操作"></a>4.5 区间操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) &#123; //返回第一个分数在range范围内的节点</div><div class="line">    zskiplistNode *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    /* If everything is out of range, return early. */</div><div class="line">    if (!zslIsInRange(zsl,range)) return NULL;  //如果不在范围内，则返回NULL，确保至少有一个节点符号range</div><div class="line"></div><div class="line">    //判断下限</div><div class="line">    x = zsl-&gt;header;//遍历跳跃表</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;//遍历每一层</div><div class="line">        /* Go forward while *OUT* of range. */</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;           //如果该层有下一个节点且</div><div class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))//当前节点的score还小于(小于等于)range的min</div><div class="line">                x = x-&gt;level[i].forward;        //继续指向下一个节点</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* This is an inner range, so the next node cannot be NULL. */</div><div class="line">    x = x-&gt;level[0].forward;    //找到目标节点</div><div class="line">    redisAssert(x != NULL);     //保证能找到</div><div class="line"></div><div class="line">    /* Check if score &lt;= max. */</div><div class="line">    //判断上限</div><div class="line">    if (!zslValueLteMax(x-&gt;score,range)) return NULL;   //该节点的分值如果比max还要大，就返回NULL</div><div class="line">    return x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) &#123;//返回最后一个分数在range范围内的节点</div><div class="line">    zskiplistNode *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    /* If everything is out of range, return early. */</div><div class="line">    if (!zslIsInRange(zsl,range)) return NULL;  //如果不在范围内，则返回NULL，确保至少有一个节点符号range</div><div class="line"></div><div class="line">    //判断上限</div><div class="line">    x = zsl-&gt;header;//遍历跳跃表</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;   //遍历每一层</div><div class="line">        /* Go forward while *IN* range. */</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;   //如果该层有下一个节点且</div><div class="line">            zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))//当前节点的score小于(小于等于)max</div><div class="line">                x = x-&gt;level[i].forward;    //继续指向下一个节点</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* This is an inner range, so this node cannot be NULL. */</div><div class="line">    redisAssert(x != NULL);//保证能找到</div><div class="line"></div><div class="line">    /* Check if score &gt;= min. */</div><div class="line">    //判断下限</div><div class="line">    if (!zslValueGteMin(x-&gt;score,range)) return NULL;   //如果找到的节点的分值比range的min还要小</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/02/04/redis-analysis-dict/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/04/redis-analysis-dict/" itemprop="url">
                  Redis源码剖析和注释（三）---字典结构
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-04T06:45:54+08:00">
                2018-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>字典又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。例如：redis中的所有key到value的映射，就是通过字典结构维护，还有hash类型的键值。</p>
<p>通过redis中的命令感受一下哈希键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HSET user name Mike </div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HSET user passwd 123456</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HSET user sex male</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HLEN user       //user就是一个包含3个键值对的哈希键</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; HGETALL user</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;Mike&quot;</div><div class="line">3) &quot;passwd&quot;</div><div class="line">4) &quot;123456&quot;</div><div class="line">5) &quot;sex&quot;</div><div class="line">6) &quot;male&quot;</div></pre></td></tr></table></figure></p>
<p>user键在底层实现就是一个字典，字典包含3个键值对。</p>
<h2 id="2-字典的实现"><a href="#2-字典的实现" class="headerlink" title="2. 字典的实现"></a>2. 字典的实现</h2><p>redis的字典是由哈希表实现的，一个哈希表有多个节点，每个节点保存一个键值对。</p>
<h3 id="2-1-哈希表"><a href="#2-1-哈希表" class="headerlink" title="2.1 哈希表"></a>2.1 哈希表</h3><p>redis中哈希表定义在dict.h/dictht中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht &#123; //哈希表</div><div class="line">    dictEntry **table;      //存放一个数组的地址，数组存放着哈希表节点dictEntry的地址。</div><div class="line">    unsigned long size;     //哈希表table的大小，初始化大小为4</div><div class="line">    unsigned long sizemask; //用于将哈希值映射到table的位置索引。它的值总是等于(size-1)。</div><div class="line">    unsigned long used;     //记录哈希表已有的节点（键值对）数量。</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure></p>
<h3 id="2-2-哈希表节点"><a href="#2-2-哈希表节点" class="headerlink" title="2.2 哈希表节点"></a>2.2 哈希表节点</h3><p>哈希表的table指向的数组存放这dictEntry类型的地址。也定义在dict.h/dictEntryt中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ypedef struct dictEntry &#123;</div><div class="line">    void *key;                  //key</div><div class="line">    union &#123;</div><div class="line">        void *val;</div><div class="line">        uint64_t u64;</div><div class="line">        int64_t s64;</div><div class="line">        double d;</div><div class="line">    &#125; v;                        //value</div><div class="line">    struct dictEntry *next;     //指向下一个hash节点，用来解决hash键冲突（collision）</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure></p>
<p>下图展现的就是通过链接法（chaining）来解决冲突的方法。<br>[url01]</p>
<h3 id="2-3-字典"><a href="#2-3-字典" class="headerlink" title="2.3 字典"></a>2.3 字典</h3><p>字典结构定义在dict.h/dict中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct dict &#123;</div><div class="line">    dictType *type;     //指向dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据。</div><div class="line">    void *privdata;     //私有数据，保存着dictType结构中函数的参数。</div><div class="line">    dictht ht[2];       //两张哈希表。</div><div class="line">    long rehashidx;     //rehash的标记，rehashidx==-1，表示没在进行rehash</div><div class="line">    int iterators;      //正在迭代的迭代器数量</div><div class="line">&#125; dict;</div></pre></td></tr></table></figure></p>
<p>dictType类型保存着 操作字典不同类型key和value的方法 的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictType &#123;</div><div class="line">    unsigned int (*hashFunction)(const void *key);      //计算hash值的函数</div><div class="line">    void *(*keyDup)(void *privdata, const void *key);   //复制key的函数</div><div class="line">    void *(*valDup)(void *privdata, const void *obj);   //复制value的函数</div><div class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);  //比较key的函数</div><div class="line">    void (*keyDestructor)(void *privdata, void *key);   //销毁key的析构函数</div><div class="line">    void (*valDestructor)(void *privdata, void *obj);   //销毁val的析构函数</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure></p>
<p>下图展现的就是刚才命令user哈希键所展现的内部结构：<br>[url02]</p>
<h2 id="3-哈希算法"><a href="#3-哈希算法" class="headerlink" title="3. 哈希算法"></a>3. 哈希算法</h2><p>Thomas Wang认为好的hash函数具有两个好的特点：</p>
<ul>
<li>hash函数是可逆的。</li>
<li>具有雪崩效应，意思是，输入值1bit位的变化会造成输出值1/2的bit位发生变化</li>
</ul>
<h3 id="3-1-计算int整型哈希值的哈希函数"><a href="#3-1-计算int整型哈希值的哈希函数" class="headerlink" title="3.1 计算int整型哈希值的哈希函数"></a>3.1 计算int整型哈希值的哈希函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">unsigned int dictIntHashFunction(unsigned int key)      //用于计算int整型哈希值的哈希函数</div><div class="line">&#123;</div><div class="line">    key += ~(key &lt;&lt; 15);</div><div class="line">    key ^=  (key &gt;&gt; 10);</div><div class="line">    key +=  (key &lt;&lt; 3);</div><div class="line">    key ^=  (key &gt;&gt; 6);</div><div class="line">    key += ~(key &lt;&lt; 11);</div><div class="line">    key ^=  (key &gt;&gt; 16);</div><div class="line">    return key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-MurmurHash2哈希算法"><a href="#3-2-MurmurHash2哈希算法" class="headerlink" title="3.2 MurmurHash2哈希算法"></a>3.2 MurmurHash2哈希算法</h3><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis用MurmurHash2算法来计算哈希值，能产生32-bit或64-bit哈希值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">unsigned int dictGenHashFunction(const void *key, int len) &#123;  //用于计算字符串的哈希值的哈希函数</div><div class="line">    /* &apos;m&apos; and &apos;r&apos; are mixing constants generated offline.</div><div class="line">     They&apos;re not really &apos;magic&apos;, they just happen to work well.  */</div><div class="line">    //m和r这两个值用于计算哈希值，只是因为效果好。</div><div class="line">    uint32_t seed = dict_hash_function_seed;</div><div class="line">    const uint32_t m = 0x5bd1e995;</div><div class="line">    const int r = 24;</div><div class="line"></div><div class="line">    /* Initialize the hash to a &apos;random&apos; value */</div><div class="line">    uint32_t h = seed ^ len;    //初始化</div><div class="line"></div><div class="line">    /* Mix 4 bytes at a time into the hash */</div><div class="line">    const unsigned char *data = (const unsigned char *)key;</div><div class="line"></div><div class="line">    //将字符串key每四个一组看成uint32_t类型，进行运算的到h</div><div class="line">    while(len &gt;= 4) &#123;</div><div class="line">        uint32_t k = *(uint32_t*)data;</div><div class="line"></div><div class="line">        k *= m;</div><div class="line">        k ^= k &gt;&gt; r;</div><div class="line">        k *= m;</div><div class="line"></div><div class="line">        h *= m;</div><div class="line">        h ^= k;</div><div class="line"></div><div class="line">        data += 4;</div><div class="line">        len -= 4;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Handle the last few bytes of the input array  */</div><div class="line">    switch(len) &#123;</div><div class="line">    case 3: h ^= data[2] &lt;&lt; 16;</div><div class="line">    case 2: h ^= data[1] &lt;&lt; 8;</div><div class="line">    case 1: h ^= data[0]; h *= m;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    /* Do a few final mixes of the hash to ensure the last few</div><div class="line">     * bytes are well-incorporated. */</div><div class="line">    h ^= h &gt;&gt; 13;</div><div class="line">    h *= m;</div><div class="line">    h ^= h &gt;&gt; 15;</div><div class="line"></div><div class="line">    return (unsigned int)h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-djb哈希算法"><a href="#3-3-djb哈希算法" class="headerlink" title="3.3 djb哈希算法"></a>3.3 djb哈希算法</h3><p>djb哈希算法，算法的思想是利用字符串中的ascii码值与一个随机seed，通过len次变换，得到最后的hash值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) &#123;   //用于计算字符串的哈希值的哈希函数</div><div class="line">    unsigned int hash = (unsigned int)dict_hash_function_seed;</div><div class="line"></div><div class="line">    while (len--)</div><div class="line">        hash = ((hash &lt;&lt; 5) + hash) + (tolower(*buf++)); /* hash * 33 + c */</div><div class="line">    return hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-rehash"><a href="#4-rehash" class="headerlink" title="4. rehash"></a>4. rehash</h2><p>当哈希表的大小不能满足需求，就可能会有两个或者以上数量的键被分配到了哈希表数组上的同一个索引上，于是就发生冲突（collision），在Redis中解决冲突的办法是链接法（separate chaining）。但是需要尽可能避免冲突，希望哈希表的负载因子（load factor），维持在一个合理的范围之内，就需要对哈希表进行扩展或收缩。</p>
<p>Redis对哈希表的rehash操作步骤如下：</p>
<ul>
<li>扩展或收缩 <ul>
<li>扩展：ht[1]的大小为第一个大于等于ht[0].used * 2的 2n 。</li>
<li>收缩：ht[1]的大小为第一个大于等于ht[0].used的 2n 。</li>
</ul>
</li>
<li>将所有的ht[0]上的节点rehash到ht[1]上。</li>
<li>释放ht[0]，将ht[1]设置为第0号表，并创建新的ht[1]。</li>
</ul>
<p>源码：</p>
<ul>
<li><p>扩展操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static int _dictExpandIfNeeded(dict *d) //扩展d字典，并初始化</div><div class="line">&#123;</div><div class="line">    /* Incremental rehashing already in progress. Return. */</div><div class="line">    if (dictIsRehashing(d)) return DICT_OK;     //正在进行rehash，直接返回</div><div class="line"></div><div class="line">    /* If the hash table is empty expand it to the initial size. */</div><div class="line">    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE); //如果字典（的 0 号哈希表）为空，那么创建并返回初始化大小的 0 号哈希表</div><div class="line"></div><div class="line">    /* If we reached the 1:1 ratio, and we are allowed to resize the hash</div><div class="line">     * table (global setting) or we should avoid it but the ratio between</div><div class="line">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</div><div class="line">     * the number of buckets. */</div><div class="line">    //1. 字典已使用节点数和字典大小之间的比率接近 1：1</div><div class="line">    //2. 能够扩展的标志为真</div><div class="line">    //3. 已使用节点数和字典大小之间的比率超过 dict_force_resize_ratio</div><div class="line">    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp; (dict_can_resize ||    </div><div class="line">         d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))    </div><div class="line">    &#123;</div><div class="line">        return dictExpand(d, d-&gt;ht[0].used*2);  //扩展为节点个数的2倍</div><div class="line">    &#125;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>收缩操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int dictResize(dict *d)     //缩小字典d</div><div class="line">&#123;</div><div class="line">    int minimal;</div><div class="line"></div><div class="line">    //如果dict_can_resize被设置成0，表示不能进行rehash，或正在进行rehash，返回出错标志DICT_ERR</div><div class="line">    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;</div><div class="line"></div><div class="line">    minimal = d-&gt;ht[0].used;            //获得已经有的节点数量作为最小限度minimal</div><div class="line">    if (minimal &lt; DICT_HT_INITIAL_SIZE)//但是minimal不能小于最低值DICT_HT_INITIAL_SIZE（4）</div><div class="line">        minimal = DICT_HT_INITIAL_SIZE;</div><div class="line">    return dictExpand(d, minimal);      //用minimal调整字典d的大小</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>扩展和收缩操作都调用了dictExpand()函数，该函数通过计算传入的第二个大小参数进行计算，算出一个最接近2n的realsize，然后进行扩展或收缩，dictExpand()函数源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">int dictExpand(dict *d, unsigned long size)     //根据size调整或创建字典d的哈希表</div><div class="line">&#123;</div><div class="line">    dictht n; /* the new hash table */</div><div class="line">    unsigned long realsize = _dictNextPower(size);  //获得一个最接近2^n的realsize</div><div class="line"></div><div class="line">    /* the size is invalid if it is smaller than the number of</div><div class="line">     * elements already inside the hash table */</div><div class="line">    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size) //正在rehash或size不够大返回出错标志</div><div class="line">        return DICT_ERR;</div><div class="line"></div><div class="line">    /* Rehashing to the same table size is not useful. */</div><div class="line">    if (realsize == d-&gt;ht[0].size) return DICT_ERR; //如果新的realsize和原本的size一样则返回出错标志</div><div class="line">    /* Allocate the new hash table and initialize all pointers to NULL */</div><div class="line">    //初始化新的哈希表的成员</div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize-1;</div><div class="line">    n.table = zcalloc(realsize*sizeof(dictEntry*));</div><div class="line">    n.used = 0;</div><div class="line"></div><div class="line">    /* Is this the first initialization? If so it&apos;s not really a rehashing</div><div class="line">     * we just set the first hash table so that it can accept keys. */</div><div class="line">    if (d-&gt;ht[0].table == NULL) &#123;   //如果ht[0]哈希表为空，则将新的哈希表n设置为ht[0]</div><div class="line">        d-&gt;ht[0] = n;</div><div class="line">        return DICT_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Prepare a second hash table for incremental rehashing */</div><div class="line">    d-&gt;ht[1] = n;           //如果ht[0]非空，则需要rehash</div><div class="line">    d-&gt;rehashidx = 0;       //设置rehash标志位为0，开始渐进式rehash（incremental rehashing）</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>收缩或者扩展哈希表需要将ht[0]表中的所有键全部rehash到ht[1]中，但是rehash操作不是一次性、集中式完成的，而是分多次，渐进式，断续进行的，这样才不会对服务器性能造成影响。因此下面介绍渐进式rehash。</p>
<h2 id="5-渐进式rehash（incremental-rehashing）"><a href="#5-渐进式rehash（incremental-rehashing）" class="headerlink" title="5. 渐进式rehash（incremental rehashing）"></a>5. 渐进式rehash（incremental rehashing）</h2><p>渐进式rehash的关键：</p>
<ol>
<li>字典结构dict中的一个成员rehashidx，当rehashidx为-1时表示不进行rehash，当rehashidx值为0时，表示开始进行rehash。</li>
<li>在rehash期间，每次对字典的添加、删除、查找、或更新操作时，都会判断是否正在进行rehash操作，如果是，则顺带进行单步rehash，并将rehashidx+1。</li>
<li>当rehash时进行完成时，将rehashidx置为-1，表示完成rehash。</li>
</ol>
<p>源码在此：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">static void _dictRehashStep(dict *d) &#123;      //单步rehash</div><div class="line">    if (d-&gt;iterators == 0) dictRehash(d,1); //当迭代器数量不为0，才能进行1步rehash</div><div class="line">&#125;</div><div class="line"></div><div class="line">int dictRehash(dict *d, int n) &#123;       //n步进行rehash</div><div class="line">    int empty_visits = n*10; /* Max number of empty buckets to visit. */</div><div class="line">    if (!dictIsRehashing(d)) return 0;  //只有rehashidx不等于-1时，才表示正在进行rehash，否则返回0</div><div class="line"></div><div class="line">    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;  //分n步，而且ht[0]上还有没有移动的节点</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        /* Note that rehashidx can&apos;t overflow as we are sure there are more</div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        //确保rehashidx没有越界，因为rehashidx是从-1开始，0表示已经移动1个节点，它总是小于hash表的size的</div><div class="line">        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</div><div class="line"></div><div class="line">        //第一个循环用来更新 rehashidx 的值，因为有些桶为空，所以 rehashidx并非每次都比原来前进一个位置，而是有可能前进几个位置，但最多不超过 10。</div><div class="line">        //将rehashidx移动到ht[0]有节点的下标，也就是table[d-&gt;rehashidx]非空</div><div class="line">        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            if (--empty_visits == 0) return 1;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[0].table[d-&gt;rehashidx];     //ht[0]下标为rehashidx有节点，得到该节点的地址</div><div class="line">        /* Move all the keys in this bucket from the old to the new hash HT */</div><div class="line">        //第二个循环用来将ht[0]表中每次找到的非空桶中的链表（或者就是单个节点）拷贝到ht[1]中</div><div class="line">        while(de) &#123;</div><div class="line">            unsigned int h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;  //备份下一个节点的地址</div><div class="line">            /* Get the index in the new hash table */</div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;    //获得计算哈希值并得到哈希表中的下标h</div><div class="line"></div><div class="line">            //将该节点插入到下标为h的位置</div><div class="line">            de-&gt;next = d-&gt;ht[1].table[h];</div><div class="line">            d-&gt;ht[1].table[h] = de;</div><div class="line"></div><div class="line">            //更新两个表节点数目计数器</div><div class="line">            d-&gt;ht[0].used--;</div><div class="line">            d-&gt;ht[1].used++;</div><div class="line"></div><div class="line">            //将de指向以一个处理的节点</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;    //迁移过后将该下标的指针置为空</div><div class="line">        d-&gt;rehashidx++;                         //更新rehashidx</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if we already rehashed the whole table... */</div><div class="line">    if (d-&gt;ht[0].used == 0) &#123;           //ht[0]上已经没有节点了，说明已经迁移完成</div><div class="line">        zfree(d-&gt;ht[0].table);          //释放hash表内存</div><div class="line">        d-&gt;ht[0] = d-&gt;ht[1];            //将迁移过的1号哈希表设置为0号哈希表</div><div class="line">        _dictReset(&amp;d-&gt;ht[1]);          //重置ht[1]哈希表</div><div class="line">        d-&gt;rehashidx = -1;              //rehash标志关闭</div><div class="line">        return 0;                       //表示前已完成</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* More to rehash... */</div><div class="line">    return 1;           //表示还有节点等待迁移</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6. 迭代器"></a>6. 迭代器</h2><p>redis在字典结构也定义了迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictIterator &#123;</div><div class="line">    dict *d;                    //被迭代的字典</div><div class="line">    long index;                 //迭代器当前所指向的哈希表索引位置</div><div class="line">    int table, safe;            //table表示正迭代的哈希表号码，ht[0]或ht[1]。safe表示这个迭代器是否安全。</div><div class="line">    dictEntry *entry, *nextEntry;   //entry指向当前迭代的哈希表节点，nextEntry则指向当前节点的下一个节点。</div><div class="line">    /* unsafe iterator fingerprint for misuse detection. */</div><div class="line">    long long fingerprint;      //避免不安全迭代器的指纹标记</div><div class="line">&#125; dictIterator;</div></pre></td></tr></table></figure></p>
<p>迭代器分为安全迭代器和不安全迭代器：</p>
<p>非安全迭代器只能进行Get等读的操作, 而安全迭代器则可以进行iterator支持的任何操作。<br>由于dict结构中保存了safe iterators的数量，如果数量不为0， 是不能进行下一步的rehash的; 因此安全迭代器的存在保证了遍历数据的准确性。<br>在非安全迭代器的迭代过程中, 会通过fingerprint方法来校验iterator在初始化与释放时字典的hash值是否一致; 如果不一致说明迭代过程中发生了非法操作.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="He Lei" />
          <p class="site-author-name" itemprop="name">He Lei</p>
          <p class="site-description motion-element" itemprop="description">c/c++/python | redis | recommend algorithm | search engine</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">75</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mcgrady-forever" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wuxubj" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He Lei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
