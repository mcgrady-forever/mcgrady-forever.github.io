<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta property="og:type" content="website">
<meta property="og:title" content="HeLei Blog">
<meta property="og:url" content="http://hlei.io/page/2/index.html">
<meta property="og:site_name" content="HeLei Blog">
<meta property="og:description" content="c/c++/python | redis | recommend algorithm | search engine">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HeLei Blog">
<meta name="twitter:description" content="c/c++/python | redis | recommend algorithm | search engine">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hlei.io/page/2/"/>





  <title> HeLei Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HeLei Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">不要因为走得太远，就忘记为什么而出发</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/23/redis-sentinel/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/23/redis-sentinel/" itemprop="url">
                  Redis Sentinel 介绍与部署
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-23T10:29:08+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Sentinel介绍"><a href="#1-Sentinel介绍" class="headerlink" title="1. Sentinel介绍"></a>1. Sentinel介绍</h1><h2 id="1-1-主从复制的问题"><a href="#1-1-主从复制的问题" class="headerlink" title="1.1 主从复制的问题"></a>1.1 主从复制的问题</h2><p>Redis主从复制可将主节点数据同步给从节点，从节点此时有两个作用：</p>
<ul>
<li>一旦主节点宕机，从节点作为主节点的备份可以随时顶上来。</li>
<li>扩展主节点的读能力，分担主节点读压力。</li>
</ul>
<p>但是问题来了：</p>
<ul>
<li>一旦主节点宕机，从节点晋升成主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</li>
<li>主节点的写能力受到单机的限制。</li>
<li>主节点的存储能力受到单机的限制。<br>第一个问题，我们接下来讲的Sentinel就可以解决。而后两个问题，Redis也给出了方案Redis Cluster。</li>
</ul>
<h2 id="1-2-Redis-Sentinel的高可用"><a href="#1-2-Redis-Sentinel的高可用" class="headerlink" title="1.2 Redis Sentinel的高可用"></a>1.2 Redis Sentinel的高可用</h2><p>Redis Sentinel是一个分布式架构，包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当发现节点不可达时，会对节点做下线标识。</p>
<p>如果被标识的是主节点，他还会选择和其他Sentinel节点进行“协商”，当大多数的Sentinel节点都认为主节点不可达时，他们会选举出一个Sentinel节点来完成自动故障转移工作，同时将这个变化通知给Redis应用方。</p>
<p>整个过程完全自动，不需要人工介入，所以可以很好解决Redis的高可用问题。</p>
<p>接下来我们就通过部署一个Redis Sentinel实例来了解整体框架。</p>
<h1 id="2-Redis-Sentinel部署"><a href="#2-Redis-Sentinel部署" class="headerlink" title="2. Redis Sentinel部署"></a>2. Redis Sentinel部署</h1><p>我们部署的拓扑结构如图所示：<br>[img01]</p>
<p>分别有3个Sentinel节点，1个主节点，2个从节点组成一个Redis Sentinel。</p>
<table>
<thead>
<tr>
<th>role</th>
<th>IP</th>
<th>port</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td>127.0.0.1</td>
<td>6379</td>
</tr>
<tr>
<td>slave1</td>
<td>127.0.0.1</td>
<td>6380</td>
</tr>
<tr>
<td>slave2</td>
<td>127.0.0.1</td>
<td>6381</td>
</tr>
<tr>
<td>Sentinel1</td>
<td>127.0.0.1</td>
<td>26379</td>
</tr>
<tr>
<td>Sentinel2</td>
<td>127.0.0.1</td>
<td>26380</td>
</tr>
<tr>
<td>Sentinel3</td>
<td>127.0.0.1</td>
<td>26381</td>
</tr>
</tbody>
</table>
<h2 id="2-1-启动主节点"><a href="#2-1-启动主节点" class="headerlink" title="2.1 启动主节点"></a>2.1 启动主节点</h2><ul>
<li><p>配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">port 6379</div><div class="line">daemonize yes</div><div class="line">logfile &quot;6379.log&quot;</div><div class="line">dbfilename &quot;dump-6379.rdb&quot;</div><div class="line">dir &quot;/var/redis/data/&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>启动主节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜   sudo redis-server redis-6379.conf</div></pre></td></tr></table></figure>
</li>
<li><p>使用PING命令检测是否启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜   redis-cli -h 127.0.0.1 -p 6379 ping</div><div class="line">PONG</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-2-启动两个从节点"><a href="#2-2-启动两个从节点" class="headerlink" title="2.2 启动两个从节点"></a>2.2 启动两个从节点</h2><ul>
<li><p>配置（两个从节点配置相同，除了文件名有区分）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">port 6380</div><div class="line">daemonize yes</div><div class="line">logfile &quot;6380.log&quot;</div><div class="line">dbfilename &quot;dump-6380.rdb&quot;</div><div class="line">dir &quot;/var/redis/data/&quot; </div><div class="line">slaveof 127.0.0.1 6379      // 从属主节点</div></pre></td></tr></table></figure>
</li>
<li><p>启动两个从节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜   sudo redis-server redis-6380.conf </div><div class="line">➜   sudo redis-server redis-6381.conf</div></pre></td></tr></table></figure>
</li>
<li><p>使用PING命令检测是否启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜   redis-cli -h 127.0.0.1 -p 6380 ping</div><div class="line">PONG</div><div class="line">➜   redis-cli -h 127.0.0.1 -p 6381 ping</div><div class="line">PONG</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-3-确认主从关系"><a href="#2-3-确认主从关系" class="headerlink" title="2.3 确认主从关系"></a>2.3 确认主从关系</h2><ul>
<li>主节点视角<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜   redis-cli -h 127.0.0.1 -p 6379 INFO replication</div><div class="line"># Replication</div><div class="line">role:master</div><div class="line">connected_slaves:2</div><div class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=85,lag=0</div><div class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=85,lag=0</div><div class="line">......</div></pre></td></tr></table></figure>
</li>
</ul>
<p>*从节点视角（6380端口）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜   redis-cli -h 127.0.0.1 -p 6380 INFO replication</div><div class="line"># Replication</div><div class="line">role:slave</div><div class="line">master_host:127.0.0.1</div><div class="line">master_port:6379</div><div class="line">master_link_status:up</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="2-4-部署Sentinel节点"><a href="#2-4-部署Sentinel节点" class="headerlink" title="2.4 部署Sentinel节点"></a>2.4 部署Sentinel节点</h2><p>3个Sentinel节点的部署方法是相同的（端口不同）。以26379为例。</p>
<ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Sentinel节点的端口</div><div class="line">port 26379  </div><div class="line">dir /var/redis/data/</div><div class="line">logfile &quot;26379.log&quot;</div><div class="line"></div><div class="line">// 当前Sentinel节点监控 127.0.0.1:6379 这个主节点</div><div class="line">// 2代表判断主节点失败至少需要2个Sentinel节点节点同意</div><div class="line">// mymaster是主节点的别名</div><div class="line">sentinel monitor mymaster 127.0.0.1 6379 2</div><div class="line"></div><div class="line">//每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒且没有回复，则判定不可达</div><div class="line">sentinel down-after-milliseconds mymaster 30000</div><div class="line"></div><div class="line">//当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1</div><div class="line">sentinel parallel-syncs mymaster 1</div><div class="line"></div><div class="line">//故障转移超时时间为180000毫秒</div><div class="line">sentinel failover-timeout mymaster 180000</div></pre></td></tr></table></figure>
</li>
<li><p>启动（两种方法） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* redis-sentinel sentinel-26379.conf</div><div class="line">* redis-server sentinel-26379.conf --sentinel</div><div class="line"></div><div class="line">* 确认</div></pre></td></tr></table></figure>
</li>
</ul>
<p>➜   redis-cli -h 127.0.0.1 -p 26379 INFO Sentinel</p>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>sentinel_masters:1<br>sentinel_tilt:0<br>sentinel_running_scripts:0<br>sentinel_scripts_queue_length:0<br>sentinel_simulate_failure_flags:0<br>master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=1 //sentinels=1表示启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">部署三个Sentinel节点之后，真个拓扑结构如图所示：</div><div class="line">[img02]</div><div class="line"></div><div class="line">* 当部署号Redis Sentinel之后，会有如下变化 </div><div class="line"> * Sentinel节点自动发现了从节点、其余Sentinel节点。</div><div class="line"> * 去掉了默认配置，例如：parallel-syncs、failover-timeout。</div><div class="line"> * 新添加了纪元（epoch）参数。</div><div class="line"></div><div class="line">我们拿端口26379的举例，启动所有的Sentinel和数据节点后，配置文件如下：</div></pre></td></tr></table></figure></p>
<p>port 26379<br>dir “/var/redis/data”<br>sentinel myid 70a3e215c1a34b4d9925d170d9606e615a8874f2<br>sentinel monitor mymaster 127.0.0.1 6379 2<br>sentinel config-epoch mymaster 0<br>sentinel leader-epoch mymaster 0<br>daemonize yes<br>logfile “26379.log”<br>// 发现了两个从节点<br>sentinel known-slave mymaster 127.0.0.1 6381<br>sentinel known-slave mymaster 127.0.0.1 6380<br>// 发送了连个Sentinel节点<br>sentinel known-sentinel mymaster 127.0.0.1 26381 e1148ad6caf60302dd6d0dbd693cb3448e209ac2<br>sentinel known-sentinel mymaster 127.0.0.1 26380 39db5b040b21a52da5334dd2d798244c034b4fc3<br>sentinel current-epoch 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 2.5 故障转移实验</div><div class="line">先查看一下节点的进程pid</div></pre></td></tr></table></figure></p>
<p>➜   ps -aux | grep redis<br>root     18225  0.1  0.0  40208 11212 ?        Ssl  22:10   0:05 redis-server 127.0.0.1:6379<br>root     18234  0.0  0.0  38160  8364 ?        Ssl  22:10   0:04 redis-server 127.0.0.1:6380<br>root     18244  0.0  0.0  38160  8308 ?        Ssl  22:10   0:04 redis-server 127.0.0.1:6381<br>root     20568  0.1  0.0  38160  8460 ?        Ssl  23:05   0:02 redis-sentinel <em>:26379 [sentinel]<br>root     20655  0.1  0.0  38160  8296 ?        Ssl  23:07   0:02 redis-sentinel </em>:26380 [sentinel]<br>root     20664  0.1  0.0  38160  8312 ?        Ssl  23:07   0:02 redis-sentinel *:26381 [sentinel]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们干掉端口6379的主节点。</div></pre></td></tr></table></figure></p>
<p>➜   sudo kill -9 18225<br>➜   ps -aux | grep redis<br>root     18234  0.0  0.0  38160  8364 ?        Ssl  22:10   0:05 redis-server 127.0.0.1:6380<br>root     18244  0.0  0.0  38160  8308 ?        Ssl  22:10   0:05 redis-server 127.0.0.1:6381<br>root     20568  0.1  0.0  38160  8460 ?        Ssl  23:05   0:03 redis-sentinel <em>:26379 [sentinel]<br>root     20655  0.1  0.0  38160  8296 ?        Ssl  23:07   0:03 redis-sentinel </em>:26380 [sentinel]<br>root     20664  0.1  0.0  38160  8312 ?        Ssl  23:07   0:03 redis-sentinel *:26381 [sentinel]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">此时，Redis Sentinel对主节点进行客观下线（Objectively Down， 简称 ODOWN）的判断，确认主节点不可达，则通知从节点中止复制主节点的操作。</div><div class="line">[img03]</div><div class="line"></div><div class="line">当主节点下线时长超过配置的下线时长30000秒，Redis Sentinel执行故障转移操作。</div><div class="line"></div><div class="line">此时，我们查看一下Sentinel节点监控的主节点信息：</div></pre></td></tr></table></figure></p>
<p>127.0.0.1:26379&gt; sentinel masters<br>1)  1) “name”<br>    2) “mymaster”<br>    3) “ip”<br>    4) “127.0.0.1”<br>    5) “port”<br>    6) “6380”           //可以看到主节点已经成为6380端口的节点<br>    7) “runid”<br>    8) “084850ab4ff6c2f2502b185c8eab5bdd25a26ce2”<br>    9) “flags”<br>   10) “master”<br>    …………..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">看一下Sentinel节点监控的从节点信息：</div></pre></td></tr></table></figure></p>
<p>127.0.0.1:26379&gt; sentinel slaves mymaster<br>1)  1) “name”<br>    2) “127.0.0.1:6379”             //ip:port<br>    3) “ip”<br>    4) “127.0.0.1”<br>    5) “port”<br>    6) “6379”<br>    7) “runid”<br>    8) “”<br>    9) “flags”<br>   10) “s_down,slave,disconnected”  //端口6379的原主节点已经断开了连接<br>   …………..<br>2)  1) “name”<br>    2) “127.0.0.1:6381”<br>    3) “ip”<br>    4) “127.0.0.1”<br>    5) “port”<br>    6) “6381”<br>    7) “runid”<br>    8) “24495fe180e4fd64ac47467e0b2652894406e9e4”<br>    9) “flags”<br>   10) “slave”                      //本来的从节点，还是从节点的role<br>    …………..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">由以上信息可得，端口为6380的Redis数据节点成为新的主节点，端口为6379的旧主节点断开连接。如图所示：</div><div class="line">[img04]</div><div class="line"></div><div class="line">我们在试着重启端口6379的数据节点。</div></pre></td></tr></table></figure></p>
<p>➜   sudo redis-server redis-6379.conf<br>➜   ps -aux | grep redis<br>root     18234  0.1  0.0  40208 11392 ?        Ssl  5月22   0:06 redis-server 127.0.0.1:6380<br>root     18244  0.1  0.0  40208 10356 ?        Ssl  5月22   0:07 redis-server 127.0.0.1:6381<br>root     20568  0.1  0.0  38160  8460 ?        Ssl  5月22   0:05 redis-sentinel <em>:26379 [sentinel]<br>root     20655  0.1  0.0  38160  8296 ?        Ssl  5月22   0:05 redis-sentinel </em>:26380 [sentinel]<br>root     20664  0.1  0.0  38160  8312 ?        Ssl  5月22   0:05 redis-sentinel *:26381 [sentinel]<br>menwen   22475  0.0  0.0  14216  5920 pts/2    S+   5月22   0:00 redis-cli -p 26379<br>// 6379的数据节点已重启<br>root     22617  0.0  0.0  38160  8304 ?        Ssl  00:00   0:00 redis-server 127.0.0.1:6379<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">看看发生什么：</div></pre></td></tr></table></figure></p>
<p>127.0.0.1:26379&gt; sentinel slaves mymaster<br>1)  1) “name”<br>    2) “127.0.0.1:6379”     //6379端口的节点重启后，变成了”活”的从节点<br>    3) “ip”<br>    4) “127.0.0.1”<br>    5) “port”<br>    6) “6379”<br>    7) “runid”<br>    8) “de1b5c28483cf150d9550f8e338886706e952346”<br>    9) “flags”<br>   10) “slave”<br>    …………..<br>2)  1) “name”               //6381端口的节点没有变化，仍是从节点<br>    2) “127.0.0.1:6381”<br>    …………..<br>```</p>
<p>他被降级成为端口6380的从节点。<br>[img05]</p>
<p>从上面的逻辑架构和故障转移试验中，可以看出Redis Sentinel的以下几个功能。</p>
<ul>
<li>监控：Sentinel节点会定期检测Redis数据节点和其余Sentinel节点是否可达。</li>
<li>通知：Sentinel节点会将故障转移通知给应用方。</li>
<li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</li>
<li>配置提供者：在Redis Sentinel结构中，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息。</li>
</ul>
<h1 id="3-Sentinel配置说明"><a href="#3-Sentinel配置说明" class="headerlink" title="3. Sentinel配置说明"></a>3. Sentinel配置说明</h1><ul>
<li><p>sentinel monitor mymaster 127.0.0.1 6379 2</p>
<ul>
<li>当前Sentinel节点监控 127.0.0.1:6379 这个主节点</li>
<li>2代表判断主节点失败至少需要2个Sentinel节点节点同意</li>
<li>mymaster是主节点的别名</li>
</ul>
</li>
<li><p>sentinel down-after-milliseconds mymaster 30000</p>
<ul>
<li>每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒且没有回复，则判定不可达</li>
</ul>
</li>
<li><p>sentinel parallel-syncs mymaster 1</p>
<ul>
<li>当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1。<br>sentinel failover-timeout mymaster 180000</li>
</ul>
</li>
</ul>
<p>故障转移超时时间为180000<br>sentinel auth-pass \ \<br>如果Sentinel监控的主节点配置了密码，可以通过sentinel auth-pass配置通过添加主节点的密码，防止Sentinel节点无法对主节点进行监控。<br>例如：sentinel auth-pass mymaster MySUPER–secret-0123passw0rd<br>sentinel notification-script \ \<br>在故障转移期间，当一些警告级别的Sentinel事件发生（指重要事件，如主观下线，客观下线等）时，会触发对应路径的脚本，想脚本发送相应的事件参数。<br>例如：sentinel notification-script mymaster /var/redis/notify.sh<br>sentinel client-reconfig-script \ \<br>在故障转移结束后，触发应对路径的脚本，并向脚本发送故障转移结果的参数。<br>例如：sentinel client-reconfig-script mymaster /var/redis/reconfig.sh。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/23/redis-cluster-solution/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/23/redis-cluster-solution/" itemprop="url">
                  Redis集群方案应该怎么做
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-23T10:13:48+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/22/python-iterator/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/22/python-iterator/" itemprop="url">
                  迭代器&生成器&装饰器
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-22T10:31:37+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合</p>
<p>特点：</p>
<ol>
<li>访问者不需要关心迭代器内部的结构，仅需通过next()方法不断去取下一个内容</li>
<li>不能随机访问集合中的某个值 ，只能从头到尾依次访问</li>
<li>访问到一半时不能往回退</li>
<li>便于循环比较大的数据集合，节省内存</li>
</ol>
<p>第一种方式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list=[&quot;hello&quot;,&quot;world&quot;,&quot;china&quot;]</div><div class="line">for i in list:</div><div class="line">	print i</div></pre></td></tr></table></figure></p>
<p>也是通常我们使用的遍历方式</p>
<p>第二种方式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; list=[&quot;hello&quot;,&quot;world&quot;,&quot;china&quot;]</div><div class="line">&gt;&gt;&gt; it=iter(list)</div><div class="line">&gt;&gt;&gt; while True:</div><div class="line">	try:</div><div class="line">		m=next(it)</div><div class="line">		print(m)</div><div class="line">	except StopIteration:</div><div class="line">		break</div></pre></td></tr></table></figure></p>
<p>列表推导<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</div><div class="line">&gt;&gt;&gt; type(L)</div><div class="line">&lt;type &apos;list&apos;&gt;</div></pre></td></tr></table></figure></p>
<p>range（10）返回的也是一个list</p>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<p> 一个函数调用时返回一个迭代器，那这个函数就叫做生成器（generator），如果函数中包含yield语法，那这个函数就会变成生成器。这个yield的主要效果呢，就是可以使函数中断，并保存中断状态，中断后，代码可以继续往下执行，过一段时间还可以再重新调用这个函数，从上次yield的下一句开始执行。</p>
<ul>
<li><p>用法一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</div><div class="line">&gt;&gt;&gt; g</div><div class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>用法二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def fab(n):</div><div class="line">	a = 0</div><div class="line">	b = 1</div><div class="line">	while a &lt;= n:</div><div class="line">		yield a</div><div class="line">		a, b = a+b, a</div><div class="line"></div><div class="line">for i in fab(5):</div><div class="line">	print i</div><div class="line"></div><div class="line">0</div><div class="line">1</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">5</div></pre></td></tr></table></figure>
</li>
</ul>
<p>xrange是一个生成器，而range是迭代器。</p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>不希望修改变原有函数定义，在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator，类似于设计模式中的装饰器模式。</p>
<p>代码示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    def inner(*args, **kwargs):</div><div class="line">        print(&quot;__func__ = %s&quot;, func.__name__)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return inner</div><div class="line"></div><div class="line">@log</div><div class="line">def now():</div><div class="line">    print &quot;2018/03/22&quot;</div><div class="line"></div><div class="line">(&apos;__func__ = %s&apos;, &apos;now&apos;)</div><div class="line">2018/03/22</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/21/linux-trouble-shooting/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/21/linux-trouble-shooting/" itemprop="url">
                  在线定位问题常用命令
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T10:10:12+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有时候，有很多问题只有在线上或者预发环境才能发现，而线上又不能调试代码，所以线<br>上问题定位就只能看日志、系统状态和dump线程，介绍一些常用的工具，介绍一些常用命令定位线上问题。</p>
<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>在Linux命令行下使用TOP命令查看每个进程的情况，显示如下。<br><img src="/2018/03/21/linux-trouble-shooting/linux-trouble-shooting01.png" alt="img01"></p>
<ul>
<li>交互命令数字1查看每个CPU的性能数据</li>
<li>查看某个进程所有线程的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top -H -p pid</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="strace-amp-pstack"><a href="#strace-amp-pstack" class="headerlink" title="strace &amp; pstack"></a>strace &amp; pstack</h1><p>strace就是这样一款工具。通过它，我们可以跟踪程序执行过程中产生的系统调用及接收到的信号，帮助我们分析程序或命令执行中遇到的异常情况。</p>
<h2 id="1-一个简单的例子"><a href="#1-一个简单的例子" class="headerlink" title="1. 一个简单的例子"></a>1. 一个简单的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//main.c</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">　　int fd ;</div><div class="line">　　int i = 0 ;</div><div class="line">　　fd = open( “/tmp/foo”, O_RDONLY ) ;</div><div class="line">　　if ( fd &lt; 0 )</div><div class="line">　　　　i=5;</div><div class="line">　　else</div><div class="line">　　　　i=2;</div><div class="line">　　return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-strace跟踪输出"><a href="#2-strace跟踪输出" class="headerlink" title="2.strace跟踪输出"></a>2.strace跟踪输出</h2><p>使用以下命令，我们将使用strace对以上程序进行跟踪，并将结果重定向至main.strace文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ strace -o main.strace ./main</div></pre></td></tr></table></figure></p>
<p>接下来我们来看main.strace文件的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">lx@LX:~$ cat main.strace</div><div class="line">execve(&quot;./main&quot;, [&quot;./main&quot;], [/* 43 vars */]) = 0</div><div class="line">brk(0)                                  = 0x9ac4000</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7739000</div><div class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY)      = 3</div><div class="line">fstat64(3, &#123;st_mode=S_IFREG|0644, st_size=80682, ...&#125;) = 0</div><div class="line">mmap2(NULL, 80682, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7725000</div><div class="line">close(3)                                = 0</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/lib/i386-linux-gnu/libc.so.6&quot;, O_RDONLY) = 3</div><div class="line">read(3, &quot;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\220o\1\0004\0\0\0&quot;..., 512) = 512</div><div class="line">fstat64(3, &#123;st_mode=S_IFREG|0755, st_size=1434180, ...&#125;) = 0</div><div class="line">mmap2(NULL, 1444360, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x56d000</div><div class="line">mprotect(0x6c7000, 4096, PROT_NONE)     = 0</div><div class="line">mmap2(0x6c8000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x15a) = 0x6c8000</div><div class="line">mmap2(0x6cb000, 10760, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x6cb000</div><div class="line">close(3)                                = 0</div><div class="line">mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7724000</div><div class="line">set_thread_area(&#123;entry_number:-1 -&gt; 6, base_addr:0xb77248d0, limit:1048575, seg_32bit:1, contents:0, read_exec_    only:0, limit_in_pages:1, seg_not_present:0, useable:1&#125;) = 0</div><div class="line">mprotect(0x6c8000, 8192, PROT_READ)     = 0</div><div class="line">mprotect(0x8049000, 4096, PROT_READ)    = 0</div><div class="line">mprotect(0x4b0000, 4096, PROT_READ)     = 0</div><div class="line">munmap(0xb7725000, 80682)               = 0</div><div class="line">open(&quot;/tmp/foo&quot;, O_RDONLY)              = -1 ENOENT (No such file or directory)</div><div class="line">exit_group(5)                           = ?</div><div class="line">//标红的行号为方便说明而添加，非strace执行输出</div></pre></td></tr></table></figure></p>
<p>strace跟踪程序与系统交互时产生的系统调用，以上每一行就对应一个系统调用，格式为：</p>
<p>系统调用的名称( 参数… ) = 返回值  错误标志和描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Line 1:  对于命令行下执行的程序，execve(或exec系列调用中的某一个)均为strace输出系统调用中的第一个。strace首先调用fork或clone函数新建一个子进程，然后在子进程中调用exec载入需要执行的程序(这里为./main)</div><div class="line"></div><div class="line">Line 2:  以0作为参数调用brk，返回值为内存管理的起始地址(若在子进程中调用malloc，则从0x9ac4000地址开始分配空间)</div><div class="line"></div><div class="line">Line 3:  调用access函数检验/etc/ld.so.nohwcap是否存在</div><div class="line"></div><div class="line">Line 4:  使用mmap2函数进行匿名内存映射，以此来获取8192bytes内存空间，该空间起始地址为0xb7739000，关于匿名内存映射，可以看这里</div><div class="line"></div><div class="line">Line 6:  调用open函数尝试打开/etc/ld.so.cache文件，返回文件描述符为3</div><div class="line"></div><div class="line">Line 7:  fstat64函数获取/etc/ld.so.cache文件信息</div><div class="line"></div><div class="line">Line 8:  调用mmap2函数将/etc/ld.so.cache文件映射至内存，关于使用mmap映射文件至内存，可以看这里</div><div class="line"></div><div class="line">Line 9:  close关闭文件描述符为3指向的/etc/ld.so.cache文件</div><div class="line"></div><div class="line">Line12:  调用read，从/lib/i386-linux-gnu/libc.so.6该libc库文件中读取512bytes，即读取ELF头信息</div><div class="line"></div><div class="line">Line15:  使用mprotect函数对0x6c7000起始的4096bytes空间进行保护(PROT_NONE表示不能访问，PROT_READ表示可以读取)</div><div class="line"></div><div class="line">Line24:  调用munmap函数，将/etc/ld.so.cache文件从内存中去映射，与Line 8的mmap2对应</div><div class="line"></div><div class="line">Line25:  对应源码中使用到的唯一的系统调用——open函数，使用其打开/tmp/foo文件</div><div class="line"></div><div class="line">Line26:  子进程结束，退出码为5(为什么退出值为5？返回前面程序示例部分看看源码吧：)</div></pre></td></tr></table></figure>
<h2 id="3-输出分析"><a href="#3-输出分析" class="headerlink" title="3. 输出分析"></a>3. 输出分析</h2><p>呼呼！看完这么多系统调用函数，是不是有点摸不着北？让我们从整体入手，回到主题strace上来。</p>
<p>从上面输出可以发现，真正能与源码对应上的只有open这一个系统调用(Line25)，其他系统调用几乎都用于进行进程初始化工作：装载被执行程序、载入libc函数库、设置内存映射等。</p>
<p>源码中的if语句或其他代码在相应strace输出中并没有体现，因为它们并没有唤起系统调用。strace只关心程序与系统之间产生的交互，因而strace不适用于程序逻辑代码的排错和分析。</p>
<h2 id="4-常用选项"><a href="#4-常用选项" class="headerlink" title="4. 常用选项"></a>4. 常用选项</h2><ol>
<li>跟踪子进程 -f</li>
<li>记录系统调用时间</li>
</ol>
<p>strace还可以记录程序与系统交互时，各个系统调用发生时的时间信息，有r、t、tt、ttt、T等几个选项，它们记录时间的方式为：</p>
<p>-T:   记录各个系统调用花费的时间，精确到微秒</p>
<p>-r:   以第一个系统调用(通常为execve)计时，精确到微秒</p>
<p>-t:   时：分：秒</p>
<p>-tt:  时：分：秒 . 微秒</p>
<p>-ttt: 计算机纪元以来的秒数 . 微秒</p>
<p>比较常用的为T选项，因为其提供了每个系统调用花费时间。而其他选项的时间记录既包含系统调用时间，又算上用户级代码执行用时，参考意义就小一些。对部分时间选项我们可以组合起来使用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">strace -Tr ./main</div><div class="line">0.000000 execve(“./main”, [“main”], [/* 64 vars */]) = 0</div><div class="line">0.000931 fcntl64(0, F_GETFD)= 0 &lt;0.000012&gt;</div><div class="line">0.000090 fcntl64(1, F_GETFD)= 0 &lt;0.000022&gt;</div><div class="line">0.000060 fcntl64(2, F_GETFD)= 0 &lt;0.000012&gt;</div><div class="line">0.000054 uname(&#123;sys=”Linux”, node=”ion”, ...&#125;) = 0 &lt;0.000014&gt;</div><div class="line">0.000307 geteuid32()= 7903 &lt;0.000011&gt;</div><div class="line">0.000040 getuid32()= 7903 &lt;0.000012&gt;</div><div class="line">0.000039 getegid32()= 200 &lt;0.000011&gt;</div><div class="line">0.000039 getgid32()= 200 &lt;0.000011&gt;</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>最左边一列为-r选项对应的时间输出，最右边一列为-T选项对应的输出。</p>
<ol>
<li>跟踪正在运行的进程 strace -p PID</li>
</ol>
<h2 id="5-使用strace处理程序挂死实例"><a href="#5-使用strace处理程序挂死实例" class="headerlink" title="5. 使用strace处理程序挂死实例"></a>5. 使用strace处理程序挂死实例</h2><h3 id="挂死程序源码"><a href="#挂死程序源码" class="headerlink" title="挂死程序源码"></a>挂死程序源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//hang.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line">    getpid(); //该系统调用起到标识作用</div><div class="line">    if(argc &lt; 2)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;hang (user|system)\n&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if(!strcmp(argv[1], &quot;user&quot;))</div><div class="line">        while(1);</div><div class="line">    else if(!strcmp(argv[1], &quot;system&quot;))</div><div class="line">        sleep(500);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可向该程序传送user和system参数，以上代码使用死循环模拟用户态挂死，调用sleep模拟内核态程序挂死。</p>
<h3 id="strace跟踪输出"><a href="#strace跟踪输出" class="headerlink" title="strace跟踪输出"></a>strace跟踪输出</h3><ul>
<li><p>用户态挂死跟踪输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line">mprotect(0x8049000, 4096, PROT_READ)    = 0</div><div class="line">mprotect(0xb59000, 4096, PROT_READ)     = 0</div><div class="line">munmap(0xb77bf000, 80682)               = 0</div><div class="line">getpid()                                = 14539</div></pre></td></tr></table></figure>
</li>
<li><p>内核态挂死跟踪输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line">mprotect(0x8049000, 4096, PROT_READ)    = 0</div><div class="line">mprotect(0xddf000, 4096, PROT_READ)     = 0</div><div class="line">munmap(0xb7855000, 80682)               = 0</div><div class="line">getpid()                                = 14543</div><div class="line">rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0</div><div class="line">rt_sigaction(SIGCHLD, NULL, &#123;SIG_DFL, [], 0&#125;, 8) = 0</div><div class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</div><div class="line">nanosleep(&#123;500, 0&#125;,</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="输出分析"><a href="#输出分析" class="headerlink" title="输出分析"></a>输出分析</h3><p>用户态挂死情况下，strace在getpid()一行输出之后没有其他系统调用输出；进程在内核态挂死，最后一行的系统调用nanosleep不能完整显示，这里nanosleep没有返回值表示该调用尚未完成。</p>
<p>因而我们可以得出以下结论：使用strace跟踪挂死程序，如果最后一行系统调用显示完整，程序在逻辑代码处挂死；如果最后一行系统调用显示不完整，程序在该系统调用处挂死。</p>
<h1 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h1><ul>
<li>查看网络流量 /proc/net/dev<br><img src="/2018/03/21/linux-trouble-shooting/linux-trouble-shooting02.png" alt="img02"></li>
<li>查看连接数 /proc/net/snmp<br><img src="/2018/03/21/linux-trouble-shooting/linux-trouble-shooting03.png" alt="img03"></li>
<li>查看内存信息 /proc/meminfo<br><img src="/2018/03/21/linux-trouble-shooting/linux-trouble-shooting04.png" alt="img04"></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/19/network-thundering-herd/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/19/network-thundering-herd/" itemprop="url">
                  惊群效应
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-19T14:24:47+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么叫惊群现象"><a href="#什么叫惊群现象" class="headerlink" title="什么叫惊群现象"></a>什么叫惊群现象</h1><p>首先，我们看看维基百科对惊群的定义:</p>
<pre><code>The thundering herd problem occurs when a large number of processes waiting for an event are awoken when that event occurs, but only one process is able to proceed at a time. After the processes wake up, they all demand the resource and a decision must be made as to which process can continue. After the decision is made, the remaining processes are put back to sleep, only to all wake up again to request access to the resource.

This occurs repeatedly, until there are no more processes to be woken up. Because all the processes use system resources upon waking, it is more efficient if only one process was woken up at a time.

This may render the computer unusable, but it can also be used as a technique if there is no other way to decide which process should continue (for example when programming with semaphores).
</code></pre><p>惊群简单来说就是多个进程或者线程在等待同一个事件，当事件发生时，所有线程和进程都会被内核唤醒。唤醒后通常只有一个进程获得了该事件并进行处理，其他进程发现获取事件失败后又继续进入了等待状态，在一定程度上降低了系统性能。</p>
<h1 id="accept-惊群"><a href="#accept-惊群" class="headerlink" title="accept 惊群"></a>accept 惊群</h1><p>具体来说惊群通常发生在服务器的监听等待调用上，服务器创建监听socket，后fork多个进程，在每个进程中调用accept或者epoll_wait等待终端的连接。</p>
<p>那么这个问题真的存在吗？</p>
<p>事实上，历史上，Linux 的 accpet 确实存在惊群问题，但现在的内核都解决该问题了。即，当多个进程/线程都阻塞在对同一个 socket 的 accept 调用上时，当有一个新的连接到来，内核只会唤醒一个进程，其他进程保持休眠，压根就不会被唤醒。</p>
<p>测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;  </div><div class="line">#include &lt;sys/socket.h&gt;  </div><div class="line">#include &lt;netinet/in.h&gt;  </div><div class="line">#include &lt;arpa/inet.h&gt;  </div><div class="line">#include &lt;assert.h&gt;  </div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line"></div><div class="line">#define IP   &quot;127.0.0.1&quot;</div><div class="line">#define PORT  8888</div><div class="line">#define WORKER 4</div><div class="line"></div><div class="line">int worker(int listenfd, int i)</div><div class="line">&#123;</div><div class="line">    while (1) &#123;</div><div class="line">        printf(&quot;I am worker %d, begin to accept connection.\n&quot;, i);</div><div class="line">        struct sockaddr_in client_addr;  </div><div class="line">        socklen_t client_addrlen = sizeof( client_addr );  </div><div class="line">        int connfd = accept( listenfd, ( struct sockaddr* )&amp;client_addr, &amp;client_addrlen );  </div><div class="line">        if (connfd != -1) &#123;</div><div class="line">            printf(&quot;worker %d accept a connection success.\t&quot;, i);</div><div class="line">            printf(&quot;ip :%s\t&quot;,inet_ntoa(client_addr.sin_addr));</div><div class="line">            printf(&quot;port: %d \n&quot;,client_addr.sin_port);</div><div class="line">        &#125; else &#123;</div><div class="line">            printf(&quot;worker %d accept a connection failed,error:%s&quot;, i, strerror(errno));</div><div class="line">			close(connfd);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int i = 0;</div><div class="line">    struct sockaddr_in address;  </div><div class="line">    bzero(&amp;address, sizeof(address));  </div><div class="line">    address.sin_family = AF_INET;  </div><div class="line">    inet_pton( AF_INET, IP, &amp;address.sin_addr);  </div><div class="line">    address.sin_port = htons(PORT);  </div><div class="line">    int listenfd = socket(PF_INET, SOCK_STREAM, 0);  </div><div class="line">    assert(listenfd &gt;= 0);  </div><div class="line"></div><div class="line">    int ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));  </div><div class="line">    assert(ret != -1);  </div><div class="line"></div><div class="line">    ret = listen(listenfd, 5);  </div><div class="line">    assert(ret != -1);  </div><div class="line"></div><div class="line">    for (i = 0; i &lt; WORKER; i++) &#123;</div><div class="line">        printf(&quot;Create worker %d\n&quot;, i+1);</div><div class="line">        pid_t pid = fork();</div><div class="line">        /*child  process */</div><div class="line">        if (pid == 0) &#123;</div><div class="line">            worker(listenfd, i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (pid &lt; 0) &#123;</div><div class="line">            printf(&quot;fork error&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*wait child process*/</div><div class="line">    int status;</div><div class="line">    wait(&amp;status);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们对该服务器发起连接请求（用 telnet/curl 等模拟）时，会看到只有一个进程被唤醒。</p>
<h1 id="epoll惊群"><a href="#epoll惊群" class="headerlink" title="epoll惊群"></a>epoll惊群</h1><p>如上所述，accept 已经不存在惊群问题，但 epoll 上还是存在惊群问题。即，如果多个进程/线程阻塞在监听同一个 listening socket fd 的 epoll_wait 上，当有一个新的连接到来时，所有的进程都会被唤醒。</p>
<p>考虑如下场景：</p>
<p>主进程创建 socket, bind， listen 后，将该 socket 加入到 epoll 中，然后 fork 出多个子进程，每个进程都阻塞在 epoll_wait 上，如果有事件到来，则判断该事件是否是该 socket 上的事件，如果是，说明有新的连接到来了，则进行 accept 操作。为了简化处理，忽略后续的读写以及对 accept 返回的新的套接字的处理，直接断开连接。</p>
<p>那么，当新的连接到来时，是否每个阻塞在 epoll_wait 上的进程都会被唤醒呢？</p>
<p>很多博客中提到，测试表明虽然 epoll_wait 不会像 accept 那样只唤醒一个进程/线程，但也不会把所有的进程/线程都唤醒。</p>
<p>为了验证这个问题，我自己写了一个测试程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">#include &lt;sys/epoll.h&gt;</div><div class="line">#include &lt;netdb.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;netinet/in.h&gt;</div><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line"></div><div class="line">#define IP   &quot;127.0.0.1&quot;</div><div class="line">#define PORT  8888</div><div class="line">#define PROCESS_NUM 4</div><div class="line">#define MAXEVENTS 64</div><div class="line"></div><div class="line">static int create_and_bind ()</div><div class="line">&#123;</div><div class="line">    int fd = socket(PF_INET, SOCK_STREAM, 0);</div><div class="line">    struct sockaddr_in serveraddr;</div><div class="line">    serveraddr.sin_family = AF_INET;</div><div class="line">    inet_pton( AF_INET, IP, &amp;serveraddr.sin_addr);  </div><div class="line">    serveraddr.sin_port = htons(PORT);</div><div class="line">    bind(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr));</div><div class="line">    return fd;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int make_socket_non_blocking (int sfd)</div><div class="line">&#123;</div><div class="line">    int flags, s;</div><div class="line">    flags = fcntl (sfd, F_GETFL, 0);</div><div class="line">    if (flags == -1) &#123;</div><div class="line">        perror (&quot;fcntl&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    flags |= O_NONBLOCK;</div><div class="line">    s = fcntl (sfd, F_SETFL, flags);</div><div class="line">    if (s == -1) &#123;</div><div class="line">        perror (&quot;fcntl&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void worker(int sfd, int efd, struct epoll_event *events, int k) &#123;</div><div class="line">    /* The event loop */</div><div class="line">    while (1) &#123;</div><div class="line">        int n, i;</div><div class="line">        n = epoll_wait(efd, events, MAXEVENTS, -1);</div><div class="line">        //sleep(1);</div><div class="line">        printf(&quot;worker  %d return from epoll_wait!\n&quot;, k);</div><div class="line">        for (i = 0; i &lt; n; i++) &#123;</div><div class="line">            if ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp;EPOLLIN))) &#123;</div><div class="line">                /* An error has occured on this fd, or the socket is not ready for reading (why were we notified then?) */</div><div class="line">                fprintf (stderr, &quot;epoll error\n&quot;);</div><div class="line">                close (events[i].data.fd);</div><div class="line">                continue;</div><div class="line">            &#125; else if (sfd == events[i].data.fd) &#123;</div><div class="line">                /* We have a notification on the listening socket, which means one or more incoming connections. */</div><div class="line">                struct sockaddr in_addr;</div><div class="line">                socklen_t in_len;</div><div class="line">                int infd;</div><div class="line">                char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</div><div class="line">                in_len = sizeof in_addr;</div><div class="line">                infd = accept(sfd, &amp;in_addr, &amp;in_len);</div><div class="line">                if (infd == -1) &#123;</div><div class="line">                    printf(&quot;worker %d accept failed!\n&quot;, k);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                printf(&quot;worker %d accept successed!\n&quot;, k);</div><div class="line">                /* Make the incoming socket non-blocking and add it to the list of fds to monitor. */</div><div class="line">                close(infd); </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main (int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int sfd, s;</div><div class="line">    int efd;</div><div class="line">    struct epoll_event event;</div><div class="line">    struct epoll_event *events;</div><div class="line">    sfd = create_and_bind();</div><div class="line">    if (sfd == -1) &#123;</div><div class="line">        abort ();</div><div class="line">    &#125;</div><div class="line">    s = make_socket_non_blocking (sfd);</div><div class="line">    if (s == -1) &#123;</div><div class="line">        abort ();</div><div class="line">    &#125;</div><div class="line">    s = listen(sfd, SOMAXCONN);</div><div class="line">    if (s == -1) &#123;</div><div class="line">        perror (&quot;listen&quot;);</div><div class="line">        abort ();</div><div class="line">    &#125;</div><div class="line">    efd = epoll_create(MAXEVENTS);</div><div class="line">    if (efd == -1) &#123;</div><div class="line">        perror(&quot;epoll_create&quot;);</div><div class="line">        abort();</div><div class="line">    &#125;</div><div class="line">    event.data.fd = sfd;</div><div class="line">    event.events = EPOLLIN | EPOLLEXCLUSIVE;</div><div class="line">    s = epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &amp;event);</div><div class="line">    if (s == -1) &#123;</div><div class="line">        perror(&quot;epoll_ctl&quot;);</div><div class="line">        abort();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Buffer where events are returned */</div><div class="line">    events = (struct epoll_event*)calloc(MAXEVENTS, sizeof event);</div><div class="line">    int k;</div><div class="line">    for(k = 0; k &lt; PROCESS_NUM; k++) &#123;</div><div class="line">        printf(&quot;Create worker %d\n&quot;, k+1);</div><div class="line">        int pid = fork();</div><div class="line">        if(pid == 0) &#123;</div><div class="line">            worker(sfd, efd, events, k);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int status;</div><div class="line">    wait(&amp;status);</div><div class="line">    free (events);</div><div class="line">    close (sfd);</div><div class="line">    return EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行server端后用telnet连，出现了2个进程被唤醒的情况，并不是每次都出现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">worker  3 return from epoll_wait!</div><div class="line">worker 3 accept successed!</div><div class="line">worker  2 return from epoll_wait!</div><div class="line">worker 2 accept failed!</div></pre></td></tr></table></figure></p>
<p>也就是说，到目前为止，还没有得到一个确定的答案。但后来，在下面这篇博客中看到这样一个评论：<a href="http://blog.csdn.net/spch2008/article/details/18301357" target="_blank" rel="external">http://blog.csdn.net/spch2008/article/details/18301357</a></p>
<p>这个总结，需要进一步阐述，你的实验，看上去是只有4个进程唤醒了，而事实上，其余进程没有被唤醒的原因是你的某个进程已经处理完这个 accept，内核队列上已经没有这个事件，无需唤醒其他进程。你可以在 epoll 获知这个 accept 事件的时候，不要立即去处理，而是 sleep 下，这样所有的进程都会被唤起</p>
<p>看到这个评论后，我顿时如醍醐灌顶，重新修改了上面的测试程序，即在 epoll_wait 返回后，加了个 sleep 语句，这时再测试，果然发现所有的进程都被唤醒了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">worker  1 return from epoll_wait!</div><div class="line">worker  3 return from epoll_wait!</div><div class="line">worker 1 accept successed!</div><div class="line">worker 3 accept failed!</div><div class="line">worker  2 return from epoll_wait!</div><div class="line">worker 2 accept failed!</div><div class="line">worker  0 return from epoll_wait!</div><div class="line">worker 0 accept failed!</div></pre></td></tr></table></figure></p>
<p>所以，epoll_wait上的惊群确实是存在的。</p>
<h1 id="为什么内核不处理-epoll-惊群"><a href="#为什么内核不处理-epoll-惊群" class="headerlink" title="为什么内核不处理 epoll 惊群"></a>为什么内核不处理 epoll 惊群</h1><p>看到这里，我们可能有疑惑了，为什么内核对 accept 的惊群做了处理，而现在仍然存在 epoll 的惊群现象呢？</p>
<p>accept 确实应该只能被一个进程调用成功，内核很清楚这一点。但 epoll 不一样，他监听的文件描述符，除了可能后续被 accept 调用外，还有可能是其他网络 IO 事件的，而其他 IO 事件是否只能由一个进程处理，是不一定的，内核不能保证这一点，这是一个由用户决定的事情，例如可能一个文件会由多个进程来读写。所以，对 epoll 的惊群，内核则不予处理。</p>
<h1 id="Nginx-是如何处理惊群问题的"><a href="#Nginx-是如何处理惊群问题的" class="headerlink" title="Nginx 是如何处理惊群问题的"></a>Nginx 是如何处理惊群问题的</h1><h1 id="使用EPOLLEXCLUSIVE"><a href="#使用EPOLLEXCLUSIVE" class="headerlink" title="使用EPOLLEXCLUSIVE"></a>使用EPOLLEXCLUSIVE</h1><p>Linux 4.5解决了这一问题，使用EPOLLEXCLUSIVE标记，但我自己的系统还没这么新，留待之后验证。<br><a href="http://www.man7.org/linux/man-pages/man2/epoll_ctl.2.html" target="_blank" rel="external">http://www.man7.org/linux/man-pages/man2/epoll_ctl.2.html</a></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>现在我们对惊群及 Nginx 的处理总结如下：</p>
<ul>
<li>accept 不会有惊群(since linux2.6)，epoll_wait 才会。</li>
<li>Nginx 的 accept_mutex,并不是解决 accept 惊群问题，而是解决 epoll_wait 惊群问题。</li>
<li>说Nginx 解决了 epoll_wait 惊群问题，也是不对的，它只是控制是否将监听套接字加入到epoll 中。监听套接字只在一个子进程的 epoll 中，当新的连接来到时，其他子进程当然不会惊醒了。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/13/multithread-lock-summary/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/13/multithread-lock-summary/" itemprop="url">
                  各种锁的总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-13T11:21:43+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。</p>
<p>使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。</p>
<p>在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。</p>
<p>在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。</p>
<p>可能引起的问题：</p>
<ol>
<li><p>过多占据CPU时间：如果锁的当前持有者长时间不释放该锁，那么等待者将长时间的占据cpu时间片，导致CPU资源的浪费，因此可以设定一个时间，当锁持有者超过这个时间不释放锁时，等待者会放弃CPU时间片阻塞；</p>
</li>
<li><p>死锁问题：试想一下，有一个线程连续两次试图获得自旋锁（比如在递归程序中），第一次这个线程获得了该锁，当第二次试图加锁的时候，检测到锁已被占用（其实是被自己占用），那么这时，线程会一直等待自己释放该锁，而不能继续执行，这样就引起了死锁。因此递归程序使用自旋锁应该遵循以下原则：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。</p>
</li>
</ol>
<h1 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h1><p>让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。。</p>
<p>JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()\notify()</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下<strong>ReentrantLock</strong>和<strong>synchronized</strong>都是可重入锁</p>
<p>3、可重入锁</p>
<p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class Test implements Runnable&#123;</div><div class="line"></div><div class="line">	public synchronized void get()&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public synchronized void set()&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Test ss=new Test();</div><div class="line">		new Thread(ss).start();</div><div class="line">		new Thread(ss).start();</div><div class="line">		new Thread(ss).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test implements Runnable &#123;</div><div class="line">	ReentrantLock lock = new ReentrantLock();</div><div class="line"></div><div class="line">	public void get() &#123;</div><div class="line">		lock.lock();</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void set() &#123;</div><div class="line">		lock.lock();</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Test ss = new Test();</div><div class="line">		new Thread(ss).start();</div><div class="line">		new Thread(ss).start();</div><div class="line">		new Thread(ss).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两个例子最后的结果都是正确的，即 同一个线程id被连续输出两次。</p>
<p>结果如下：</p>
<p>Threadid: 8</p>
<p>Threadid: 8</p>
<p>Threadid: 10</p>
<p>Threadid: 10</p>
<p>Threadid: 9</p>
<p>Threadid: 9</p>
<p>可重入锁最大的作用是避免死锁</p>
<p>我们以自旋锁作为例子，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SpinLock &#123;  </div><div class="line">    private AtomicReference&lt;Thread&gt; owner =new AtomicReference&lt;&gt;();  </div><div class="line">    public void lock()&#123;  </div><div class="line">        Thread current = Thread.currentThread();  </div><div class="line">        while(!owner.compareAndSet(null, current))&#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    public void unlock ()&#123;  </div><div class="line">        Thread current = Thread.currentThread();  </div><div class="line">        owner.compareAndSet(current, null);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于自旋锁来说，</p>
<ol>
<li>若有同一线程两调用lock() ，会导致第二次调用lock位置进行自旋，产生了死锁<br>说明这个锁并不是可重入的。（在lock函数内，应验证线程是否为已经获得锁的线程）</li>
<li>若1问题已经解决，当unlock（）第一次调用时，就已经将锁释放了。实际上不应释放锁。</li>
</ol>
<p>（采用计数次进行统计）<br>修改之后，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class SpinLock1 &#123;</div><div class="line">	private AtomicReference&lt;Thread&gt; owner =new AtomicReference&lt;&gt;();</div><div class="line">	private int count =0;</div><div class="line">	public void lock()&#123;</div><div class="line">		Thread current = Thread.currentThread();</div><div class="line">		if(current==owner.get()) &#123;</div><div class="line">			count++;</div><div class="line">			return ;</div><div class="line">		&#125;</div><div class="line">		while(!owner.compareAndSet(null, current))&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void unlock ()&#123;</div><div class="line">		Thread current = Thread.currentThread();</div><div class="line">		if(current==owner.get())&#123;</div><div class="line">			if(count!=0)&#123;</div><div class="line">				count--;</div><div class="line">			&#125;else&#123;</div><div class="line">				owner.compareAndSet(current, null);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该自旋锁即为可重入锁。</p>
<h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><p>悲观锁(Pessimistic Lock), 顾名思义就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。独占锁是悲观锁的一种实现</p>
<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。使用CAS来保证,保证这个操作的原子性</p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<h1 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读-写锁"></a>读-写锁</h1><p>Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。</p>
<p>Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock，详细的API可以查看JavaAPI文档。</p>
<p>ReentrantReadWriteLock 和 ReentrantLock 不是继承关系，但都是基于 AbstractQueuedSynchronizer 来实现。lock方法是基于CAS来实现的</p>
<p>ReadWriteLock中暴露了两个Lock对象：<br>在读写锁的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。读写锁是一种性能优化的策略。<br>RentrantReadWriteLock在构造时也可以选择是一个非公平的锁（默认）还是公平的锁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/12/os-memory-layout/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/12/os-memory-layout/" itemprop="url">
                  内存布局
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T17:25:18+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程的内存空间布局"><a href="#进程的内存空间布局" class="headerlink" title="进程的内存空间布局"></a>进程的内存空间布局</h1><p>进程的内存布局在结构上是有规律的，具体来说对于 linux 系统上的进程，其内存空间一般可以粗略地分为以下几大段【1】，从高内存到低内存排列：</p>
<ol>
<li><p>内核态内存空间，其大小一般比较固定（可以编译时调整），但 32 位系统和 64 位系统的值不一样。</p>
</li>
<li><p>用户态的堆栈，大小不固定，可以用 ulimit -s 进行调整，默认一般为 8M，从高地址向低地址增长。</p>
</li>
<li><p>mmap 区域，进程茫茫内存空间里的主要部分，既可以从高地址到低地址延伸(所谓 flexible layout)，也可以从低到高延伸(所谓 legacy layout)，看进程具体情况【2】【3】。</p>
</li>
<li><p>brk 区域，紧邻数据段(甚至贴着)，从低位向高位伸展，但它的大小主要取决于 mmap 如何增长，一般来说，即使是 32 位的进程以传统方式延伸，也有差不多 1 GB 的空间（准确地说是 TASK_SIZE/3 - 代码段数据段，参看 arch/x86/include/asm/processor.h 里的定义)【4】</p>
</li>
<li><p>数据段，主要是进程里初始化和未初始化的全局数据总和，当然还有编译器生成一些辅助数据结构等等)，大小取决于具体进程，其位置紧贴着代码段。</p>
</li>
<li><p>代码段，主要是进程的指令，包括用户代码和编译器生成的辅助代码，其大小取决于具体程序，但起始位置根据 32 位还是 64 位一般固定(-fPIC, -fPIE等除外【5】)。<br><img src="/2018/03/12/os-memory-layout/os_memory_layout.png" alt="img01"></p>
</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>【1】<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Growing_the_Oracle_SGA_to_2.7_GB_in_x86_Red_Hat_Enterprise_Linux_2.1_Without_VLM-Linux_Memory_Layout.html" target="_blank" rel="external">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Growing_the_Oracle_SGA_to_2.7_GB_in_x86_Red_Hat_Enterprise_Linux_2.1_Without_VLM-Linux_Memory_Layout.html</a></li>
<li>【2】understanding the linux kernel, page 819, flexible memory region layout: <a href="https://books.google.com.hk/books?id=h0lltXyJ8aIC&amp;pg=PT925&amp;lpg=PT925&amp;dq=linux+flexible+memory&amp;source=bl&amp;ots=gO7rIYb8HR&amp;sig=pirB5pswdHFHSljy57EksxS3ABw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjpkfa-2_rRAhVGFJQKHcETDSUQ6AEITDAH#v=onepage&amp;q=linux%20flexible%20memory&amp;f=false" target="_blank" rel="external">https://books.google.com.hk/books?id=h0lltXyJ8aIC&amp;pg=PT925&amp;lpg=PT925&amp;dq=linux+flexible+memory&amp;source=bl&amp;ots=gO7rIYb8HR&amp;sig=pirB5pswdHFHSljy57EksxS3ABw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjpkfa-2_rRAhVGFJQKHcETDSUQ6AEITDAH#v=onepage&amp;q=linux%20flexible%20memory&amp;f=false</a></li>
<li>【3】<a href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4" target="_blank" rel="external">https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4</a></li>
<li>【4】<a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h#L770" target="_blank" rel="external">http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h#L770</a></li>
<li>【5】<a href="https://access.redhat.com/blogs/766093/posts/1975793" target="_blank" rel="external">https://access.redhat.com/blogs/766093/posts/1975793</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/12/c-compile/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/12/c-compile/" itemprop="url">
                  程序的编译与链接
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T16:50:34+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="编译过程预览"><a href="#编译过程预览" class="headerlink" title="编译过程预览"></a>编译过程预览</h1><p><img src="/2018/03/12/c-compile/c_compile01.png" alt="img01"></p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><ul>
<li>预处理(Prepressing) :   -E 表示只进行预处理, 即 : gcc –E hello.c –o hello.i<ul>
<li>展开所有 #define 定义的宏</li>
<li>处理所有条件预编译指令,如 #if, #ifdef</li>
<li>递归的将 #include 的文件插入到该预编译文件中</li>
<li>删除各类注释</li>
<li>添加行和文件标识,如  #2 “hello.c” 2 ,用于调试或编译出错报警</li>
<li>保留所有的 #pragma 编译指令,编译器要使用</li>
</ul>
</li>
<li>对于C++ 来说,预处理后的文件扩展名是 .ii</li>
</ul>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ul>
<li>编译(Compilation):  gcc –S hello.i –o hello.s<br>编译过程就是把预处理完的文件进行一系列词法分析,语法分析,语义分析及优化后生成相应的汇编代码文件.</li>
<li>现在的gcc 把预处理和编译两个步骤合成一个步骤,C语言使用一个叫做 cc1 的程序来完成,C++则是 cc1plus ,位于 /usr/libexec/gcc/x86_64-redhat-linux/4.1.2/</li>
<li>gcc 实际上是这些后台程序的包装,它会根据参数要求去调用 cc1(cclplus), 汇编器 as 和链接器 ld</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li>链接(Linking):解决一个程序被分割成多个模块后,模块间最后如何组合成一个单一程序的问题.</li>
<li>链接的主要任务是把各个模块之间相互引用的部分处理好,使各个模块之间能正确的衔接.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/12/linux-command/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/12/linux-command/" itemprop="url">
                  linux-command
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T10:49:48+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="查看某个进程的线程数量"><a href="#查看某个进程的线程数量" class="headerlink" title="查看某个进程的线程数量"></a>查看某个进程的线程数量</h1><ol>
<li>根据进程号进行查询：<ul>
<li><h1 id="pstree-p-进程号"><a href="#pstree-p-进程号" class="headerlink" title="pstree -p 进程号"></a>pstree -p 进程号</h1></li>
</ul>
</li>
</ol>
<p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~/myspace/test/network$ pstree -p 5629</div><div class="line">test05(5629)─┬─&#123;test05&#125;(5630)</div><div class="line">             ├─&#123;test05&#125;(5631)</div><div class="line">             ├─&#123;test05&#125;(5632)</div><div class="line">             └─&#123;test05&#125;(5633)</div></pre></td></tr></table></figure></p>
<ul>
<li><h1 id="top-Hp-进程号"><a href="#top-Hp-进程号" class="headerlink" title="top -Hp 进程号"></a>top -Hp 进程号</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND </div><div class="line">  5629 chris     20   0 47680 1420 1188 S    0  0.1   0:00.02 test05                                          </div><div class="line"> 5630 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05                                          </div><div class="line"> 5631 chris     20   0 47680 1420 1188 S    0  0.1   0:00.03 test05                                          </div><div class="line"> 5632 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05                                          </div><div class="line"> 5633 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05</div><div class="line"> ``` </div><div class="line"></div><div class="line">2. 根据进程名字进行查询：</div></pre></td></tr></table></figure>
<h1 id="pstree-p-ps-e-grep-test05-awk-39-print-1-39"><a href="#pstree-p-ps-e-grep-test05-awk-39-print-1-39" class="headerlink" title="pstree -p ps -e | grep test05 | awk &#39;{print $1}&#39;"></a>pstree -p <code>ps -e | grep test05 | awk &#39;{print $1}&#39;</code></h1><h1 id="pstree-p-ps-e-grep-test05-awk-39-print-1-39-wc-l"><a href="#pstree-p-ps-e-grep-test05-awk-39-print-1-39-wc-l" class="headerlink" title="pstree -p ps -e | grep test05 | awk &#39;{print $1}&#39; | wc -l"></a>pstree -p <code>ps -e | grep test05 | awk &#39;{print $1}&#39;</code> | wc -l</h1><p>```<br>执行效果和上面的命令是一样的</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hlei.io/2018/03/07/distributed-system-consistent-hashing/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="He Lei">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="HeLei Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="HeLei Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/07/distributed-system-consistent-hashing/" itemprop="url">
                  一致性哈希算法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-07T17:02:49+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一些场景希望同样的请求尽量落到一台机器上，比如访问缓存集群时，我们往往希望同一种请求能落到同一个后端上，以充分利用其上已有的缓存，不同的机器承载不同的稳定working set。而不是随机地散落到所有机器上，那样的话会迫使所有机器缓存所有的内容，最终由于存不下形成颠簸而表现糟糕。 我们都知道hash能满足这个要求，比如当有n台服务器时，输入x总是会发送到第hash(x) % n台服务器上。但当服务器变为m台时，hash(x) % n和hash(x) % m很可能都不相等，这会使得几乎所有请求的发送目的地都发生变化，如果目的地是缓存服务，所有缓存将失效，继而对原本被缓存遮挡的数据库或计算服务造成请求风暴，触发雪崩。一致性哈希是一种特殊的哈希算法，在增加服务器时，发向每个老节点的请求中只会有一部分转向新节点，从而实现平滑的迁移。这篇论文中提出了一致性hash的概念。</p>
<p>一致性hash满足以下四个性质：</p>
<ul>
<li>平衡性 (Balance) : 每个节点被选到的概率是O(1/n)。</li>
<li>单调性 (Monotonicity) : 当新节点加入时， 不会有请求在老节点间移动， 只会从老节点移动到新节点。当有节点被删除时，也不会影响落在别的节点上的请求。</li>
<li>分散性 (Spread) : 当上游的机器看到不同的下游列表时(在上线时及不稳定的网络中比较常见), 同一个请求尽量映射到少量的节点中。</li>
<li>负载 (Load) : 当上游的机器看到不同的下游列表的时候， 保证每台下游分到的请求数量尽量一致。</li>
</ul>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>所有server的32位hash值在32位整数值域上构成一个环(Hash Ring)，环上的每个区间和一个server唯一对应，如果一个key落在某个区间内， 它就被分流到对应的server上。<br><img src="/2018/03/07/distributed-consistent-hashing/chash.png" alt="img01"><br>当删除一个server的， 它对应的区间会归属于相邻的server，所有的请求都会跑过去。当增加一个server时，它会分割某个server的区间并承载落在这个区间上的所有请求。单纯使用Hash Ring很难满足我们上节提到的属性，主要两个问题：</p>
<ul>
<li>在机器数量较少的时候， 区间大小会不平衡。</li>
<li>当一台机器故障的时候， 它的压力会完全转移到另外一台机器， 可能无法承载。<br>为了解决这个问题，我们为每个server计算m个hash值，从而把32位整数值域划分为n*m个区间，当key落到某个区间时，分流到对应的server上。那些额外的hash值使得区间划分更加均匀，被称为Virtual Node。当删除一个server时，它对应的m个区间会分别合入相邻的区间中，那个server上的请求会较为平均地转移到其他server上。当增加server时，它会分割m个现有区间，从对应server上分别转移一些请求过来。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="He Lei" />
          <p class="site-author-name" itemprop="name">He Lei</p>
          <p class="site-description motion-element" itemprop="description">c/c++/python | redis | recommend algorithm | search engine</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">69</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mcgrady-forever" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wuxubj" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He Lei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
