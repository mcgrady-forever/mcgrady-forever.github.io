<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Nginx＋uWSGI＋Django部署服务器]]></title>
      <url>http://hlei.io/2018/06/07/python-nginx-uwsgi-django/</url>
      <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>先弄清楚几点概念, 注意大小写区别.</p>
<ul>
<li>WSGI - 全称为Python Web Server Gateway Interface, 即Python服务器网关接口. 是为Python语言定义的Web服务器和Web应用程序或Web应用框架之间的一种简单而通用的接口. WSGI只是一种通信协议. 更详细信息请查看维基百科WSGI.<br>通俗一点说就是写Python程序时不想花费大量的时间去处理TCP连接、HTTP的请求和响应等等, 于是就把这些都统一成了一个接口(即WSGI). 然后由专门的Web服务器(uWSGI等)和Web应用框架(Django等)去实现. 既降低了开发门槛又节约了时间.</li>
<li>uWSGI - uWSGI是一个实现了WSGI协议的Web服务器, uWSGI处理了HTTP的响应解析等, 并转成WSGI协议, 这样我们编写的Web应用程序或Web应用框架才可以对传递过来的信息进行处理.</li>
<li>uwsgi - uwsgi是实现了WSGI协议的服务器的内部自有协议, 它定义了传输信息的类型, 用于实现了WSGI协议的服务器与其他网络服务器的数据通信.</li>
</ul>
<p>了解了基本的概念之后, 就知道了为什么要Django+uWSGI. Django是Python的Web应用框架, 他帮我们做了很多基础工作, 让开发者可以专心的写业务代码. 而uWSGI是实现了WSGI协议的Web服务器, 只有这两者组合在一起, Python的应用程序才可以发挥作用.</p>
<p>理论上, 有了这一套, 就可以部署到服务器使用了. 而我们还要加上Nginx的原因, 当然是因为Nginx可以做一些uWSGI做不到的事情, 或者把事情做得更好.</p>
<p>Nginx是一款面向性能设计的HTTP服务器，相较于Apache具有占有内存少，稳定性高等优势. 可以被用作反向代理，负载平衡器 和 HTTP缓存. 所以使用Nginx的最大原因之一就是性能问题. 如果只是个小网站, 不会有很大了流量, 当然uWSGI可以满足要求, 但是在高并发情况下就需要Nginx了, 并且Nginx相比Apache有很大的高并发优势.</p>
<p>另外, Nginx能带来更好的安全性. 并且可以直接处理静态内容, 不需要通过uWSGI, 让uWSGI专心处理动态内容, 从而提高性能.</p>
<h1 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h1><p>我的机器已经安装了anaconda</p>
<ol>
<li><p>打开python虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ conda info <span class="_">-e</span></div><div class="line"><span class="comment"># conda environments:</span></div><div class="line"><span class="comment">#</span></div><div class="line">python27                 /home/chris/anaconda2/envs/python27</div><div class="line"></div><div class="line">$ <span class="built_in">source</span> activate python27</div></pre></td></tr></table></figure>
</li>
<li><p>安装nginx</p>
</li>
<li><p>安装uwsgi</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install uwsgi</div></pre></td></tr></table></figure>
</li>
</ol>
<p>安装完成后，出现了如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uwsgi --version</div><div class="line">uwsgi: error while loading shared libraries: libpcre.so.1: cannot open...</div></pre></td></tr></table></figure></p>
<p>可以按照下面的方法解决：<br><a href="https://stackoverflow.com/questions/43301339/pcre-issue-when-setting-up-wsgi-application" target="_blank" rel="external">https://stackoverflow.com/questions/43301339/pcre-issue-when-setting-up-wsgi-application</a></p>
<ol>
<li>在django项目下新建uwsgi.ini文件，配置如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># uwsig使用配置文件启动</div><div class="line">[uwsgi]</div><div class="line"># 项目目录</div><div class="line">chdir=/home/chris/myspace/python/myblog</div><div class="line"># 指定项目的application</div><div class="line">module=myblog.wsgi:application</div><div class="line"># 指定sock的文件路径   </div><div class="line">socket=127.0.0.1:8080    </div><div class="line">#socket=/home/chris/myspace/python/myblog/script/uwsgi.sock</div><div class="line"># 进程个数       </div><div class="line">workers=5</div><div class="line">pidfile=/home/chris/myspace/python/myblog/script/uwsgi.pid</div><div class="line"># 指定IP端口       </div><div class="line">http=127.0.0.1:8080</div><div class="line"># 指定静态文件</div><div class="line">static-map=/static=/home/chris/myspace/python/myblog/static</div><div class="line"># 启动uwsgi的用户名和用户组</div><div class="line">uid=root</div><div class="line">gid=root</div><div class="line"># 启用主进程</div><div class="line">master=true</div><div class="line"># 自动移除unix Socket和pid文件当服务停止的时候</div><div class="line">vacuum=true</div><div class="line"># 序列化接受的内容，如果可能的话</div><div class="line">thunder-lock=true</div><div class="line"># 启用线程</div><div class="line">enable-threads=true</div><div class="line"># 设置自中断时间</div><div class="line">harakiri=30</div><div class="line"># 设置缓冲</div><div class="line">post-buffering=100004096</div><div class="line"># 设置日志目录</div><div class="line">daemonize=/home/chris/myspace/python/myblog/script/uwsgi.log</div></pre></td></tr></table></figure>
</li>
</ol>
<p>socket参数这里配置为网络地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket=127.0.0.1:7070</div></pre></td></tr></table></figure></p>
<p>但如果Nginx和uWSGI同在一个服务器上，可以使用socket文件的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket=/home/chris/myspace/python/myblog/script/uwsgi.sock</div></pre></td></tr></table></figure></p>
<p>使用netstat查看8080端口，已经在监听，说明服务已启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(python27) $ sudo netstat -apn |grep 8080</div><div class="line">tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN      19700/uwsgi</div></pre></td></tr></table></figure></p>
<ol>
<li>配置nginx</li>
</ol>
<p>拷贝nginx默认的配置文件nginx.conf并重命名为nginx_django.conf，配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ···</div><div class="line">            server &#123;</div><div class="line">                listen       8000;</div><div class="line">                server_name  localhost;</div><div class="line">                location / &#123;</div><div class="line">                        include     /usr/local/nginx/conf/uwsgi_params;</div><div class="line">                        #include uwsgi_params;</div><div class="line">                        uwsgi_pass  127.0.0.1:8080;</div><div class="line">                        #uwsgi_pass unix:/home/chris/myspace/python/myblog/script/uwsgi.sock;</div><div class="line">                        uwsgi_connect_timeout      300; #nginx跟后端服务器连接超时时间(代理连接超时)</div><div class="line">                        uwsgi_send_timeout         300; #后端服务器数据回传时间(代理发送超时)</div><div class="line">                        uwsgi_read_timeout         300; #连接成功后，后端服务器响应时间(代理接收超时)</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>启动Nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nginx -c nginx_django.conf</div></pre></td></tr></table></figure>
</li>
<li><p>在浏览器访问nginx配置的端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:8000/index</div></pre></td></tr></table></figure>
</li>
</ol>
<p>到这里，就完了用Nginx+uWSGI+Django搭建Web服务。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[进程&线程]]></title>
      <url>http://hlei.io/2018/06/05/linux-process-thread/</url>
      <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="Linux创建进程采用fork-和exec"><a href="#Linux创建进程采用fork-和exec" class="headerlink" title="Linux创建进程采用fork()和exec()"></a>Linux创建进程采用fork()和exec()</h2><ul>
<li>fork: 采用复制当前进程的方式来创建子进程，此时子进程与父进程的区别仅在于pid, ppid以及资源统计量(比如挂起的信号)</li>
<li>exec：读取可执行文件并载入地址空间执行；一般称之为exec函数族，有一系列exec开头的函数，比如execl, execve等</li>
</ul>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><ul>
<li>Linux进程创建： 通过fork()系统调用创建进程</li>
<li>Linux用户级线程创建：通过pthread库中的pthread_create()创建线程</li>
<li>Linux内核线程创建： 通过kthread_create()<br>Linux线程，也并非”轻量级进程”，在Linux看来线程是一种进程间共享资源的方式，线程可看做是跟其他进程共享资源的进程。</li>
</ul>
<p>fork, vfork, clone根据不同参数调用do_fork：</p>
<ul>
<li>pthread_create: flags参数为 CLONE_VM, CLONE_FS, CLONE_FILES, CLONE_SIGHAND</li>
<li>fork: flags参数为 SIGCHLD</li>
<li>vfork: flags参数为 CLONE_VFORK, CLONE_VM, SIGCHLD</li>
</ul>
<h2 id="fork的具体流程"><a href="#fork的具体流程" class="headerlink" title="fork的具体流程"></a>fork的具体流程</h2><p>进程/线程创建的方法fork(),pthread_create(), 万物归一，最终在linux都是调用do_fork方法。 当然还有vfork其实也是一样的， 通过系统调用到sys_vfork，然后再调用do_fork方法，该方法 现在很少使用，所以下图省略该方法。</p>
<p><img src="/2018/06/05/linux-process-thread/linux-process01.jpg" alt="img01"></p>
<p>fork执行流程:</p>
<ol>
<li>用户空间调用fork()方法;</li>
<li>经过syscall陷入内核空间, 内核根据系统调用号找到相应的sys_fork系统调用;</li>
<li>sys_fork()过程会在调用do_fork(), 该方法参数有一个flags很重要, 代表的是父子进程之间需要共享的资源; 对于进程创建flags=SIGCHLD, 即当子进程退出时向父进程发送SIGCHLD信号;</li>
<li>do_fork(),会进行一些check过程,之后便是进入核心方法copy_process.</li>
</ol>
<h2 id="进程复制"><a href="#进程复制" class="headerlink" title="进程复制"></a>进程复制</h2><p>使用fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。</p>
<p>子进程与父进程的区别在于：</p>
<ol>
<li>父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）</li>
<li>各自的进程ID和父进程ID不同</li>
<li>子进程的未决告警被清除；</li>
<li>子进程的未决信号集设置为空集。</li>
</ol>
<h2 id="写时复制（copy-on-write）"><a href="#写时复制（copy-on-write）" class="headerlink" title="写时复制（copy on write）"></a>写时复制（copy on write）</h2><p>linux系统为了提高系统性能和资源利用率，在fork出一个新进程时，系统并没有真正复制一个副本。</p>
<p>如果多个进程要读取它们自己的那部分资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。</p>
<p>如果一个进程要修改自己的那份资源的“副本”，那么就会复制那份资源。这就是写时复制的含义</p>
<p>fork 和vfork：<br>在fork还没实现copy on write之前。Unix设计者很关心fork之后立刻执行exec所造成的地址空间浪费，所以引入了vfork系统调用。</p>
<p>vfork有个限制，子进程必须立刻执行_exit或者exec函数。</p>
<p>即使fork实现了copy on write，效率也没有vfork高，但是我们不推荐使用vfork，因为几乎每一个vfork的实现，都或多或少存在一定的问题。</p>
<h2 id="孤儿进程-amp-僵尸进程"><a href="#孤儿进程-amp-僵尸进程" class="headerlink" title="孤儿进程&amp;僵尸进程"></a>孤儿进程&amp;僵尸进程</h2><p>fork系统调用之后，父子进程将交替执行，执行顺序不定。</p>
<ul>
<li>孤儿进程：如果父进程先退出，子进程还没退出那么子进程的父进程将变为init进程（托孤给了init进程）。（注：任何一个进程都必须有父进程）</li>
<li><p>僵尸进程：如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程（僵尸进程：只保留一些退出信息供父进程查询）</p>
<pre><code>僵尸进程的影响：
比如进程采用exit()退出的时候，操作系统会进行一些列的处理工作，包括关闭打开的文件描述符、占用的内存等等，但是，操作系统也会为该进程保留少量的信息，以供父进程使用。例如进程的ID号、进程的退出状态、进程运行的CPU时间等，因而占用了系统的资源。
在一种极端的情况下，档僵尸进程过多的时候，占用了大量的进程ID，系统将无法产生新的进程，相当于系统的资源被耗尽。
</code></pre></li>
<li><p>代码例子-孤儿进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> childpid = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	</div><div class="line">	<span class="keyword">pid_t</span> pid = fork();</div><div class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">//child process</span></div><div class="line">		sleep(<span class="number">20</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"child:%d, parent: %d\n"</span>, getpid(), getppid());</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="comment">// char * execv_str[] = &#123;"echo", "executed by execv",NULL&#125;;</span></div><div class="line">		<span class="comment">// if (execv("/bin/echo",execv_str) &lt;0 )&#123;</span></div><div class="line">		<span class="comment">// 	perror("error on exec");</span></div><div class="line">		<span class="comment">// 	exit(0);</span></div><div class="line">		<span class="comment">// &#125;</span></div><div class="line">		</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"child process end\n\n"</span>);</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">//parent process</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"parent: %d\n"</span>, getpid());</div><div class="line">		<span class="comment">//sleep(20);</span></div><div class="line">		<span class="comment">//wait(NULL);</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"parent process end\n\n"</span>);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		perror(<span class="string">"fork"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>例子中先让父进程退出，子进程在fork后sleep一段时间，用ps命令查看进程信息，可以看到5083的父进程是1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ps <span class="_">-e</span>F |grep exec_test</div><div class="line">chris     5083     1  0  3180   172   3 17:01 pts/1    00:00:00 ./exec_test</div><div class="line">chris     5095  4391  0 24366   980   3 17:01 pts/2    00:00:00 grep --color=auto exec_test</div></pre></td></tr></table></figure></p>
<ul>
<li>代码例子-僵尸进程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> childpid = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	</div><div class="line">	<span class="keyword">pid_t</span> pid = fork();</div><div class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">//child process</span></div><div class="line">		<span class="comment">//sleep(20);</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"child:%d, parent: %d\n"</span>, getpid(), getppid());</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="comment">// char * execv_str[] = &#123;"echo", "executed by execv",NULL&#125;;</span></div><div class="line">		<span class="comment">// if (execv("/bin/echo",execv_str) &lt;0 )&#123;</span></div><div class="line">		<span class="comment">// 	perror("error on exec");</span></div><div class="line">		<span class="comment">// 	exit(0);</span></div><div class="line">		<span class="comment">// &#125;</span></div><div class="line">		</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"child process end\n\n"</span>);</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">//parent process</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"parent: %d\n"</span>, getpid());</div><div class="line">		sleep(<span class="number">30</span>);</div><div class="line">		<span class="comment">//wait(NULL);</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"parent process end\n\n"</span>);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		perror(<span class="string">"fork"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>父进程不调用wait等待子进程结束，使用ps命令查看进程状态，defunct表示僵尸进程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ps <span class="_">-e</span>F |grep exec_test</div><div class="line">chris     5225  3922  0  3181  1116   2 17:17 pts/1    00:00:00 ./exec_test</div><div class="line">chris     5226  5225  0     0     0   3 17:17 pts/1    00:00:00 [exec_test] &lt;defunct&gt;</div></pre></td></tr></table></figure></p>
<p>也可以这这样查询：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps <span class="_">-e</span> -o <span class="built_in">stat</span>,ppid,pid,cmd|egrep <span class="string">'^[Zz]'</span></div></pre></td></tr></table></figure></p>
<h2 id="如何避免僵尸进程"><a href="#如何避免僵尸进程" class="headerlink" title="如何避免僵尸进程"></a>如何避免僵尸进程</h2><p>我们可以使用如下几种方法避免僵尸进程的产生:</p>
<ol>
<li>在fork后调用wait/waitpid函数取得子进程退出状态。</li>
<li>调用fork两次（第一次调用产生一个子进程，第二次调用fork是在第一个子进程中调用，同时将父进程退出（第一个子进程退出），此时的第二个子进程的父进程id为init进程id。</li>
<li>在程序中显示忽略SIGCHLD信号（子进程退出时会产生一个SIGCHLD信号，我们显示忽略此信号即可）。</li>
<li>捕获SIGCHLD信号并在捕获程序中调用wait/waitpid函数。</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://gityuan.com/2017/08/05/linux-process-fork/" target="_blank" rel="external">http://gityuan.com/2017/08/05/linux-process-fork/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解c++引用]]></title>
      <url>http://hlei.io/2018/05/22/cpp-reference/</url>
      <content type="html"><![CDATA[<h2 id="底层实现分析"><a href="#底层实现分析" class="headerlink" title="底层实现分析"></a>底层实现分析</h2><ul>
<li><p>先看下面的一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        int x = 1;</div><div class="line">        int &amp;b = x;</div><div class="line">        printf(&quot;&amp;x=%x,&amp;b=%x\n&quot;,&amp;x,&amp;b);</div><div class="line">        printf(&quot;&amp;x=%x,&amp;x-1=%x\n&quot;,&amp;x,&amp;x-1);</div><div class="line">        printf(&quot;&amp;x=%x,&amp;b=%x\n&quot;,&amp;x,*(&amp;x-1));</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>汇编后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1 movl    $1, -12(%rbp)</div><div class="line">2 leaq    -12(%rbp), %rax</div><div class="line">3 movq    %rax, -8(%rbp)</div><div class="line">4 movl    $0, %eax</div><div class="line">5 popq    %rbp</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper介绍]]></title>
      <url>http://hlei.io/2018/05/22/distributed-system-zk-intro/</url>
      <content type="html"><![CDATA[<h1 id="一、系统模型"><a href="#一、系统模型" class="headerlink" title="一、系统模型"></a>一、系统模型</h1><h2 id="1-1-数据模型"><a href="#1-1-数据模型" class="headerlink" title="1.1 数据模型"></a>1.1 数据模型</h2><p>ZooKeeper的视图结构使用了其特有的“数据节点”概念，我们称之为ZNode。ZNode是ZooKeeper中数据的最小单元，每个ZNode上都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，我们称之为树。</p>
<h2 id="1-2-节点特性"><a href="#1-2-节点特性" class="headerlink" title="1.2 节点特性"></a>1.2 节点特性</h2><p>我们已知，ZooKeeper的命名空间是由一系列数据节点组成的，我们将对数据节点做详细讲解。</p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>在ZooKeeper中，每个数据节点都是有生命周期的，其生命周期的长短取决于数据节点的节点类型。在ZooKeeper中，节点类型可以分为持久节点(PERSISTENT)、临时节点(EPHEMERAL)和顺序节点(SEQUENTIAL)三大类，ju’ti具体在节点创建过程中，通过组合使用，可以生成以下四种组合型节点类型：</p>
<ul>
<li><p>持久节点(PERSISTENT)<br>数据节点被创建后，就会一直存在于ZooKeeper服务器上，直到有删除操作来主动清除这个节点。</p>
</li>
<li><p>持久顺序节点(PERSISTENT_SEQUENTIAL)<br>他的基本特性和持久节点是一致的，额外的特性表现在顺序性上。在ZooKeeper中，每个父节点都会为他的第一级子节点维护一份顺序，用于记录下每个子节点创建的先后顺序。基于这个顺序特性，在创建子节点的时候，可以设置这个标记，那么在创建节点过程中，ZooKeeper会自动为给定节点加上一个数字后缀，作为一个新的、完整的节点名。另外需要注意的是，这个数字后缀的上限是整型的最大值。</p>
</li>
<li><p>临时节点(EPHEMERAL)<br>临时节点的生命周期和客户端的会话绑定在一起，也就是说，如果客户端会话失效，那么这个节点就会被自动清理掉。这里提到的客户端会话失效，而非TCP连接断开。</p>
</li>
<li><p>临时顺序节点(EPHEMERAL_SEQUENTIAL)<br>在临时节点基础上，添加了顺序的特性。</p>
</li>
</ul>
<h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p>每个数据节点除了存储了数据内容外，还存储了数据节点本身的一些状态信息。</p>
<table>
<thead>
<tr>
<th>状态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>czxid</td>
<td>即Created ZXID，表示该节点被创建时的事务ID</td>
</tr>
<tr>
<td>mzxid</td>
<td>即Modified ZXID，表示该节点最后一次被更新时的事务ID</td>
</tr>
<tr>
<td>ctime</td>
<td>即Created Time</td>
</tr>
<tr>
<td>mtime</td>
<td>即Modified Time</td>
</tr>
<tr>
<td>version</td>
<td>数据节点的版本号</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点的版本号</td>
</tr>
<tr>
<td>aversion</td>
<td>节点的ACL版本号</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>创建该临时节点的会话的sessionID。如果该节点是持久节点，那么这个属性值为0</td>
</tr>
<tr>
<td>dataLength</td>
<td>数据内容长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>当前节点的子节点个数</td>
</tr>
<tr>
<td>pzxid</td>
<td>表示该节点的子节点列表最后一次被修改时的事务ID。注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响pzxid。</td>
</tr>
</tbody>
</table>
<h2 id="1-3-版本-保证分布式数据原子性操作"><a href="#1-3-版本-保证分布式数据原子性操作" class="headerlink" title="1.3 版本-保证分布式数据原子性操作"></a>1.3 版本-保证分布式数据原子性操作</h2><p>ZooKeeper中为数据节点引入了版本的概念，每个数据节点都具有三种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。</p>
<table>
<thead>
<tr>
<th>版本类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>version</td>
<td>当前数据节点数据内容的版本号</td>
</tr>
<tr>
<td>cversion</td>
<td>当前数据节点子节点的版本号</td>
</tr>
<tr>
<td>aversion</td>
<td>当前数据节点ACL变更版本号</td>
</tr>
</tbody>
</table>
<p>在ZooKeeper中，version属性正是用来实现乐观锁机制中的“写入校验”的。</p>
<h2 id="1-4-Watcher-数据变更的通知"><a href="#1-4-Watcher-数据变更的通知" class="headerlink" title="1.4 Watcher-数据变更的通知"></a>1.4 Watcher-数据变更的通知</h2><p>在ZooKeeper中，引入了Watcher机制来实现这种分布式的通知功能。ZooKeeper允许客户端向服务端注册一个Watcher监听，当服务器的一些指定事件出发了这个Watcher，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。<br>[img01]<br>从图中我们可以看到，ZooKeeper的Watcher机制主要包括客户端线程、客户端WatcherManager和ZooKeeper服务器三部分。在具体工作流程上，客户端在向ZooKeeper服务器注册Watcher的同时，会将Watcher对象存储在客户端的WatcherManager中。当ZooKeeper服务器端触发Watcher事件后，会向客户端发送通知，客户端线程从WatcherManager中取出对应的Watcher对象来执行回调逻辑。</p>
<h1 id="二、序列化协议"><a href="#二、序列化协议" class="headerlink" title="二、序列化协议"></a>二、序列化协议</h1><p>ZooKeeper的客户端和服务端之间会进行一系列的网络通信以实现数据的传输。对于一个网络通信，首先要解决的就是对数据的序列化和反序列化处理，在ZooKeeper中，使用了Jute这一序列化组件来进行数据的序列化和反序列化操作。同时，为了实现一个高效的网络通信程序，良好的通信协议设计也是至关重要的。</p>
<ul>
<li>通信协议<br>基于TCP/IP协议，ZooKeeper实现了自己的通信协议来完成客户端与服务端、服务端与服务端之间的网络通信。ZooKeeper通信协议整体上的设计非常简单，对于请求，主要包含请求头和请求体，对于响应，则主要包含响应头和相应体。</li>
</ul>
<h1 id="三、Leader选举"><a href="#三、Leader选举" class="headerlink" title="三、Leader选举"></a>三、Leader选举</h1><h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li>SID(myid)：服务器ID</li>
<li>ZXID：事务ID</li>
<li>Vote：投票</li>
<li>Quorum：过半机器数</li>
</ul>
<h2 id="各服务器角色介绍"><a href="#各服务器角色介绍" class="headerlink" title="各服务器角色介绍"></a>各服务器角色介绍</h2><ol>
<li><p>Leader<br>Leader服务器是整个ZooKeeper集群工作机制的核心，其主要工作有以下两个:<br>a. 事务请求的唯一调度和处理者，保证集群事务处理的顺序性。<br>b. 集群内部各服务器的调度者。</p>
</li>
<li><p>Follower<br>Follower服务器是ZooKeeper集群状态的跟随者，主要工作:<br>a. 处理客户端非事务请求，转发事务请求给Leader服务器。<br>b. 参与事务请求Proposal的投票<br>c. 参与Leader选举投票</p>
</li>
<li><p>Observer<br>工作原理与Follower基本一致，唯一区别在于Observer不参与任何形式的投票，包括事务请求Proposal的投票和Leader选举投票。简单的讲，Observer服务器只提供非事务服务，通常用于在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p>
</li>
</ol>
<h2 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h2><ul>
<li>LOOKING</li>
<li>FOLLOWING</li>
<li>LEADING</li>
<li>OBSERVING</li>
</ul>
<h2 id="服务器启动时leader选举"><a href="#服务器启动时leader选举" class="headerlink" title="服务器启动时leader选举"></a>服务器启动时leader选举</h2><p>假设有两台服务器s1、s2</p>
<ul>
<li><p>step1. <strong>每个server发出自己的投票</strong>，以 (myid, ZXID) 的形式表示一次投票，初始阶段都会将票投给自己，然后发给所有其他的机器，两台机器的投票如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s1-&gt;(1, 0)</div><div class="line">s2-&gt;(2, 0)</div></pre></td></tr></table></figure>
</li>
<li><p>step2. <strong>接受来自各个服务器的投票</strong>，集群中的每个服务器在接收到投票后，会先检查是否本轮投票、是否来自LOOKING状态的服务器</p>
</li>
<li><p>step3. <strong>处理投票</strong>，在接收到来自其他服务器的投票后，当前服务器需要和其进行pk，pk的规则如下：</p>
<ol>
<li>首先比较ZXID，ZXID大者优先作为LEADER</li>
<li>其次比较myid，myid大的作为LEADER<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">对于s1，更新投票信息为 (2, 0)，然后发给其他机器</div><div class="line">对于s2，不用更新投票信息，直接将原投票(2, 0)发给其他机器</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>step4. <strong>统计投票</strong>，每次投票后，服务器都会统计是否有过半的机器收到相同的投票信息（&gt;= n/2+1），若满足则认为已经选出了LEADER。</p>
</li>
<li>step5. <strong>改变服务器状态</strong>，若为LEADER则变为LEADING，若为FOLLOWER则变为FOLLOWING</li>
</ul>
<h2 id="服务器运行期间leader选举"><a href="#服务器运行期间leader选举" class="headerlink" title="服务器运行期间leader选举"></a>服务器运行期间leader选举</h2><p>在Zookeeper集群运行过程中，各自的角色一般不会变化，即使新加入机器或者FOLLOWER挂掉；但一旦LEADER挂掉，整个集群就暂时无法对外服务，会进入新一轮的LEADER选举，过程和启动时类似。</p>
<p>假设有s1、s2、s3三台服务器，s2是LEADER，s2挂了</p>
<ul>
<li>step1. <strong>变更状态</strong>，所有的FOLLOWER将状态变更为LOOKING，进入选角流程</li>
<li><p>step2. <strong>每个server发出自己的投票</strong>，由于是在运行过程中，每台机器的ZXID可能不同，s1、s3两台机器的投票如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s1-&gt;(1, 123)</div><div class="line">s3-&gt;(3, 122)</div></pre></td></tr></table></figure>
</li>
<li><p>step3. <strong>接受来自各个服务器的投票</strong></p>
</li>
<li>step4. <strong>处理投票</strong>，处理投票时pk的规则和启动时是一样的，s1最终会成为LEADER</li>
<li>step5. <strong>统计投票</strong></li>
<li>step6. <strong>改变服务器状态</strong></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[抓包工具介绍]]></title>
      <url>http://hlei.io/2018/05/12/network-grap-packet/</url>
      <content type="html"><![CDATA[<h1 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump (选项)</div></pre></td></tr></table></figure></p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">-a：尝试将网络和广播地址转换成名称；</div><div class="line">-c&lt;数据包数目&gt;：收到指定的数据包数目后，就停止进行倾倒操作；</div><div class="line">-d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出；</div><div class="line">-dd：把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出；</div><div class="line">-ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出；</div><div class="line">-e：在每列倾倒资料上显示连接层级的文件头；</div><div class="line">-f：用数字显示网际网络地址；</div><div class="line">-F&lt;表达文件&gt;：指定内含表达方式的文件；</div><div class="line">-i&lt;网络界面&gt;：使用指定的网络截面送出数据包；</div><div class="line">-l：使用标准输出列的缓冲区；</div><div class="line">-n：不把主机的网络地址转换成名字；</div><div class="line">-N：不列出域名；</div><div class="line">-O：不将数据包编码最佳化；</div><div class="line">-p：不让网络界面进入混杂模式；</div><div class="line">-q ：快速输出，仅列出少数的传输协议信息；</div><div class="line">-r&lt;数据包文件&gt;：从指定的文件读取数据包数据；</div><div class="line">-s&lt;数据包大小&gt;：设置每个数据包的大小；</div><div class="line">-S：用绝对而非相对数值列出TCP关联数；</div><div class="line">-t：在每列倾倒资料上不显示时间戳记；</div><div class="line">-tt： 在每列倾倒资料上显示未经格式化的时间戳记；</div><div class="line">-T&lt;数据包类型&gt;：强制将表达方式所指定的数据包转译成设置的数据包类型；</div><div class="line">-v：详细显示指令执行过程；</div><div class="line">-vv：更详细显示指令执行过程；</div><div class="line">-x：用十六进制字码列出数据包资料；</div><div class="line">-w&lt;数据包文件&gt;：把数据包数据写入指定的文件。</div></pre></td></tr></table></figure>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><ol>
<li>首先在端口5555启动一个监听程序</li>
<li><p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i lo tcp port 5555</div></pre></td></tr></table></figure>
</li>
<li><p>telnet连接这个端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet 127.0.0.1 5555</div></pre></td></tr></table></figure>
</li>
<li><p>抓包结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">17:46:14.089113 IP localhost.17827 &gt; localhost.5555: Flags [S], seq 3155508131, win 43690, options [mss 65495,sackOK,TS val 346898 ecr 0,nop,wscale 7], length 0</div><div class="line">17:46:14.089133 IP localhost.5555 &gt; localhost.17827: Flags [S.], seq 1578794747, ack 3155508132, win 43690, options [mss 65495,sackOK,TS val 346898 ecr 346898,nop,wscale 7], length 0</div><div class="line">17:46:14.089180 IP localhost.17827 &gt; localhost.5555: Flags [.], ack 1, win 342, options [nop,nop,TS val 346898 ecr 346898], length</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到tcp的三次握手的过程</p>
<h1 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h1><p>tcpdump 对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序(如Wireshark)进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cpp_sharedptr]]></title>
      <url>http://hlei.io/2018/05/09/cpp-sharedptr/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux-cache-line]]></title>
      <url>http://hlei.io/2018/04/21/linux-cache-line/</url>
      <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>cpu利用cache和内存之间交换数据的最小粒度不是字节，而是称为<a href="https://en.wikipedia.org/wiki/CPU_cache#Cache_entries" target="_blank" rel="external">cacheline</a>的一块固定大小的区域，<a href="http://cenalulu.github.io/linux/all-about-cpu-cache" target="_blank" rel="external">这篇文章</a>也对于cacheline作了很详细的分析</p>
<ul>
<li><p>Cache hierarchy<br>Cache的层次，一般有L1, L2, L3 （L是level的意思）的cache。通常来说L1，L2是集成  在CPU里面的（可以称之为On-chip cache），而L3是放在CPU外面（可以称之为Off-chip cache）。当然这个不是绝对的，不同CPU的做法可能会不太一样。这里面应该还需要加上register，虽然register不是cache，但是把数据放到register里面是能够提高性能的。</p>
</li>
<li><p>Cache size<br>Cache的容量决定了有多少代码和数据可以放到Cache里面，有了Cache才有了竞争，才有了替换，才有了优化的空间。如果一个程序的热点(hotspot)已经完全填充了整Cache，那么再从Cache角度考虑优化就是白费力气了，巧妇难为无米之炊。我们优化程序的目标是把程序尽可能放到Cache里面，但是把程序写到能够占满整个Cache还是有一定难度的，这么大的一个Code path，相应的代码得有多少，代码逻辑肯定是相当的复杂（基本上是不可能，至少我没有见过）。</p>
</li>
<li><p>Cache line size<br>CPU从内存load数据是一次一个cache line；往内存里面写也是一次一个cache line，所以一个cache line里面的数据最好是读写分开，否则就会相互影响。</p>
</li>
<li><p>Cache associative<br>Cache的关联。有全关联(full associative)，内存可以映射到任意一个Cache line；也有N-way关联，这个就是一个哈希表的结构，N就是冲突链的长度，超过了N，就需要替换。</p>
</li>
<li><p>Cache type<br>有I-cache（指令cache），D-cache（数据cache），TLB（MMU的cache），每一种又有L1,L2等等，有区分指令和数据的cache，也有不区分指令和数据的cache。</p>
</li>
</ul>
<h1 id="查看cacheline大小的方法"><a href="#查看cacheline大小的方法" class="headerlink" title="查看cacheline大小的方法"></a>查看cacheline大小的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</div><div class="line"></div><div class="line"># 如何在程序中利用好cacheline</div><div class="line">对于这个问题，brpc的文档中有这样的总结</div><div class="line"></div><div class="line"> 要提高性能，就要避免让CPU频繁同步cacheline。这不单和原子指令本身的性能有关，还会影响到程序的整体性能。最有效的解决方法很直白：尽量避免共享。</div><div class="line"></div><div class="line"> * 一个依赖全局多生产者多消费者队列(MPMC)的程序难有很好的多核扩展性，因为这个队列的极限吞吐取决于同步cache的延时，而不是核心的个数。最好是用多个SPMC或多个MPSC队列，甚至多个SPSC队列代替，在源头就规避掉竞争。</div><div class="line"> * 另一个例子是计数器，如果所有线程都频繁修改一个计数器，性能就会很差，原因同样在于不同的核心在不停地同步同一个cacheline。如果这个计数器只是用作打打日志之类的，那我们完全可以让每个线程修改thread-local变量，在需要时再合并所有线程中的值，性能可能有几十倍的差别。</div></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="external">http://cenalulu.github.io/linux/all-about-cpu-cache/</a></li>
<li><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="external">http://igoro.com/archive/gallery-of-processor-cache-effects/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[new，operate new和placement new]]></title>
      <url>http://hlei.io/2018/04/11/c-new/</url>
      <content type="html"><![CDATA[<ul>
<li>new：不能被重载，其行为总是一致的。先调用operator</li>
<li>new分配内存，然后调用构造函数初始化那段内存。</li>
<li>operator new：要实现不同的内存分配行为，应该重载operator new，而不是new。</li>
</ul>
<p>placement new：只是operator new重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此在删除该对象时，需要调用对象的析构函数。</p>
<p>下面重点讲placement new:</p>
<p>placement new 是重载operator new的一个标准、全局的版本，它不能被自定义的版本代替（不像普通的operator new和operator delete能够被替换成用户自定义的版本）。</p>
<p>它的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *operator new( size_t, void *p ) throw() &#123; return p; &#125;</div></pre></td></tr></table></figure></p>
<p>首先我们区分下几个容易混淆的关键词：new、operator new、placement new<br>new和delete操作符我们应该都用过，它们是对堆中的内存进行申请和释放，而这两个都是不能被重载的。要实现不同的内存分配行为，需要重载operator new，而不是new和delete。</p>
<p>看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;…&#125;;</div><div class="line">MyClass * p=new MyClass;</div></pre></td></tr></table></figure></p>
<p>这里的new实际上是执行如下3个过程：</p>
<ol>
<li>调用operator new分配内存；</li>
<li>调用构造函数生成类对象；</li>
<li>返回相应指针。</li>
</ol>
<p>operator new就像operator+一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的，一般你重载的其中一个，那么最后把其余的三个都重载一遍。</p>
<p>至于placement new才是本文的重点。其实它也只是operator new的一个重载的版本，只是我们很少用到它。如果你想在已经分配的内存中创建一个对象，使用new时行不通的。也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<p>我们知道使用new操作符分配内存需要在堆中查找足够大的剩余空间，这个操作速度是很慢的，而且有可能出现无法分配 内存的异常（空间不够）。 placement new就可以解决这个问题。我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途 出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。</p>
<p>使用方法如下：</p>
<ol>
<li><p>缓冲区提前分配<br>可以使用堆的空间，也可以使用栈的空间，所以分配方式有如下两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;…&#125;;</div><div class="line">char *buf=new char[N*sizeof(MyClass)+sizeof(int)];或者char buf[N*sizeof(MyClass)+sizeof(int)];</div></pre></td></tr></table></figure>
</li>
<li><p>对象的构造</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyClass * pClass=new(buf) MyClass;</div></pre></td></tr></table></figure>
</li>
<li><p>对象的销毁<br>一旦这个对象使用完毕，你必须显式的调用类的析构函数进行销毁对象。但此时内存空间不会被释放，以便其他的对象的构造。<br>pClass-&gt;~MyClass();</p>
</li>
<li><p>内存的释放<br>如果缓冲区在堆中，那么调用delete[] buf;进行内存的释放；如果在栈中，那么在其作用域内有效，跳出作用域，内存自动释放。</p>
</li>
</ol>
<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>在C++标准中，对于placement operator new []有如下的说明： placement operator new[] needs implementation-defined amount of additional storage to save a size of array. 所以我们必须申请比原始对象大小多出sizeof(int)个字节来存放对象的个数，或者说数组的大小。<br>使用方法第二步中的new才是placement new，其实是没有申请内存的，只是调用了构造函数，返回一个指向已经分配好的内存的一个指针，所以对象销毁的时候不需要调用delete释放空间，但必须调用析构函数销毁对象。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[原子操作剖析]]></title>
      <url>http://hlei.io/2018/04/09/linux-atomic-instructions/</url>
      <content type="html"><![CDATA[<p>我们都知道多核编程常用锁避免多个线程在修改同一个数据时产生<a href="http://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="external">race condition</a>。当锁成为性能瓶颈时，我们又总想试着绕开它，而不可避免地接触了原子指令。但在实践中，用原子指令写出正确的代码是一件非常困难的事，琢磨不透的race condition、<a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="external">ABA problem</a>、<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="external">memory fence</a>很烧脑，这篇文章试图通过介绍<a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing" target="_blank" rel="external">SMP</a>架构下的原子指令帮助大家入门。C++11正式引入了<a href="http://en.cppreference.com/w/cpp/atomic/atomic" target="_blank" rel="external">原子指令</a>，我们就以其语法描述。</p>
<p>顾名思义，原子指令是<strong>对软件</strong>不可再分的指令，比如x.fetch_add(n)指原子地给x加上n，这个指令<strong>对软件</strong>要么没做，要么完成，不会观察到中间状态。常见的原子指令有：</p>
<table>
<thead>
<tr>
<th>原子指令 (x均为std::atomic<int>)</int></th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x.load()</td>
<td>返回x的值。</td>
</tr>
<tr>
<td>x.store(n)</td>
<td>把x设为n，什么都不返回。</td>
</tr>
<tr>
<td>x.exchange(n)</td>
<td>把x设为n，返回设定之前的值。</td>
</tr>
<tr>
<td>x.compare_exchange_strong(expected_ref, desired)</td>
<td>若x等于expected_ref，则设为desired，返回成功；否则把最新值写入expected_ref，返回失败。</td>
</tr>
<tr>
<td>x.compare_exchange_weak(expected_ref, desired)</td>
<td>相比compare_exchange_strong可能有<a href="http://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="external">spurious wakeup</a>。</td>
</tr>
<tr>
<td>x.fetch_add(n), x.fetch_sub(n)</td>
<td>原子地做x += n, x-= n，返回修改之前的值。</td>
</tr>
</tbody>
</table>
<p>你已经可以用这些指令做原子计数，比如多个线程同时累加一个原子变量，以统计这些线程对一些资源的操作次数。但是，这可能会有两个问题：</p>
<ul>
<li>这个操作没有你想象地快。</li>
<li>如果你尝试通过看似简单的原子操作控制对一些资源的访问，你的程序有很大几率会crash。</li>
</ul>
<h1 id="Cacheline"><a href="#Cacheline" class="headerlink" title="Cacheline"></a>Cacheline</h1><p>没有任何竞争或只被一个线程访问的原子操作是比较快的，“竞争”指的是多个线程同时访问同一个<a href="https://en.wikipedia.org/wiki/CPU_cache#Cache_entries" target="_blank" rel="external">cacheline</a>。现代CPU为了以低价格获得高性能，大量使用了cache，并把cache分了多级。常见的Intel E5-2620拥有32K的L1 Data Cache和Instruction Cache，256K的L2 cache和15M的L3 cache。其中L1和L2 cache为每个核心独有，L3则所有核心共享。一个核心写入自己的L1 cache是极快的(4 cycles, ~2ns)，但当另一个核心读或写同一处内存时，它得确认看到其他核心中对应的cacheline。对于软件来说，这个过程是原子的，不能在中间穿插其他代码，只能等待CPU完成<a href="https://en.wikipedia.org/wiki/Cache_coherence" target="_blank" rel="external">一致性同步</a>，这个复杂的硬件算法使得原子操作会变得很慢，在E5-2620上竞争激烈时fetch_add会耗费700纳秒左右。访问被多个线程频繁共享的内存往往是比较慢的。比如像一些场景临界区看着很小，但保护它的spinlock性能不佳，因为spinlock使用的exchange, fetch_add等指令必须等待最新的cacheline，看上去只有几条指令，花费若干微秒并不奇怪。</p>
<p>要提高性能，就要避免让CPU频繁同步cacheline。这不单和原子指令本身的性能有关，还会影响到程序的整体性能。最有效的解决方法很直白：<strong>尽量避免共享</strong>。</p>
<ul>
<li>一个依赖全局多生产者多消费者队列(MPMC)的程序难有很好的多核扩展性，因为这个队列的极限吞吐取决于同步cache的延时，而不是核心的个数。最好是用多个SPMC或多个MPSC队列，甚至多个SPSC队列代替，在源头就规避掉竞争。</li>
<li>另一个例子是计数器，如果所有线程都频繁修改一个计数器，性能就会很差，原因同样在于不同的核心在不停地同步同一个cacheline。如果这个计数器只是用作打打日志之类的，那我们完全可以让每个线程修改thread-local变量，在需要时再合并所有线程中的值，性能可能有<a href="bvar.md">几十倍的差别</a>。</li>
</ul>
<p>一个相关的编程陷阱是false sharing：对那些不怎么被修改甚至只读变量的访问，由于同一个cacheline中的其他变量被频繁修改，而不得不经常等待cacheline同步而显著变慢了。多线程中的变量尽量按访问规律排列，频繁被其他线程修改的变量要放在独立的cacheline中。要让一个变量或结构体按cacheline对齐，可以include \<butil macros.h\="">后使用BAIDU_CACHELINE_ALIGNMENT宏，请自行grep brpc的代码了解用法。</butil></p>
<h1 id="Memory-fence"><a href="#Memory-fence" class="headerlink" title="Memory fence"></a>Memory fence</h1><p>仅靠原子技术实现不了对资源的访问控制，即使简单如<a href="https://en.wikipedia.org/wiki/Spinlock" target="_blank" rel="external">spinlock</a>或<a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="external">引用计数</a>，看上去正确的代码也可能会crash。这里的关键在于<strong>重排指令</strong>导致了读写顺序的变化。只要没有依赖，代码中在后面的指令就可能跑到前面去，<a href="http://preshing.com/20120625/memory-ordering-at-compile-time/" target="_blank" rel="external">编译器</a>和<a href="https://en.wikipedia.org/wiki/Out-of-order_execution" target="_blank" rel="external">CPU</a>都会这么做。</p>
<p>这么做的动机非常自然，CPU要尽量塞满每个cycle，在单位时间内运行尽量多的指令。如上节中提到的，访存指令在等待cacheline同步时要花费数百纳秒，最高效地自然是同时同步多个cacheline，而不是一个个做。一个线程在代码中对多个变量的依次修改，可能会以不同的次序同步到另一个线程所在的核心上。不同线程对数据的需求不同，按需同步也会导致cacheline的读序和写序不同。</p>
<p>如果其中第一个变量扮演了开关的作用，控制对后续变量的访问。那么当这些变量被一起同步到其他核心时，更新顺序可能变了，第一个变量未必是第一个更新的，然而其他线程还认为它代表着其他变量有效，去访问了实际已被删除的变量，从而导致未定义的行为。比如下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1</span></div><div class="line"><span class="comment">// ready was initialized to false</span></div><div class="line">p.init();</div><div class="line">ready = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread2</span></div><div class="line"><span class="keyword">if</span> (ready) &#123;</div><div class="line">    p.bar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从人的角度，这是对的，因为线程2在ready为true时才会访问p，按线程1的逻辑，此时p应该初始化好了。但对多核机器而言，这段代码可能难以正常运行：</p>
<ul>
<li>线程1中的ready = true可能会被编译器或cpu重排到p.init()之前，从而使线程2看到ready为true时，p仍然未初始化。这种情况同样也会在线程2中发生，p.bar()中的一些代码可能被重排到检查ready之前。</li>
<li>即使没有重排，ready和p的值也会独立地同步到线程2所在核心的cache，线程2仍然可能在看到ready为true时看到未初始化的p。</li>
</ul>
<p>注：x86/x64的load带acquire语意，store带release语意，上面的代码刨除编译器和CPU因素可以正确运行。</p>
<p>通过这个简单例子，你可以窥见原子指令编程的复杂性了吧。为了解决这个问题，CPU和编译器提供了<a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="external">memory fence</a>，让用户可以声明访存指令间的可见性(visibility)关系，boost和C++11对memory fence做了抽象，总结为如下几种<a href="http://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="external">memory order</a>.</p>
<table>
<thead>
<tr>
<th>memory order</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory_order_relaxed</td>
<td>没有fencing作用</td>
</tr>
<tr>
<td>memory_order_consume</td>
<td>后面依赖此原子变量的访存指令勿重排至此条指令之前</td>
</tr>
<tr>
<td>memory_order_acquire</td>
<td>后面访存指令勿重排至此条指令之前</td>
</tr>
<tr>
<td>memory_order_release</td>
<td>前面访存指令勿重排至此条指令之后。当此条指令的结果对其他线程可见后，之前的所有指令都可见</td>
</tr>
<tr>
<td>memory_order_acq_rel</td>
<td>acquire + release语意</td>
</tr>
<tr>
<td>memory_order_seq_cst</td>
<td>acq_rel语意外加所有使用seq_cst的指令有严格地全序关系</td>
</tr>
</tbody>
</table>
<p>有了memory order，上面的例子可以这么更正：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread1</span></div><div class="line"><span class="comment">// ready was initialized to false</span></div><div class="line">p.init();</div><div class="line">ready.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread2</span></div><div class="line"><span class="keyword">if</span> (ready.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</div><div class="line">    p.bar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程2中的acquire和线程1的release配对，确保线程2在看到ready==true时能看到线程1 release之前所有的访存操作。</p>
<p>注意，memory fence不等于可见性，即使线程2恰好在线程1在把ready设置为true后读取了ready也不意味着它能看到true，因为同步cache是有延时的。memory fence保证的是可见性的顺序：“假如我看到了a的最新值，那么我一定也得看到b的最新值”。</p>
<p>一个相关问题是：如何知道看到的值是新还是旧？一般分两种情况：</p>
<ul>
<li>值是特殊的。比如在上面的例子中，ready=true是个特殊值，只要线程2看到ready为true就意味着更新了。只要设定了特殊值，读到或没有读到特殊值都代表了一种含义。</li>
<li>总是累加。一些场景下没有特殊值，那我们就用fetch_add之类的指令累加一个变量，只要变量的值域足够大，在很长一段时间内，新值和之前所有的旧值都会不相同，我们就能区分彼此了。</li>
</ul>
<p>原子指令的例子可以看boost.atomic的<a href="http://www.boost.org/doc/libs/1_56_0/doc/html/atomic/usage_examples.html" target="_blank" rel="external">Example</a>，atomic的官方描述可以看<a href="http://en.cppreference.com/w/cpp/atomic/atomic" target="_blank" rel="external">这里</a>。</p>
<h1 id="wait-free-amp-lock-free"><a href="#wait-free-amp-lock-free" class="headerlink" title="wait-free &amp; lock-free"></a>wait-free &amp; lock-free</h1><p>原子指令能为我们的服务赋予两个重要属性：<a href="http://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom" target="_blank" rel="external">wait-free</a>和<a href="http://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom" target="_blank" rel="external">lock-free</a>。前者指不管OS如何调度线程，每个线程都始终在做有用的事；后者比前者弱一些，指不管OS如何调度线程，至少有一个线程在做有用的事。如果我们的服务中使用了锁，那么OS可能把一个刚获得锁的线程切换出去，这时候所有依赖这个锁的线程都在等待，而没有做有用的事，所以用了锁就不是lock-free，更不会是wait-free。为了确保一件事情总在确定时间内完成，实时系统的关键代码至少是lock-free的。在百度广泛又多样的在线服务中，对时效性也有着严苛的要求，如果RPC中最关键的部分满足wait-free或lock-free，就可以提供更稳定的服务质量。事实上，brpc中的读写都是wait-free的。</p>
<p>值得提醒的是，常见想法是lock-free或wait-free的算法会更快，但事实可能相反，因为：</p>
<ul>
<li>lock-free和wait-free必须处理更多更复杂的race condition和ABA problem，完成相同目的的代码比用锁更复杂。代码越多，耗时就越长。</li>
<li>使用mutex的算法变相带“后退”效果。后退(backoff)指出现竞争时尝试另一个途径以临时避免竞争，mutex出现竞争时会使调用者睡眠，使拿到锁的那个线程可以很快地独占完成一系列流程，总体吞吐可能反而高了。</li>
</ul>
<p>mutex导致低性能往往是因为临界区过大（限制了并发度），或竞争过于激烈（上下文切换开销变得突出）。lock-free/wait-free算法的价值在于其保证了一个或所有线程始终在做有用的事，而不是绝对的高性能。但在一种情况下lock-free和wait-free算法的性能多半更高：就是算法本身可以用少量原子指令实现。实现锁也是要用原子指令的，当算法本身用一两条指令就能完成的时候，相比额外用锁肯定是更快了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Redis持久化]]></title>
      <url>http://hlei.io/2018/04/03/redis-persistence/</url>
      <content type="html"><![CDATA[<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>Redis 提供了多种不同级别的持久化方式：</p>
<p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。<br>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。<br>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。<br>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。</p>
<h1 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a>RDB 的优点</h1><p>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</p>
<p>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</p>
<p>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</p>
<p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<h1 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h1><p>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</p>
<p>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</p>
<h1 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h1><p>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync策略，比如无 fsync，每秒钟一次 fsync，或者每次执行写入命令时 fsync 。</p>
<p>AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync<br>会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</p>
<p>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof<br>工具也可以轻易地修复这种问题。</p>
<p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
<p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</p>
<h1 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h1><p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。<br>根据所使用的 fsync策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync的性能依然非常高， 而关闭 fsync可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</p>
<p>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</p>
<h1 id="RDB-和-AOF-，我应该用哪一个？"><a href="#RDB-和-AOF-，我应该用哪一个？" class="headerlink" title="RDB 和 AOF ，我应该用哪一个？"></a>RDB 和 AOF ，我应该用哪一个？</h1><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p>
<p>因为以上提到的种种原因， 未来我们可能会将 AOF 和 RDB 整合成单个持久化模型。 （这是一个长期计划。）<br>接下来的几个小节将介绍 RDB 和 AOF 的更多细节。</p>
<h1 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h1><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。</p>
<p>你可以对 Redis 进行设置， 让它在“ N秒内数据集至少有 M个改动”这一条件被满足时， 自动保存一次数据集。</p>
<p>你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p>
<p>比如说， 以下设置会让 Redis 在满足“ 60秒内有至少有 1000个键被改动”这一条件时， 自动保存一次数据集：<br>save 60 1000</p>
<p>这种持久化方式被称为快照（snapshot）。</p>
<h1 id="快照的运作方式"><a href="#快照的运作方式" class="headerlink" title="快照的运作方式"></a>快照的运作方式</h1><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p>
<p>Redis 调用 fork() ，同时拥有父进程和子进程。<br>子进程将数据集写入到一个临时 RDB 文件中。<br>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。<br>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h1 id="只进行追加操作的文件（append-only-file，AOF）"><a href="#只进行追加操作的文件（append-only-file，AOF）" class="headerlink" title="只进行追加操作的文件（append-only file，AOF）"></a>只进行追加操作的文件（append-only file，AOF）</h1><p>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。</p>
<p>尽管对于某些程序来说， 数据的耐久性并不是最重要的考虑因素， 但是对于那些追求完全耐久能力（full durability）的程序来说， 快照功能就不太适用了。</p>
<p>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p>
<p>你可以通过修改配置文件来打开 AOF 功能：</p>
<p>appendonly yes</p>
<p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。</p>
<p>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p>
<h1 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h1><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。</p>
<p>举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。</p>
<p>然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p>
<p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。</p>
<p>执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p>
<p>Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件</p>
<h1 id="AOF-有多耐久？"><a href="#AOF-有多耐久？" class="headerlink" title="AOF 有多耐久？"></a>AOF 有多耐久？</h1><p>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。</p>
<p>有三个选项：</p>
<p>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。<br>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。<br>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。<br>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p>
<p>总是 fsync 的策略在实际使用中非常慢， 即使在 Redis 2.0 对相关的程序进行了改进之后仍是如此 —— 频繁调用 fsync 注定了这种策略不可能快得起来。</p>
<h1 id="如果-AOF-文件出错了，怎么办？-http-doc-redisfans-com-topic-persistence-html-id9"><a href="#如果-AOF-文件出错了，怎么办？-http-doc-redisfans-com-topic-persistence-html-id9" class="headerlink" title="如果 AOF 文件出错了，怎么办？(http://doc.redisfans.com/topic/persistence.html#id9)"></a>如果 AOF 文件出错了，怎么办？(<a href="http://doc.redisfans.com/topic/persistence.html#id9" target="_blank" rel="external">http://doc.redisfans.com/topic/persistence.html#id9</a>)</h1><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。</p>
<p>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p>
<p>为现有的 AOF 文件创建一个备份。<br>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。<br> $ redis-check-aof –fix</p>
<p>（可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。<br>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</p>
<h1 id="AOF-的运作方式"><a href="#AOF-的运作方式" class="headerlink" title="AOF 的运作方式"></a>AOF 的运作方式</h1><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。</p>
<p>以下是 AOF 重写的执行步骤：</p>
<p>Redis 执行 fork() ，现在同时拥有父进程和子进程。</p>
<p>子进程开始将新 AOF 文件的内容写入到临时文件。</p>
<p>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</p>
<p>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</p>
<p>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</p>
<h1 id="怎么从-RDB-持久化切换到-AOF-持久化"><a href="#怎么从-RDB-持久化切换到-AOF-持久化" class="headerlink" title="怎么从 RDB 持久化切换到 AOF 持久化"></a>怎么从 RDB 持久化切换到 AOF 持久化</h1><p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ：</p>
<p>为最新的 dump.rdb 文件创建一个备份。<br>将备份放到一个安全的地方。<br>执行以下两条命令：<br> redis-cli&gt; CONFIG SET appendonly yes<br> redis-cli&gt; CONFIG SET save “”</p>
<p>确保命令执行之后，数据库的键的数量没有改变。<br>确保写命令会被正确地追加到 AOF 文件的末尾。<br>步骤 3 执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</p>
<p>步骤 3 执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。</p>
<h1 id="RDB-和-AOF-之间的相互作用"><a href="#RDB-和-AOF-之间的相互作用" class="headerlink" title="RDB 和 AOF 之间的相互作用"></a>RDB 和 AOF 之间的相互作用</h1><p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。</p>
<p>这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p>
<p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK状态， 并告知用户，BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。</p>
<p>当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。</p>
<h1 id="备份-Redis-数据"><a href="#备份-Redis-数据" class="headerlink" title="备份 Redis 数据"></a>备份 Redis 数据</h1><p>在阅读这个小节前， 先将下面这句话铭记于心： 一定要备份你的数据库！</p>
<p>磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。</p>
<p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p>
<p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p>
<p>以下是我们的建议：</p>
<p>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。<br>确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。<br>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[signal]]></title>
      <url>http://hlei.io/2018/03/30/linux-signal/</url>
      <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>信号是软件中断。很多比较重要的应用程序都需处理信号。首先，每个信号都有一个名字。这些名字都以三个字符 SIG 开头。在头文件 <signal.h> 中，这些信号都被定义为正整数（信号编号）。</signal.h></p>
<h1 id="所有信号名称"><a href="#所有信号名称" class="headerlink" title="所有信号名称"></a>所有信号名称</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~/myspace/myblog$ kill -l</div><div class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</div><div class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</div><div class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</div><div class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</div><div class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</div><div class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</div><div class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</div><div class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</div><div class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</div><div class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</div><div class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</div><div class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</div><div class="line">63) SIGRTMAX-1	64) SIGRTMAX</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux最大文件数限制]]></title>
      <url>http://hlei.io/2018/03/30/linux-max-fd/</url>
      <content type="html"><![CDATA[<p>要知道,在linux的世界里,一切皆文件.因此要实现大的并发量的第一步,修改linux系统的文件标识符限制数,也就是文件打开数量的限制</p>
<h1 id="内核级的总限制-fs-file-max"><a href="#内核级的总限制-fs-file-max" class="headerlink" title="内核级的总限制 fs.file-max"></a>内核级的总限制 fs.file-max</h1><p>man proc 里有这么一段话<br><img src="/2018/03/30/linux-max-fd/linux_max_fd01.png" alt="img01"></p>
<ul>
<li><p>查看限制数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~/myspace/myblog$ sysctl fs.file-max</div><div class="line">fs.file-max = 3000000</div></pre></td></tr></table></figure>
</li>
<li><p>修改限制数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~/myspace/myblog$ sudo sysctl -w fs.file-max=3000000</div><div class="line">[sudo] password for chris: </div><div class="line">fs.file-max = 3000000</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要永久生效则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;fs.file-max=3000000&quot; &gt;&gt;/etc/sysctl.conf</div></pre></td></tr></table></figure></p>
<ul>
<li>查看使用情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~$ sysctl fs.file-nr</div><div class="line">fs.file-nr = 6816	0	3000000</div></pre></td></tr></table></figure>
</li>
</ul>
<p>其中第一个数表示当前系统已分配使用的打开文件描述符数，第二个数为分配后已释放的（目前已不再使用），第三个数等于file-max。</p>
<h1 id="用户级进程级的限制"><a href="#用户级进程级的限制" class="headerlink" title="用户级进程级的限制"></a>用户级进程级的限制</h1><h2 id="查看资源硬限制数"><a href="#查看资源硬限制数" class="headerlink" title="查看资源硬限制数"></a>查看资源硬限制数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~$ ulimit -Hn</div><div class="line">4096</div></pre></td></tr></table></figure>
<h2 id="查看资源软限制数"><a href="#查看资源软限制数" class="headerlink" title="查看资源软限制数"></a>查看资源软限制数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~$ ulimit -Sn</div><div class="line">1024</div></pre></td></tr></table></figure>
<pre><code>通过ulimit -Sn设置最大打开文件描述符数的soft limit，注意soft limit不能大于hard limit（ulimit -Hn可查看hard limit），另外ulimit -n默认查看的是soft limit，但是 ulimit -n 204800 则会同时设置soft limit和hard limit。对于非root用户只能设置比原来小的hard limit
</code></pre><p>若要使修改永久有效，则需要在/etc/security/limits.conf中进行设置，可添加如下两行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@work       hard    nofile  6000000</div><div class="line">@work       soft    nofile  4000000</div><div class="line">@work	    soft    core    4000000</div><div class="line">@work	    hard    core    4000000</div><div class="line">@work       hard    nproc   6000000</div><div class="line">@work       soft    nproc   4000000</div></pre></td></tr></table></figure></p>
<pre><code>以上设置需要注销之后重新登录才能生效：
设置nofile的hard limit还有一点要注意的就是hard limit不能大于/proc/sys/fs/nr_open，假如hard limit大于nr_open，注销后无法正常登录。可以修改nr_open的值： echo 2000000 &gt; /proc/sys/fs/nr_open
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内存问题定位]]></title>
      <url>http://hlei.io/2018/03/27/debug-memory/</url>
      <content type="html"><![CDATA[<h2 id="使用glibc的MALLOCCHECK"><a href="#使用glibc的MALLOCCHECK" class="headerlink" title="使用glibc的MALLOCCHECK"></a>使用glibc的MALLOC<em>CHECK</em></h2><p>因为是一个内存问题，考虑使用一些内存调试工具来定位问题。因为OB内部对于内存块有自己的缓存，需要去除它的影响。修改OB内存分配器，让它每次都直接调用c库的malloc和free等，不做缓存。然后，可以使用glibc内置的内存块完整性检查功能。</p>
<p>使用这一特性，程序无需重新编译，只需要在运行的时候设置环境变量MALLOC<em>CHECK</em>（注意结尾的下划线）。每当在程序运行过程free内存给glibc时，glibc会检查其隐藏的元数据的完整性，如果发现错误就会立即abort。</p>
<p>用类似下面的命令行启动server程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export MALLOC_CHECK_=2</div><div class="line">./test</div></pre></td></tr></table></figure></p>
<p>MALLOC<em>CHECK</em>有三种设定,即:</p>
<ul>
<li>MALLOC<em>CHECK</em>=0 —– 关闭所有检查.</li>
<li>MALLOC<em>CHECK</em>=1 —– 当有错误被探测到时,在标准错误输出(stderr)上打印错误信息.</li>
<li>MALLOC<em>CHECK</em>=2 —– 当有错误被探测到时,不显示错误信息,直接进行中断.</li>
</ul>
<p>但这个core能带给我们想信息也很少。我们只是找到了另外一种稍高效地重现问题的方法而已。或许最初看到的core的现象是延后显现而已，其实“更早”的时刻内存就被破坏掉了。</p>
<h2 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h2><p>glibc提供的MALLOC<em>CHECK</em>功能太简单了，有没有更高级点的工具不光能够报告错误，还能分析出问题原因来？我们自然想到了大名鼎鼎的valgrind。用valgrind来检查内存问题，程序也不需要重新编译，只需要使用valgrind来启动：</p>
<p>nohup valgrind –error-limit=no –suppressions=suppress bin/mergeserver -z 45447 -r 10.232.36.183:45401 -p45441 &gt;nohup.out &amp;</p>
<p>默认情况下，当valgrind发现了1000中不同的错误，或者总数超过1000万次错误后，会停止报告错误。加了–error-limit=no以后可以禁止这一特性。–suppressions用来屏蔽掉一些不关心的误报的问题。</p>
<h2 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h2><ol>
<li>版本要求: LLVM3.1 或者gcc4.8</li>
<li><p>bug代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int main (int argc,char *argv[])</div><div class="line">&#123;</div><div class="line">        int i;</div><div class="line">        char* p = (char *)malloc(10);</div><div class="line">        char* pt = p;</div><div class="line"></div><div class="line">        for (i = 0;i &lt; 10;i++)</div><div class="line">        &#123;</div><div class="line">                p[i] = &apos;z&apos;;</div><div class="line">        &#125;</div><div class="line">        free (p);</div><div class="line">        //free(pt);</div><div class="line"></div><div class="line">        *p = 1;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编译&amp;运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g++ -fsanitize=address test09.cpp -o test09</div><div class="line">./test09</div></pre></td></tr></table></figure>
</li>
<li><p>出错提示<br>[img01]</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux上Core Dump文件的形成和分析]]></title>
      <url>http://hlei.io/2018/03/27/linux-coredump/</url>
      <content type="html"><![CDATA[<p>Core，又称之为Core Dump文件，是Unix/Linux操作系统的一种机制，对于线上服务而言，Core令人闻之色变，因为出Core的过程意味着服务暂时不能正常响应，需要恢复，并且随着吐Core进程的内存空间越大，此过程可能持续很长一段时间（例如当进程占用60G+以上内存时，完整Core文件需要15分钟才能完全写到磁盘上），这期间产生的流量损失，不可估量。</p>
<p>凡事皆有两面性，OS在出Core的同时，虽然会终止掉当前进程，但是也会保留下第一手的现场数据，OS仿佛是一架被按下快门的相机，而照片就是产出的Core文件。里面含有当进程被终止时内存、CPU寄存器等信息，可以供后续开发人员进行调试。</p>
<p>关于Core产生的原因很多，比如过去一些Unix的版本不支持现代Linux上这种GDB直接附着到进程上进行调试的机制，需要先向进程发送终止信号，然后用工具阅读core文件。在Linux上，我们就可以使用kill向一个指定的进程发送信号或者使用gcore命令来使其主动出Core并退出。如果从浅层次的原因上来讲，出Core意味着当前进程存在BUG，需要程序员修复。从深层次的原因上讲，是当前进程触犯了某些OS层级的保护机制，逼迫OS向当前进程发送诸如SIGSEGV(即signal 11)之类的信号, 例如访问空指针或数组越界出Core，实际上是触犯了OS的内存管理，访问了非当前进程的内存空间，OS需要通过出Core来进行警示，这就好像一个人身体内存在病毒，免疫系统就会通过发热来警示，并导致人体发烧是一个道理（有意思的是，并不是每次数组越界都会出Core，这和OS的内存管理中虚拟页面分配大小和边界有关，即使不出Core，也很有可能读到脏数据，引起后续程序行为紊乱，这是一种很难追查的BUG）。</p>
<ol>
<li>修改core文件名格式<br>修改/proc/sys/kernel/core_pattern文件，此文件用于控制Core文件产生的文件名，默认情况下，此文件内容只有一行内容：“core”，此文件支持定制，一般使用%配合不同的字符，这里罗列几种：<ul>
<li>%p  出Core进程的PID</li>
<li>%u  出Core进程的UID</li>
<li>%s  造成Core的signal号</li>
<li>%t  出Core的时间，从1970-01-0100:00:00开始的秒数</li>
<li>%e  出Core进程对应的可执行文件名</li>
</ul>
</li>
</ol>
<p>不能直接修改，需要通过下面的方法：<br> a. vim /etc/sysctl.conf在最后一行添加kernel.core_uses_pid = 1<br> b. 执行sysctl -p</p>
<ol>
<li>修改core文件大小</li>
</ol>
<ul>
<li><p>查看core文件的大小<br>ulimit –a </p>
</li>
<li><p>修改core文件的大小<br>ulimit –c </p>
</li>
</ul>
<ol>
<li>文件格式<br>core文件是ELF格式，可以通过 readelf -h命令查看<br>[img01]</li>
</ol>
<p>像bmp、exe等文件一样，ELF的文件头包含整个文件的控制结构。它的定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct elf32_hdr &#123;  </div><div class="line">	unsigned char e_ident[EI_NIDENT];   </div><div class="line">	Elf32_Half    e_type;         /* file type */  </div><div class="line">	Elf32_Half    e_machine;      /* architecture */  </div><div class="line">	Elf32_Word    e_version;  </div><div class="line">	Elf32_Addr    e_entry;    	  /* entry point */  </div><div class="line">	Elf32_Off 	  e_phoff;        /* PH table offset */  </div><div class="line">	Elf32_Off 	  e_shoff;        /* SH table offset */  </div><div class="line">	Elf32_Word    e_flags;  </div><div class="line">	Elf32_Half    e_ehsize;       /* ELF header size in bytes */  </div><div class="line">	Elf32_Half    e_phentsize;    /* PH size */  </div><div class="line">	Elf32_Half    e_phnum;        /* PH number */  </div><div class="line">	Elf32_Half    e_shentsize;    /* SH size */  </div><div class="line">	Elf32_Half    e_shnum;        /* SH number */  </div><div class="line">	Elf32_Half    e_shstrndx;     /* SH name string table index */  </div><div class="line">&#125; Elf32_Ehdr;</div></pre></td></tr></table></figure></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>coredump函数在kernel/fs/exec.c中函数为do_coredump( )，如果coredump生成失败可以在do_coredump函数中增加打印，do_coredump的源代码如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line">void do_coredump(long signr, int exit_code, struct pt_regs *regs)</div><div class="line">&#123;</div><div class="line">	struct core_state core_state;</div><div class="line">	char corename[CORENAME_MAX_SIZE + 1];</div><div class="line">	struct mm_struct *mm = current-&gt;mm;</div><div class="line">	struct linux_binfmt * binfmt;</div><div class="line">	const struct cred *old_cred;</div><div class="line">	struct cred *cred;</div><div class="line">	int retval = 0;</div><div class="line">	int flag = 0;</div><div class="line">	int ispipe;</div><div class="line">	static atomic_t core_dump_count = ATOMIC_INIT(0);</div><div class="line">	struct coredump_params cprm = &#123;</div><div class="line">		.signr = signr,</div><div class="line">		.regs = regs,</div><div class="line">		.limit = rlimit(RLIMIT_CORE),</div><div class="line">		/*</div><div class="line">		 * We must use the same mm-&gt;flags while dumping core to avoid</div><div class="line">		 * inconsistency of bit flags, since this flag is not protected</div><div class="line">		 * by any locks.</div><div class="line">		 */</div><div class="line">		.mm_flags = mm-&gt;flags,</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	audit_core_dumps(signr);</div><div class="line">	binfmt = mm-&gt;binfmt;</div><div class="line"></div><div class="line">	//binfmt-&gt;core_dump根据内核宏初始化赋值core_dump函数，未开宏时为NULL</div><div class="line">	if (!binfmt || !binfmt-&gt;core_dump)</div><div class="line">		goto fail;</div><div class="line">	if (!__get_dumpable(cprm.mm_flags))</div><div class="line">		goto fail;</div><div class="line"></div><div class="line">	cred = prepare_creds();</div><div class="line">	if (!cred)</div><div class="line">		goto fail;</div><div class="line">	/*</div><div class="line">	 *	We cannot trust fsuid as being the &quot;true&quot; uid of the</div><div class="line">	 *	process nor do we know its entire history. We only know it</div><div class="line">	 *	was tainted so we dump it as root in mode 2.</div><div class="line">	 */</div><div class="line">	if (__get_dumpable(cprm.mm_flags) == 2) &#123;</div><div class="line">		/* Setuid core dump mode */</div><div class="line">		flag = O_EXCL;		/* Stop rewrite attacks */</div><div class="line">		cred-&gt;fsuid = 0;	/* Dump root private */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	retval = coredump_wait(exit_code, &amp;core_state);</div><div class="line">	if (retval &lt; 0)</div><div class="line">		goto fail_creds;</div><div class="line"></div><div class="line">	old_cred = override_creds(cred);</div><div class="line"></div><div class="line">	/*</div><div class="line">	 * Clear any false indication of pending signals that might</div><div class="line">	 * be seen by the filesystem code called to write the core file.</div><div class="line">	 */</div><div class="line">	clear_thread_flag(TIF_SIGPENDING);</div><div class="line"></div><div class="line">	//根据/proc/sys/kernel/core_pattern中值定义core文件名</div><div class="line">	ispipe = format_corename(corename, signr);</div><div class="line"></div><div class="line"> 	if (ispipe) &#123;</div><div class="line">		int dump_count;</div><div class="line">		char **helper_argv;</div><div class="line"></div><div class="line">		if (cprm.limit == 1) &#123;</div><div class="line">			/*</div><div class="line">			 * Normally core limits are irrelevant to pipes, since</div><div class="line">			 * we&apos;re not writing to the file system, but we use</div><div class="line">			 * cprm.limit of 1 here as a speacial value. Any</div><div class="line">			 * non-1 limit gets set to RLIM_INFINITY below, but</div><div class="line">			 * a limit of 0 skips the dump.  This is a consistent</div><div class="line">			 * way to catch recursive crashes.  We can still crash</div><div class="line">			 * if the core_pattern binary sets RLIM_CORE =  !1</div><div class="line">			 * but it runs as root, and can do lots of stupid things</div><div class="line">			 * Note that we use task_tgid_vnr here to grab the pid</div><div class="line">			 * of the process group leader.  That way we get the</div><div class="line">			 * right pid if a thread in a multi-threaded</div><div class="line">			 * core_pattern process dies.</div><div class="line">			 */</div><div class="line">			printk(KERN_WARNING</div><div class="line">				&quot;Process %d(%s) has RLIMIT_CORE set to 1\n&quot;,</div><div class="line">				task_tgid_vnr(current), current-&gt;comm);</div><div class="line">			printk(KERN_WARNING &quot;Aborting core\n&quot;);</div><div class="line">			goto fail_unlock;</div><div class="line">		&#125;</div><div class="line">		cprm.limit = RLIM_INFINITY;</div><div class="line"></div><div class="line">		dump_count = atomic_inc_return(&amp;core_dump_count);</div><div class="line">		if (core_pipe_limit &amp;&amp; (core_pipe_limit &lt; dump_count)) &#123;</div><div class="line">			printk(KERN_WARNING &quot;Pid %d(%s) over core_pipe_limit\n&quot;,</div><div class="line">			       task_tgid_vnr(current), current-&gt;comm);</div><div class="line">			printk(KERN_WARNING &quot;Skipping core dump\n&quot;);</div><div class="line">			goto fail_dropcount;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		helper_argv = argv_split(GFP_KERNEL, corename+1, NULL);</div><div class="line">		if (!helper_argv) &#123;</div><div class="line">			printk(KERN_WARNING &quot;%s failed to allocate memory\n&quot;,</div><div class="line">			       __func__);</div><div class="line">			goto fail_dropcount;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		retval = call_usermodehelper_fns(helper_argv[0], helper_argv,</div><div class="line">					NULL, UMH_WAIT_EXEC, umh_pipe_setup,</div><div class="line">					NULL, &amp;cprm);</div><div class="line">		argv_free(helper_argv);</div><div class="line">		if (retval) &#123;</div><div class="line"> 			printk(KERN_INFO &quot;Core dump to %s pipe failed\n&quot;,</div><div class="line">			       corename);</div><div class="line">			goto close_fail;</div><div class="line"> 		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		struct inode *inode;</div><div class="line">		</div><div class="line">		//根据进程的soft limit大小，soft limit大于coredump初始设置最小值=PAGE_SZIE</div><div class="line">		if (cprm.limit &lt; binfmt-&gt;min_coredump)</div><div class="line">			goto fail_unlock;</div><div class="line"></div><div class="line">		cprm.file = filp_open(corename,</div><div class="line">				 O_CREAT | 2 | O_NOFOLLOW | O_LARGEFILE | flag,</div><div class="line">				 0600);</div><div class="line">		if (IS_ERR(cprm.file))</div><div class="line">			goto fail_unlock;</div><div class="line"></div><div class="line">		inode = cprm.file-&gt;f_path.dentry-&gt;d_inode;</div><div class="line">		if (inode-&gt;i_nlink &gt; 1)</div><div class="line">			goto close_fail;</div><div class="line">		if (d_unhashed(cprm.file-&gt;f_path.dentry))</div><div class="line">			goto close_fail;</div><div class="line">		/*</div><div class="line">		 * AK: actually i see no reason to not allow this for named</div><div class="line">		 * pipes etc, but keep the previous behaviour for now.</div><div class="line">		 */</div><div class="line">		if (!S_ISREG(inode-&gt;i_mode))</div><div class="line">			goto close_fail;</div><div class="line">		/*</div><div class="line">		 * Dont allow local users get cute and trick others to coredump</div><div class="line">		 * into their pre-created files.</div><div class="line">		 */</div><div class="line">		if (inode-&gt;i_uid != current_fsuid())</div><div class="line">			goto close_fail;</div><div class="line">		if (!cprm.file-&gt;f_op || !cprm.file-&gt;f_op-&gt;write)</div><div class="line">			goto close_fail;</div><div class="line">		if (do_truncate(cprm.file-&gt;f_path.dentry, 0, 0, cprm.file))</div><div class="line">			goto close_fail;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//执行core_dump函数输出寄存器等信息到core文件中</div><div class="line">	retval = binfmt-&gt;core_dump(&amp;cprm);</div><div class="line">	if (retval)</div><div class="line">		current-&gt;signal-&gt;group_exit_code |= 0x80;</div><div class="line"></div><div class="line">	if (ispipe &amp;&amp; core_pipe_limit)</div><div class="line">		wait_for_dump_helpers(cprm.file);</div><div class="line">close_fail:</div><div class="line">	if (cprm.file)</div><div class="line">		filp_close(cprm.file, NULL);</div><div class="line">fail_dropcount:</div><div class="line">	if (ispipe)</div><div class="line">		atomic_dec(&amp;core_dump_count);</div><div class="line">fail_unlock:</div><div class="line">	coredump_finish(mm);</div><div class="line">	revert_creds(old_cred);</div><div class="line">fail_creds:</div><div class="line">	put_cred(cred);</div><div class="line">fail:</div><div class="line">	return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper部署]]></title>
      <url>http://hlei.io/2018/03/26/distributed-system-zk-install/</url>
      <content type="html"><![CDATA[<p>最新的版本可以通过官网 <a href="http://hadoop.apache.org/zookeeper/来获取，Zookeeper" target="_blank" rel="external">http://hadoop.apache.org/zookeeper/来获取，Zookeeper</a> 的安装非常简单，下面将从单机模式和集群模式两个方面介绍 Zookeeper 的安装和配置。</p>
<h1 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h1><ol>
<li><p>解压安装包zookerper-3.4.7.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xzvf zookerper-3.4.7.tar.gz</div></pre></td></tr></table></figure>
</li>
<li><p>创建Zookeeper子目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -r zookerper-3.4.7 zookerper</div></pre></td></tr></table></figure>
</li>
<li><p>修改Zookeeper配置文件conf/zoo.cfg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># The number of milliseconds of each tick</div><div class="line">tickTime=2000</div><div class="line"># The number of ticks that the initial </div><div class="line"># synchronization phase can take</div><div class="line">initLimit=10</div><div class="line"># The number of ticks that can pass between </div><div class="line"># sending a request and getting an acknowledgement</div><div class="line">syncLimit=5</div><div class="line"># the directory where the snapshot is stored.</div><div class="line"># do not use /tmp for storage, /tmp here is just </div><div class="line"># example sakes.</div><div class="line">dataDir=./data</div><div class="line">dataLogDir=./logs</div><div class="line"># the port at which the clients will connect</div><div class="line">clientPort=2181</div><div class="line"># the maximum number of client connections.</div><div class="line"># increase this if you need to handle more clients</div><div class="line">#maxClientCnxns=60</div><div class="line">#</div><div class="line"># Be sure to read the maintenance section of the </div><div class="line"># administrator guide before turning on autopurge.</div><div class="line">#</div><div class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</div><div class="line">#</div><div class="line"># The number of snapshots to retain in dataDir</div><div class="line">#autopurge.snapRetainCount=3</div><div class="line"># Purge task interval in hours</div><div class="line"># Set to &quot;0&quot; to disable auto purge feature</div><div class="line">#autopurge.purgeInterval=1</div></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd bin</div><div class="line">$ ./zkServer.sh start</div></pre></td></tr></table></figure>
</li>
<li><p>查看运行状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./zkServer.sh status</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="伪集群模式"><a href="#伪集群模式" class="headerlink" title="伪集群模式"></a>伪集群模式</h1><ol>
<li><p>新建两个directory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp -r zookeeper/ zookerper1/</div><div class="line">cp -r zookeeper/ zookerper2/</div></pre></td></tr></table></figure>
</li>
<li><p>修改Zookeeper配置文件conf/zoo.cfg,这里配置了3个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.1=localhost:2887:3887</div><div class="line">server.2=localhost:2888:3888</div><div class="line">server.3=localhost:2889:3889</div></pre></td></tr></table></figure>
</li>
<li><p>分别在data目录下添加myid文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo &quot;1&quot; &gt; myid</div><div class="line">echo &quot;2&quot; &gt; myid</div><div class="line">echo &quot;3&quot; &gt; myid</div></pre></td></tr></table></figure>
</li>
<li><p>分别运行3个实例</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql覆盖索引]]></title>
      <url>http://hlei.io/2018/03/24/mysql-covering-index/</url>
      <content type="html"><![CDATA[<p>概念</p>
<p>如果索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)，也就是平时所说的不需要回表操作</p>
<p>判断标准</p>
<p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p>
<p>注意<br>1、覆盖索引也并不适用于任意的索引类型，索引必须存储列的值<br>2、Hash 和full-text索引不存储值，因此MySQL只能使用B-TREE<br>3、并且不同的存储引擎实现覆盖索引都是不同的<br>4、并不是所有的存储引擎都支持它们<br>5、如果要使用覆盖索引，一定要注意SELECT 列表值取出需要的列，不可以是SELECT *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降，不能为了利用覆盖索引而这么做</p>
<p>InnoDB<br>1、覆盖索引查询时除了除了索引本身的包含的列，还可以使用其默认的聚集索引列<br>2、这跟INNOB的索引结构有关系，主索引是B+树索引存储，也即我们所说的数据行即索引，索引即数据<br>3、对于INNODB的辅助索引，它的叶子节点存储的是索引值和指向主键索引的位置，然后需要通过主键在查询表的字段值，所以辅助索引存储了主键的值<br>4、覆盖索引也可以用上INNODB 默认的聚集索引<br>5、innodb引擎的所有储存了主键ID，事务ID，回滚指针,非主键ID，他的查询就会是非主键ID也可覆盖来取得主键ID</p>
<p>覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不用读取数据有以下一些优点<br>1、索引项通常比记录要小，所以MySQL访问更少的数据<br>2、索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O<br>3、大多数据引擎能更好的缓存索引，比如MyISAM只缓存索引<br>4、覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了</p>
<p>在sakila的inventory表中，有一个组合索引(store_id,film_id)，对于只需要访问这两列的查 询，MySQL就可以使用索引，如下<br>表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `inventory` (</div><div class="line">  `inventory_id` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,</div><div class="line">  `film_id` smallint(5) unsigned NOT NULL,</div><div class="line">  `store_id` tinyint(3) unsigned NOT NULL,</div><div class="line">  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</div><div class="line">  PRIMARY KEY (`inventory_id`),</div><div class="line">  KEY `idx_fk_film_id` (`film_id`),</div><div class="line">  KEY `idx_store_id_film_id` (`store_id`,`film_id`),</div><div class="line">  CONSTRAINT `fk_inventory_film` FOREIGN KEY (`film_id`) REFERENCES `film` (`film_id`) ON UPDATE CASCADE,</div><div class="line">  CONSTRAINT `fk_inventory_store` FOREIGN KEY (`store_id`) REFERENCES `store` (`store_id`) ON UPDATE CASCADE</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=4582 DEFAULT CHARSET=utf8 |</div></pre></td></tr></table></figure></p>
<p>查询语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt;  EXPLAIN SELECT store_id, film_id FROM sakila.inventory\G</div><div class="line">*************************** 1. row ***************************</div><div class="line">           id: 1</div><div class="line">  select_type: SIMPLE</div><div class="line">        table: inventory</div><div class="line">         type: index</div><div class="line">possible_keys: NULL</div><div class="line">          key: idx_store_id_film_id</div><div class="line">      key_len: 3</div><div class="line">          ref: NULL</div><div class="line">         rows: 4581</div><div class="line">        Extra: Using index</div><div class="line">1 row in set (0.03 sec)</div></pre></td></tr></table></figure></p>
<p>在大多数引擎中，只有当查询语句所访问的列是索引的一部分时，索引才会覆盖。但是，InnoDB不限于此，InnoDB的二级索引在叶子节点中存储了 primary key的值。因此，sakila.actor表使用InnoDB，而且对于是last_name上有索引，所以，索引能覆盖那些访问actor_id的查 询，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT actor_id, last_name  FROM sakila.actor WHERE last_name = &apos;HOPPER&apos;\G</div><div class="line">*************************** 1. row ***************************</div><div class="line">           id: 1</div><div class="line">  select_type: SIMPLE</div><div class="line">        table: actor</div><div class="line">         type: ref</div><div class="line">possible_keys: idx_actor_last_name</div><div class="line">          key: idx_actor_last_name</div><div class="line">      key_len: 137</div><div class="line">          ref: const</div><div class="line">         rows: 2</div><div class="line">        Extra: Using where; Using index</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>使用索引进行排序</p>
<p>MySQL中，有两种方式生成有序结果集：一是使用filesort，二是按索引顺序扫描</p>
<p>利用索引进行排序操作是非常快的，而且可以利用同一索引同时进 行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序，如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引，其它情况都会使用filesort<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `actor` (</div><div class="line">  `actor_id` int(10) unsigned NOT NULL AUTO_INCREMENT,</div><div class="line">  `name` varchar(16) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `password` varchar(16) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  PRIMARY KEY (`actor_id`),</div><div class="line">  KEY `name` (`name`)</div><div class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;</div><div class="line">insert into actor(name,password) values (&apos;cat01&apos;,&apos;1234567&apos;),(&apos;cat02&apos;,&apos;1234567&apos;),(&apos;ddddd&apos;,&apos;1234567&apos;),(&apos;aaaaa&apos;,&apos;1234567&apos;);</div></pre></td></tr></table></figure></p>
<p>1、 explain select actor_id from actor order by actor_id \G<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select actor_id from actor order by actor_id \G</div><div class="line">*************************** 1. row ***************************</div><div class="line">           id: 1</div><div class="line">  select_type: SIMPLE</div><div class="line">        table: actor</div><div class="line">         type: index</div><div class="line">possible_keys: NULL</div><div class="line">          key: PRIMARY</div><div class="line">      key_len: 4</div><div class="line">          ref: NULL</div><div class="line">         rows: 4</div><div class="line">        Extra: Using index</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>2、explain select actor_id from actor order by password \G<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select actor_id from actor order by password \G</div><div class="line">*************************** 1. row ***************************</div><div class="line">           id: 1</div><div class="line">  select_type: SIMPLE</div><div class="line">        table: actor</div><div class="line">         type: ALL</div><div class="line">possible_keys: NULL</div><div class="line">          key: NULL</div><div class="line">      key_len: NULL</div><div class="line">          ref: NULL</div><div class="line">         rows: 4</div><div class="line">        Extra: Using filesort</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>3、explain select actor_id from actor order by name \G<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select actor_id from actor order by name \G</div><div class="line">*************************** 1. row ***************************</div><div class="line">           id: 1</div><div class="line">  select_type: SIMPLE</div><div class="line">        table: actor</div><div class="line">         type: index</div><div class="line">possible_keys: NULL</div><div class="line">          key: name</div><div class="line">      key_len: 50</div><div class="line">          ref: NULL</div><div class="line">         rows: 4</div><div class="line">        Extra: Using index</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>当MySQL不能使用索引进行排序时，就会利用自己的排序算法(快速排序算法)在内存(sort buffer)中对数据进行排序，如果内存装载不下，它会将磁盘上的数据进行分块，再对各个数据块进行排序，然后将各个块合并成有序的结果集（实际上就是外排序）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis Sentinel 介绍与部署]]></title>
      <url>http://hlei.io/2018/03/23/redis-sentinel/</url>
      <content type="html"><![CDATA[<h1 id="1-Sentinel介绍"><a href="#1-Sentinel介绍" class="headerlink" title="1. Sentinel介绍"></a>1. Sentinel介绍</h1><h2 id="1-1-主从复制的问题"><a href="#1-1-主从复制的问题" class="headerlink" title="1.1 主从复制的问题"></a>1.1 主从复制的问题</h2><p>Redis主从复制可将主节点数据同步给从节点，从节点此时有两个作用：</p>
<ul>
<li>一旦主节点宕机，从节点作为主节点的备份可以随时顶上来。</li>
<li>扩展主节点的读能力，分担主节点读压力。</li>
</ul>
<p>但是问题来了：</p>
<ul>
<li>一旦主节点宕机，从节点晋升成主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</li>
<li>主节点的写能力受到单机的限制。</li>
<li>主节点的存储能力受到单机的限制。<br>第一个问题，我们接下来讲的Sentinel就可以解决。而后两个问题，Redis也给出了方案Redis Cluster。</li>
</ul>
<h2 id="1-2-Redis-Sentinel的高可用"><a href="#1-2-Redis-Sentinel的高可用" class="headerlink" title="1.2 Redis Sentinel的高可用"></a>1.2 Redis Sentinel的高可用</h2><p>Redis Sentinel是一个分布式架构，包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当发现节点不可达时，会对节点做下线标识。</p>
<p>如果被标识的是主节点，他还会选择和其他Sentinel节点进行“协商”，当大多数的Sentinel节点都认为主节点不可达时，他们会选举出一个Sentinel节点来完成自动故障转移工作，同时将这个变化通知给Redis应用方。</p>
<p>整个过程完全自动，不需要人工介入，所以可以很好解决Redis的高可用问题。</p>
<p>接下来我们就通过部署一个Redis Sentinel实例来了解整体框架。</p>
<h1 id="2-Redis-Sentinel部署"><a href="#2-Redis-Sentinel部署" class="headerlink" title="2. Redis Sentinel部署"></a>2. Redis Sentinel部署</h1><p>我们部署的拓扑结构如图所示：<br>[img01]</p>
<p>分别有3个Sentinel节点，1个主节点，2个从节点组成一个Redis Sentinel。</p>
<table>
<thead>
<tr>
<th>role</th>
<th>IP</th>
<th>port</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td>127.0.0.1</td>
<td>6379</td>
</tr>
<tr>
<td>slave1</td>
<td>127.0.0.1</td>
<td>6380</td>
</tr>
<tr>
<td>slave2</td>
<td>127.0.0.1</td>
<td>6381</td>
</tr>
<tr>
<td>Sentinel1</td>
<td>127.0.0.1</td>
<td>26379</td>
</tr>
<tr>
<td>Sentinel2</td>
<td>127.0.0.1</td>
<td>26380</td>
</tr>
<tr>
<td>Sentinel3</td>
<td>127.0.0.1</td>
<td>26381</td>
</tr>
</tbody>
</table>
<h2 id="2-1-启动主节点"><a href="#2-1-启动主节点" class="headerlink" title="2.1 启动主节点"></a>2.1 启动主节点</h2><ul>
<li><p>配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">port 6379</div><div class="line">daemonize yes</div><div class="line">logfile &quot;6379.log&quot;</div><div class="line">dbfilename &quot;dump-6379.rdb&quot;</div><div class="line">dir &quot;/var/redis/data/&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>启动主节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜   sudo redis-server redis-6379.conf</div></pre></td></tr></table></figure>
</li>
<li><p>使用PING命令检测是否启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜   redis-cli -h 127.0.0.1 -p 6379 ping</div><div class="line">PONG</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-2-启动两个从节点"><a href="#2-2-启动两个从节点" class="headerlink" title="2.2 启动两个从节点"></a>2.2 启动两个从节点</h2><ul>
<li><p>配置（两个从节点配置相同，除了文件名有区分）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">port 6380</div><div class="line">daemonize yes</div><div class="line">logfile &quot;6380.log&quot;</div><div class="line">dbfilename &quot;dump-6380.rdb&quot;</div><div class="line">dir &quot;/var/redis/data/&quot; </div><div class="line">slaveof 127.0.0.1 6379      // 从属主节点</div></pre></td></tr></table></figure>
</li>
<li><p>启动两个从节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜   sudo redis-server redis-6380.conf </div><div class="line">➜   sudo redis-server redis-6381.conf</div></pre></td></tr></table></figure>
</li>
<li><p>使用PING命令检测是否启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜   redis-cli -h 127.0.0.1 -p 6380 ping</div><div class="line">PONG</div><div class="line">➜   redis-cli -h 127.0.0.1 -p 6381 ping</div><div class="line">PONG</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-3-确认主从关系"><a href="#2-3-确认主从关系" class="headerlink" title="2.3 确认主从关系"></a>2.3 确认主从关系</h2><ul>
<li>主节点视角<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜   redis-cli -h 127.0.0.1 -p 6379 INFO replication</div><div class="line"># Replication</div><div class="line">role:master</div><div class="line">connected_slaves:2</div><div class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=85,lag=0</div><div class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=85,lag=0</div><div class="line">......</div></pre></td></tr></table></figure>
</li>
</ul>
<p>*从节点视角（6380端口）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜   redis-cli -h 127.0.0.1 -p 6380 INFO replication</div><div class="line"># Replication</div><div class="line">role:slave</div><div class="line">master_host:127.0.0.1</div><div class="line">master_port:6379</div><div class="line">master_link_status:up</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="2-4-部署Sentinel节点"><a href="#2-4-部署Sentinel节点" class="headerlink" title="2.4 部署Sentinel节点"></a>2.4 部署Sentinel节点</h2><p>3个Sentinel节点的部署方法是相同的（端口不同）。以26379为例。</p>
<ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Sentinel节点的端口</div><div class="line">port 26379  </div><div class="line">dir /var/redis/data/</div><div class="line">logfile &quot;26379.log&quot;</div><div class="line"></div><div class="line">// 当前Sentinel节点监控 127.0.0.1:6379 这个主节点</div><div class="line">// 2代表判断主节点失败至少需要2个Sentinel节点节点同意</div><div class="line">// mymaster是主节点的别名</div><div class="line">sentinel monitor mymaster 127.0.0.1 6379 2</div><div class="line"></div><div class="line">//每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒且没有回复，则判定不可达</div><div class="line">sentinel down-after-milliseconds mymaster 30000</div><div class="line"></div><div class="line">//当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1</div><div class="line">sentinel parallel-syncs mymaster 1</div><div class="line"></div><div class="line">//故障转移超时时间为180000毫秒</div><div class="line">sentinel failover-timeout mymaster 180000</div></pre></td></tr></table></figure>
</li>
<li><p>启动（两种方法） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* redis-sentinel sentinel-26379.conf</div><div class="line">* redis-server sentinel-26379.conf --sentinel</div><div class="line"></div><div class="line">* 确认</div></pre></td></tr></table></figure>
</li>
</ul>
<p>➜   redis-cli -h 127.0.0.1 -p 26379 INFO Sentinel</p>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>sentinel_masters:1<br>sentinel_tilt:0<br>sentinel_running_scripts:0<br>sentinel_scripts_queue_length:0<br>sentinel_simulate_failure_flags:0<br>master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=1 //sentinels=1表示启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">部署三个Sentinel节点之后，真个拓扑结构如图所示：</div><div class="line">[img02]</div><div class="line"></div><div class="line">* 当部署号Redis Sentinel之后，会有如下变化 </div><div class="line"> * Sentinel节点自动发现了从节点、其余Sentinel节点。</div><div class="line"> * 去掉了默认配置，例如：parallel-syncs、failover-timeout。</div><div class="line"> * 新添加了纪元（epoch）参数。</div><div class="line"></div><div class="line">我们拿端口26379的举例，启动所有的Sentinel和数据节点后，配置文件如下：</div></pre></td></tr></table></figure></p>
<p>port 26379<br>dir “/var/redis/data”<br>sentinel myid 70a3e215c1a34b4d9925d170d9606e615a8874f2<br>sentinel monitor mymaster 127.0.0.1 6379 2<br>sentinel config-epoch mymaster 0<br>sentinel leader-epoch mymaster 0<br>daemonize yes<br>logfile “26379.log”<br>// 发现了两个从节点<br>sentinel known-slave mymaster 127.0.0.1 6381<br>sentinel known-slave mymaster 127.0.0.1 6380<br>// 发送了连个Sentinel节点<br>sentinel known-sentinel mymaster 127.0.0.1 26381 e1148ad6caf60302dd6d0dbd693cb3448e209ac2<br>sentinel known-sentinel mymaster 127.0.0.1 26380 39db5b040b21a52da5334dd2d798244c034b4fc3<br>sentinel current-epoch 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 2.5 故障转移实验</div><div class="line">先查看一下节点的进程pid</div></pre></td></tr></table></figure></p>
<p>➜   ps -aux | grep redis<br>root     18225  0.1  0.0  40208 11212 ?        Ssl  22:10   0:05 redis-server 127.0.0.1:6379<br>root     18234  0.0  0.0  38160  8364 ?        Ssl  22:10   0:04 redis-server 127.0.0.1:6380<br>root     18244  0.0  0.0  38160  8308 ?        Ssl  22:10   0:04 redis-server 127.0.0.1:6381<br>root     20568  0.1  0.0  38160  8460 ?        Ssl  23:05   0:02 redis-sentinel <em>:26379 [sentinel]<br>root     20655  0.1  0.0  38160  8296 ?        Ssl  23:07   0:02 redis-sentinel </em>:26380 [sentinel]<br>root     20664  0.1  0.0  38160  8312 ?        Ssl  23:07   0:02 redis-sentinel *:26381 [sentinel]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们干掉端口6379的主节点。</div></pre></td></tr></table></figure></p>
<p>➜   sudo kill -9 18225<br>➜   ps -aux | grep redis<br>root     18234  0.0  0.0  38160  8364 ?        Ssl  22:10   0:05 redis-server 127.0.0.1:6380<br>root     18244  0.0  0.0  38160  8308 ?        Ssl  22:10   0:05 redis-server 127.0.0.1:6381<br>root     20568  0.1  0.0  38160  8460 ?        Ssl  23:05   0:03 redis-sentinel <em>:26379 [sentinel]<br>root     20655  0.1  0.0  38160  8296 ?        Ssl  23:07   0:03 redis-sentinel </em>:26380 [sentinel]<br>root     20664  0.1  0.0  38160  8312 ?        Ssl  23:07   0:03 redis-sentinel *:26381 [sentinel]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">此时，Redis Sentinel对主节点进行客观下线（Objectively Down， 简称 ODOWN）的判断，确认主节点不可达，则通知从节点中止复制主节点的操作。</div><div class="line">[img03]</div><div class="line"></div><div class="line">当主节点下线时长超过配置的下线时长30000秒，Redis Sentinel执行故障转移操作。</div><div class="line"></div><div class="line">此时，我们查看一下Sentinel节点监控的主节点信息：</div></pre></td></tr></table></figure></p>
<p>127.0.0.1:26379&gt; sentinel masters<br>1)  1) “name”<br>    2) “mymaster”<br>    3) “ip”<br>    4) “127.0.0.1”<br>    5) “port”<br>    6) “6380”           //可以看到主节点已经成为6380端口的节点<br>    7) “runid”<br>    8) “084850ab4ff6c2f2502b185c8eab5bdd25a26ce2”<br>    9) “flags”<br>   10) “master”<br>    …………..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">看一下Sentinel节点监控的从节点信息：</div></pre></td></tr></table></figure></p>
<p>127.0.0.1:26379&gt; sentinel slaves mymaster<br>1)  1) “name”<br>    2) “127.0.0.1:6379”             //ip:port<br>    3) “ip”<br>    4) “127.0.0.1”<br>    5) “port”<br>    6) “6379”<br>    7) “runid”<br>    8) “”<br>    9) “flags”<br>   10) “s_down,slave,disconnected”  //端口6379的原主节点已经断开了连接<br>   …………..<br>2)  1) “name”<br>    2) “127.0.0.1:6381”<br>    3) “ip”<br>    4) “127.0.0.1”<br>    5) “port”<br>    6) “6381”<br>    7) “runid”<br>    8) “24495fe180e4fd64ac47467e0b2652894406e9e4”<br>    9) “flags”<br>   10) “slave”                      //本来的从节点，还是从节点的role<br>    …………..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">由以上信息可得，端口为6380的Redis数据节点成为新的主节点，端口为6379的旧主节点断开连接。如图所示：</div><div class="line">[img04]</div><div class="line"></div><div class="line">我们在试着重启端口6379的数据节点。</div></pre></td></tr></table></figure></p>
<p>➜   sudo redis-server redis-6379.conf<br>➜   ps -aux | grep redis<br>root     18234  0.1  0.0  40208 11392 ?        Ssl  5月22   0:06 redis-server 127.0.0.1:6380<br>root     18244  0.1  0.0  40208 10356 ?        Ssl  5月22   0:07 redis-server 127.0.0.1:6381<br>root     20568  0.1  0.0  38160  8460 ?        Ssl  5月22   0:05 redis-sentinel <em>:26379 [sentinel]<br>root     20655  0.1  0.0  38160  8296 ?        Ssl  5月22   0:05 redis-sentinel </em>:26380 [sentinel]<br>root     20664  0.1  0.0  38160  8312 ?        Ssl  5月22   0:05 redis-sentinel *:26381 [sentinel]<br>menwen   22475  0.0  0.0  14216  5920 pts/2    S+   5月22   0:00 redis-cli -p 26379<br>// 6379的数据节点已重启<br>root     22617  0.0  0.0  38160  8304 ?        Ssl  00:00   0:00 redis-server 127.0.0.1:6379<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">看看发生什么：</div></pre></td></tr></table></figure></p>
<p>127.0.0.1:26379&gt; sentinel slaves mymaster<br>1)  1) “name”<br>    2) “127.0.0.1:6379”     //6379端口的节点重启后，变成了”活”的从节点<br>    3) “ip”<br>    4) “127.0.0.1”<br>    5) “port”<br>    6) “6379”<br>    7) “runid”<br>    8) “de1b5c28483cf150d9550f8e338886706e952346”<br>    9) “flags”<br>   10) “slave”<br>    …………..<br>2)  1) “name”               //6381端口的节点没有变化，仍是从节点<br>    2) “127.0.0.1:6381”<br>    …………..<br>```</p>
<p>他被降级成为端口6380的从节点。<br>[img05]</p>
<p>从上面的逻辑架构和故障转移试验中，可以看出Redis Sentinel的以下几个功能。</p>
<ul>
<li>监控：Sentinel节点会定期检测Redis数据节点和其余Sentinel节点是否可达。</li>
<li>通知：Sentinel节点会将故障转移通知给应用方。</li>
<li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</li>
<li>配置提供者：在Redis Sentinel结构中，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息。</li>
</ul>
<h1 id="3-Sentinel配置说明"><a href="#3-Sentinel配置说明" class="headerlink" title="3. Sentinel配置说明"></a>3. Sentinel配置说明</h1><ul>
<li><p>sentinel monitor mymaster 127.0.0.1 6379 2</p>
<ul>
<li>当前Sentinel节点监控 127.0.0.1:6379 这个主节点</li>
<li>2代表判断主节点失败至少需要2个Sentinel节点节点同意</li>
<li>mymaster是主节点的别名</li>
</ul>
</li>
<li><p>sentinel down-after-milliseconds mymaster 30000</p>
<ul>
<li>每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒且没有回复，则判定不可达</li>
</ul>
</li>
<li><p>sentinel parallel-syncs mymaster 1</p>
<ul>
<li>当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1。<br>sentinel failover-timeout mymaster 180000</li>
</ul>
</li>
</ul>
<p>故障转移超时时间为180000<br>sentinel auth-pass \ \<br>如果Sentinel监控的主节点配置了密码，可以通过sentinel auth-pass配置通过添加主节点的密码，防止Sentinel节点无法对主节点进行监控。<br>例如：sentinel auth-pass mymaster MySUPER–secret-0123passw0rd<br>sentinel notification-script \ \<br>在故障转移期间，当一些警告级别的Sentinel事件发生（指重要事件，如主观下线，客观下线等）时，会触发对应路径的脚本，想脚本发送相应的事件参数。<br>例如：sentinel notification-script mymaster /var/redis/notify.sh<br>sentinel client-reconfig-script \ \<br>在故障转移结束后，触发应对路径的脚本，并向脚本发送故障转移结果的参数。<br>例如：sentinel client-reconfig-script mymaster /var/redis/reconfig.sh。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis集群方案应该怎么做]]></title>
      <url>http://hlei.io/2018/03/23/redis-cluster-solution/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[迭代器&生成器&装饰器]]></title>
      <url>http://hlei.io/2018/03/22/python-iterator/</url>
      <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合</p>
<p>特点：</p>
<ol>
<li>访问者不需要关心迭代器内部的结构，仅需通过next()方法不断去取下一个内容</li>
<li>不能随机访问集合中的某个值 ，只能从头到尾依次访问</li>
<li>访问到一半时不能往回退</li>
<li>便于循环比较大的数据集合，节省内存</li>
</ol>
<p>第一种方式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list=[&quot;hello&quot;,&quot;world&quot;,&quot;china&quot;]</div><div class="line">for i in list:</div><div class="line">	print i</div></pre></td></tr></table></figure></p>
<p>也是通常我们使用的遍历方式</p>
<p>第二种方式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; list=[&quot;hello&quot;,&quot;world&quot;,&quot;china&quot;]</div><div class="line">&gt;&gt;&gt; it=iter(list)</div><div class="line">&gt;&gt;&gt; while True:</div><div class="line">	try:</div><div class="line">		m=next(it)</div><div class="line">		print(m)</div><div class="line">	except StopIteration:</div><div class="line">		break</div></pre></td></tr></table></figure></p>
<p>列表推导<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</div><div class="line">&gt;&gt;&gt; type(L)</div><div class="line">&lt;type &apos;list&apos;&gt;</div></pre></td></tr></table></figure></p>
<p>range（10）返回的也是一个list</p>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<p> 一个函数调用时返回一个迭代器，那这个函数就叫做生成器（generator），如果函数中包含yield语法，那这个函数就会变成生成器。这个yield的主要效果呢，就是可以使函数中断，并保存中断状态，中断后，代码可以继续往下执行，过一段时间还可以再重新调用这个函数，从上次yield的下一句开始执行。</p>
<ul>
<li><p>用法一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</div><div class="line">&gt;&gt;&gt; g</div><div class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>用法二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def fab(n):</div><div class="line">	a = 0</div><div class="line">	b = 1</div><div class="line">	while a &lt;= n:</div><div class="line">		yield a</div><div class="line">		a, b = a+b, a</div><div class="line"></div><div class="line">for i in fab(5):</div><div class="line">	print i</div><div class="line"></div><div class="line">0</div><div class="line">1</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">5</div></pre></td></tr></table></figure>
</li>
</ul>
<p>xrange是一个生成器，而range是迭代器。</p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>不希望修改变原有函数定义，在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator，类似于设计模式中的装饰器模式。</p>
<p>代码示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    def inner(*args, **kwargs):</div><div class="line">        print(&quot;__func__ = %s&quot;, func.__name__)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return inner</div><div class="line"></div><div class="line">@log</div><div class="line">def now():</div><div class="line">    print &quot;2018/03/22&quot;</div><div class="line"></div><div class="line">(&apos;__func__ = %s&apos;, &apos;now&apos;)</div><div class="line">2018/03/22</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在线定位问题常用命令]]></title>
      <url>http://hlei.io/2018/03/21/linux-trouble-shooting/</url>
      <content type="html"><![CDATA[<p>有时候，有很多问题只有在线上或者预发环境才能发现，而线上又不能调试代码，所以线<br>上问题定位就只能看日志、系统状态和dump线程，介绍一些常用的工具，介绍一些常用命令定位线上问题。</p>
<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>在Linux命令行下使用TOP命令查看每个进程的情况，显示如下。<br><img src="/2018/03/21/linux-trouble-shooting/linux-trouble-shooting01.png" alt="img01"></p>
<ul>
<li>交互命令数字1查看每个CPU的性能数据</li>
<li>查看某个进程所有线程的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top -H -p pid</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="strace-amp-pstack"><a href="#strace-amp-pstack" class="headerlink" title="strace &amp; pstack"></a>strace &amp; pstack</h1><p>strace就是这样一款工具。通过它，我们可以跟踪程序执行过程中产生的系统调用及接收到的信号，帮助我们分析程序或命令执行中遇到的异常情况。</p>
<h2 id="1-一个简单的例子"><a href="#1-一个简单的例子" class="headerlink" title="1. 一个简单的例子"></a>1. 一个简单的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//main.c</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">　　int fd ;</div><div class="line">　　int i = 0 ;</div><div class="line">　　fd = open( “/tmp/foo”, O_RDONLY ) ;</div><div class="line">　　if ( fd &lt; 0 )</div><div class="line">　　　　i=5;</div><div class="line">　　else</div><div class="line">　　　　i=2;</div><div class="line">　　return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-strace跟踪输出"><a href="#2-strace跟踪输出" class="headerlink" title="2.strace跟踪输出"></a>2.strace跟踪输出</h2><p>使用以下命令，我们将使用strace对以上程序进行跟踪，并将结果重定向至main.strace文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ strace -o main.strace ./main</div></pre></td></tr></table></figure></p>
<p>接下来我们来看main.strace文件的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">lx@LX:~$ cat main.strace</div><div class="line">execve(&quot;./main&quot;, [&quot;./main&quot;], [/* 43 vars */]) = 0</div><div class="line">brk(0)                                  = 0x9ac4000</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7739000</div><div class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY)      = 3</div><div class="line">fstat64(3, &#123;st_mode=S_IFREG|0644, st_size=80682, ...&#125;) = 0</div><div class="line">mmap2(NULL, 80682, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7725000</div><div class="line">close(3)                                = 0</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/lib/i386-linux-gnu/libc.so.6&quot;, O_RDONLY) = 3</div><div class="line">read(3, &quot;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\220o\1\0004\0\0\0&quot;..., 512) = 512</div><div class="line">fstat64(3, &#123;st_mode=S_IFREG|0755, st_size=1434180, ...&#125;) = 0</div><div class="line">mmap2(NULL, 1444360, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x56d000</div><div class="line">mprotect(0x6c7000, 4096, PROT_NONE)     = 0</div><div class="line">mmap2(0x6c8000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x15a) = 0x6c8000</div><div class="line">mmap2(0x6cb000, 10760, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x6cb000</div><div class="line">close(3)                                = 0</div><div class="line">mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7724000</div><div class="line">set_thread_area(&#123;entry_number:-1 -&gt; 6, base_addr:0xb77248d0, limit:1048575, seg_32bit:1, contents:0, read_exec_    only:0, limit_in_pages:1, seg_not_present:0, useable:1&#125;) = 0</div><div class="line">mprotect(0x6c8000, 8192, PROT_READ)     = 0</div><div class="line">mprotect(0x8049000, 4096, PROT_READ)    = 0</div><div class="line">mprotect(0x4b0000, 4096, PROT_READ)     = 0</div><div class="line">munmap(0xb7725000, 80682)               = 0</div><div class="line">open(&quot;/tmp/foo&quot;, O_RDONLY)              = -1 ENOENT (No such file or directory)</div><div class="line">exit_group(5)                           = ?</div><div class="line">//标红的行号为方便说明而添加，非strace执行输出</div></pre></td></tr></table></figure></p>
<p>strace跟踪程序与系统交互时产生的系统调用，以上每一行就对应一个系统调用，格式为：</p>
<p>系统调用的名称( 参数… ) = 返回值  错误标志和描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Line 1:  对于命令行下执行的程序，execve(或exec系列调用中的某一个)均为strace输出系统调用中的第一个。strace首先调用fork或clone函数新建一个子进程，然后在子进程中调用exec载入需要执行的程序(这里为./main)</div><div class="line"></div><div class="line">Line 2:  以0作为参数调用brk，返回值为内存管理的起始地址(若在子进程中调用malloc，则从0x9ac4000地址开始分配空间)</div><div class="line"></div><div class="line">Line 3:  调用access函数检验/etc/ld.so.nohwcap是否存在</div><div class="line"></div><div class="line">Line 4:  使用mmap2函数进行匿名内存映射，以此来获取8192bytes内存空间，该空间起始地址为0xb7739000，关于匿名内存映射，可以看这里</div><div class="line"></div><div class="line">Line 6:  调用open函数尝试打开/etc/ld.so.cache文件，返回文件描述符为3</div><div class="line"></div><div class="line">Line 7:  fstat64函数获取/etc/ld.so.cache文件信息</div><div class="line"></div><div class="line">Line 8:  调用mmap2函数将/etc/ld.so.cache文件映射至内存，关于使用mmap映射文件至内存，可以看这里</div><div class="line"></div><div class="line">Line 9:  close关闭文件描述符为3指向的/etc/ld.so.cache文件</div><div class="line"></div><div class="line">Line12:  调用read，从/lib/i386-linux-gnu/libc.so.6该libc库文件中读取512bytes，即读取ELF头信息</div><div class="line"></div><div class="line">Line15:  使用mprotect函数对0x6c7000起始的4096bytes空间进行保护(PROT_NONE表示不能访问，PROT_READ表示可以读取)</div><div class="line"></div><div class="line">Line24:  调用munmap函数，将/etc/ld.so.cache文件从内存中去映射，与Line 8的mmap2对应</div><div class="line"></div><div class="line">Line25:  对应源码中使用到的唯一的系统调用——open函数，使用其打开/tmp/foo文件</div><div class="line"></div><div class="line">Line26:  子进程结束，退出码为5(为什么退出值为5？返回前面程序示例部分看看源码吧：)</div></pre></td></tr></table></figure>
<h2 id="3-输出分析"><a href="#3-输出分析" class="headerlink" title="3. 输出分析"></a>3. 输出分析</h2><p>呼呼！看完这么多系统调用函数，是不是有点摸不着北？让我们从整体入手，回到主题strace上来。</p>
<p>从上面输出可以发现，真正能与源码对应上的只有open这一个系统调用(Line25)，其他系统调用几乎都用于进行进程初始化工作：装载被执行程序、载入libc函数库、设置内存映射等。</p>
<p>源码中的if语句或其他代码在相应strace输出中并没有体现，因为它们并没有唤起系统调用。strace只关心程序与系统之间产生的交互，因而strace不适用于程序逻辑代码的排错和分析。</p>
<h2 id="4-常用选项"><a href="#4-常用选项" class="headerlink" title="4. 常用选项"></a>4. 常用选项</h2><ol>
<li>跟踪子进程 -f</li>
<li>记录系统调用时间</li>
</ol>
<p>strace还可以记录程序与系统交互时，各个系统调用发生时的时间信息，有r、t、tt、ttt、T等几个选项，它们记录时间的方式为：</p>
<p>-T:   记录各个系统调用花费的时间，精确到微秒</p>
<p>-r:   以第一个系统调用(通常为execve)计时，精确到微秒</p>
<p>-t:   时：分：秒</p>
<p>-tt:  时：分：秒 . 微秒</p>
<p>-ttt: 计算机纪元以来的秒数 . 微秒</p>
<p>比较常用的为T选项，因为其提供了每个系统调用花费时间。而其他选项的时间记录既包含系统调用时间，又算上用户级代码执行用时，参考意义就小一些。对部分时间选项我们可以组合起来使用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">strace -Tr ./main</div><div class="line">0.000000 execve(“./main”, [“main”], [/* 64 vars */]) = 0</div><div class="line">0.000931 fcntl64(0, F_GETFD)= 0 &lt;0.000012&gt;</div><div class="line">0.000090 fcntl64(1, F_GETFD)= 0 &lt;0.000022&gt;</div><div class="line">0.000060 fcntl64(2, F_GETFD)= 0 &lt;0.000012&gt;</div><div class="line">0.000054 uname(&#123;sys=”Linux”, node=”ion”, ...&#125;) = 0 &lt;0.000014&gt;</div><div class="line">0.000307 geteuid32()= 7903 &lt;0.000011&gt;</div><div class="line">0.000040 getuid32()= 7903 &lt;0.000012&gt;</div><div class="line">0.000039 getegid32()= 200 &lt;0.000011&gt;</div><div class="line">0.000039 getgid32()= 200 &lt;0.000011&gt;</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>最左边一列为-r选项对应的时间输出，最右边一列为-T选项对应的输出。</p>
<ol>
<li>跟踪正在运行的进程 strace -p PID</li>
</ol>
<h2 id="5-使用strace处理程序挂死实例"><a href="#5-使用strace处理程序挂死实例" class="headerlink" title="5. 使用strace处理程序挂死实例"></a>5. 使用strace处理程序挂死实例</h2><h3 id="挂死程序源码"><a href="#挂死程序源码" class="headerlink" title="挂死程序源码"></a>挂死程序源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//hang.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line">    getpid(); //该系统调用起到标识作用</div><div class="line">    if(argc &lt; 2)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;hang (user|system)\n&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if(!strcmp(argv[1], &quot;user&quot;))</div><div class="line">        while(1);</div><div class="line">    else if(!strcmp(argv[1], &quot;system&quot;))</div><div class="line">        sleep(500);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可向该程序传送user和system参数，以上代码使用死循环模拟用户态挂死，调用sleep模拟内核态程序挂死。</p>
<h3 id="strace跟踪输出"><a href="#strace跟踪输出" class="headerlink" title="strace跟踪输出"></a>strace跟踪输出</h3><ul>
<li><p>用户态挂死跟踪输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line">mprotect(0x8049000, 4096, PROT_READ)    = 0</div><div class="line">mprotect(0xb59000, 4096, PROT_READ)     = 0</div><div class="line">munmap(0xb77bf000, 80682)               = 0</div><div class="line">getpid()                                = 14539</div></pre></td></tr></table></figure>
</li>
<li><p>内核态挂死跟踪输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line">mprotect(0x8049000, 4096, PROT_READ)    = 0</div><div class="line">mprotect(0xddf000, 4096, PROT_READ)     = 0</div><div class="line">munmap(0xb7855000, 80682)               = 0</div><div class="line">getpid()                                = 14543</div><div class="line">rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0</div><div class="line">rt_sigaction(SIGCHLD, NULL, &#123;SIG_DFL, [], 0&#125;, 8) = 0</div><div class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</div><div class="line">nanosleep(&#123;500, 0&#125;,</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="输出分析"><a href="#输出分析" class="headerlink" title="输出分析"></a>输出分析</h3><p>用户态挂死情况下，strace在getpid()一行输出之后没有其他系统调用输出；进程在内核态挂死，最后一行的系统调用nanosleep不能完整显示，这里nanosleep没有返回值表示该调用尚未完成。</p>
<p>因而我们可以得出以下结论：使用strace跟踪挂死程序，如果最后一行系统调用显示完整，程序在逻辑代码处挂死；如果最后一行系统调用显示不完整，程序在该系统调用处挂死。</p>
<h1 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h1><ul>
<li>查看网络流量 /proc/net/dev<br><img src="/2018/03/21/linux-trouble-shooting/linux-trouble-shooting02.png" alt="img02"></li>
<li>查看连接数 /proc/net/snmp<br><img src="/2018/03/21/linux-trouble-shooting/linux-trouble-shooting03.png" alt="img03"></li>
<li>查看内存信息 /proc/meminfo<br><img src="/2018/03/21/linux-trouble-shooting/linux-trouble-shooting04.png" alt="img04"></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[惊群效应]]></title>
      <url>http://hlei.io/2018/03/19/network-thundering-herd/</url>
      <content type="html"><![CDATA[<h1 id="什么叫惊群现象"><a href="#什么叫惊群现象" class="headerlink" title="什么叫惊群现象"></a>什么叫惊群现象</h1><p>首先，我们看看维基百科对惊群的定义:</p>
<pre><code>The thundering herd problem occurs when a large number of processes waiting for an event are awoken when that event occurs, but only one process is able to proceed at a time. After the processes wake up, they all demand the resource and a decision must be made as to which process can continue. After the decision is made, the remaining processes are put back to sleep, only to all wake up again to request access to the resource.

This occurs repeatedly, until there are no more processes to be woken up. Because all the processes use system resources upon waking, it is more efficient if only one process was woken up at a time.

This may render the computer unusable, but it can also be used as a technique if there is no other way to decide which process should continue (for example when programming with semaphores).
</code></pre><p>惊群简单来说就是多个进程或者线程在等待同一个事件，当事件发生时，所有线程和进程都会被内核唤醒。唤醒后通常只有一个进程获得了该事件并进行处理，其他进程发现获取事件失败后又继续进入了等待状态，在一定程度上降低了系统性能。</p>
<h1 id="accept-惊群"><a href="#accept-惊群" class="headerlink" title="accept 惊群"></a>accept 惊群</h1><p>具体来说惊群通常发生在服务器的监听等待调用上，服务器创建监听socket，后fork多个进程，在每个进程中调用accept或者epoll_wait等待终端的连接。</p>
<p>那么这个问题真的存在吗？</p>
<p>事实上，历史上，Linux 的 accpet 确实存在惊群问题，但现在的内核都解决该问题了。即，当多个进程/线程都阻塞在对同一个 socket 的 accept 调用上时，当有一个新的连接到来，内核只会唤醒一个进程，其他进程保持休眠，压根就不会被唤醒。</p>
<p>测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;  </div><div class="line">#include &lt;sys/socket.h&gt;  </div><div class="line">#include &lt;netinet/in.h&gt;  </div><div class="line">#include &lt;arpa/inet.h&gt;  </div><div class="line">#include &lt;assert.h&gt;  </div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line"></div><div class="line">#define IP   &quot;127.0.0.1&quot;</div><div class="line">#define PORT  8888</div><div class="line">#define WORKER 4</div><div class="line"></div><div class="line">int worker(int listenfd, int i)</div><div class="line">&#123;</div><div class="line">    while (1) &#123;</div><div class="line">        printf(&quot;I am worker %d, begin to accept connection.\n&quot;, i);</div><div class="line">        struct sockaddr_in client_addr;  </div><div class="line">        socklen_t client_addrlen = sizeof( client_addr );  </div><div class="line">        int connfd = accept( listenfd, ( struct sockaddr* )&amp;client_addr, &amp;client_addrlen );  </div><div class="line">        if (connfd != -1) &#123;</div><div class="line">            printf(&quot;worker %d accept a connection success.\t&quot;, i);</div><div class="line">            printf(&quot;ip :%s\t&quot;,inet_ntoa(client_addr.sin_addr));</div><div class="line">            printf(&quot;port: %d \n&quot;,client_addr.sin_port);</div><div class="line">        &#125; else &#123;</div><div class="line">            printf(&quot;worker %d accept a connection failed,error:%s&quot;, i, strerror(errno));</div><div class="line">			close(connfd);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int i = 0;</div><div class="line">    struct sockaddr_in address;  </div><div class="line">    bzero(&amp;address, sizeof(address));  </div><div class="line">    address.sin_family = AF_INET;  </div><div class="line">    inet_pton( AF_INET, IP, &amp;address.sin_addr);  </div><div class="line">    address.sin_port = htons(PORT);  </div><div class="line">    int listenfd = socket(PF_INET, SOCK_STREAM, 0);  </div><div class="line">    assert(listenfd &gt;= 0);  </div><div class="line"></div><div class="line">    int ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));  </div><div class="line">    assert(ret != -1);  </div><div class="line"></div><div class="line">    ret = listen(listenfd, 5);  </div><div class="line">    assert(ret != -1);  </div><div class="line"></div><div class="line">    for (i = 0; i &lt; WORKER; i++) &#123;</div><div class="line">        printf(&quot;Create worker %d\n&quot;, i+1);</div><div class="line">        pid_t pid = fork();</div><div class="line">        /*child  process */</div><div class="line">        if (pid == 0) &#123;</div><div class="line">            worker(listenfd, i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (pid &lt; 0) &#123;</div><div class="line">            printf(&quot;fork error&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*wait child process*/</div><div class="line">    int status;</div><div class="line">    wait(&amp;status);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们对该服务器发起连接请求（用 telnet/curl 等模拟）时，会看到只有一个进程被唤醒。</p>
<h1 id="epoll惊群"><a href="#epoll惊群" class="headerlink" title="epoll惊群"></a>epoll惊群</h1><p>如上所述，accept 已经不存在惊群问题，但 epoll 上还是存在惊群问题。即，如果多个进程/线程阻塞在监听同一个 listening socket fd 的 epoll_wait 上，当有一个新的连接到来时，所有的进程都会被唤醒。</p>
<p>考虑如下场景：</p>
<p>主进程创建 socket, bind， listen 后，将该 socket 加入到 epoll 中，然后 fork 出多个子进程，每个进程都阻塞在 epoll_wait 上，如果有事件到来，则判断该事件是否是该 socket 上的事件，如果是，说明有新的连接到来了，则进行 accept 操作。为了简化处理，忽略后续的读写以及对 accept 返回的新的套接字的处理，直接断开连接。</p>
<p>那么，当新的连接到来时，是否每个阻塞在 epoll_wait 上的进程都会被唤醒呢？</p>
<p>很多博客中提到，测试表明虽然 epoll_wait 不会像 accept 那样只唤醒一个进程/线程，但也不会把所有的进程/线程都唤醒。</p>
<p>为了验证这个问题，我自己写了一个测试程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">#include &lt;sys/epoll.h&gt;</div><div class="line">#include &lt;netdb.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;netinet/in.h&gt;</div><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line"></div><div class="line">#define IP   &quot;127.0.0.1&quot;</div><div class="line">#define PORT  8888</div><div class="line">#define PROCESS_NUM 4</div><div class="line">#define MAXEVENTS 64</div><div class="line"></div><div class="line">static int create_and_bind ()</div><div class="line">&#123;</div><div class="line">    int fd = socket(PF_INET, SOCK_STREAM, 0);</div><div class="line">    struct sockaddr_in serveraddr;</div><div class="line">    serveraddr.sin_family = AF_INET;</div><div class="line">    inet_pton( AF_INET, IP, &amp;serveraddr.sin_addr);  </div><div class="line">    serveraddr.sin_port = htons(PORT);</div><div class="line">    bind(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr));</div><div class="line">    return fd;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int make_socket_non_blocking (int sfd)</div><div class="line">&#123;</div><div class="line">    int flags, s;</div><div class="line">    flags = fcntl (sfd, F_GETFL, 0);</div><div class="line">    if (flags == -1) &#123;</div><div class="line">        perror (&quot;fcntl&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    flags |= O_NONBLOCK;</div><div class="line">    s = fcntl (sfd, F_SETFL, flags);</div><div class="line">    if (s == -1) &#123;</div><div class="line">        perror (&quot;fcntl&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void worker(int sfd, int efd, struct epoll_event *events, int k) &#123;</div><div class="line">    /* The event loop */</div><div class="line">    while (1) &#123;</div><div class="line">        int n, i;</div><div class="line">        n = epoll_wait(efd, events, MAXEVENTS, -1);</div><div class="line">        //sleep(1);</div><div class="line">        printf(&quot;worker  %d return from epoll_wait!\n&quot;, k);</div><div class="line">        for (i = 0; i &lt; n; i++) &#123;</div><div class="line">            if ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp;EPOLLIN))) &#123;</div><div class="line">                /* An error has occured on this fd, or the socket is not ready for reading (why were we notified then?) */</div><div class="line">                fprintf (stderr, &quot;epoll error\n&quot;);</div><div class="line">                close (events[i].data.fd);</div><div class="line">                continue;</div><div class="line">            &#125; else if (sfd == events[i].data.fd) &#123;</div><div class="line">                /* We have a notification on the listening socket, which means one or more incoming connections. */</div><div class="line">                struct sockaddr in_addr;</div><div class="line">                socklen_t in_len;</div><div class="line">                int infd;</div><div class="line">                char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</div><div class="line">                in_len = sizeof in_addr;</div><div class="line">                infd = accept(sfd, &amp;in_addr, &amp;in_len);</div><div class="line">                if (infd == -1) &#123;</div><div class="line">                    printf(&quot;worker %d accept failed!\n&quot;, k);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                printf(&quot;worker %d accept successed!\n&quot;, k);</div><div class="line">                /* Make the incoming socket non-blocking and add it to the list of fds to monitor. */</div><div class="line">                close(infd); </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main (int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int sfd, s;</div><div class="line">    int efd;</div><div class="line">    struct epoll_event event;</div><div class="line">    struct epoll_event *events;</div><div class="line">    sfd = create_and_bind();</div><div class="line">    if (sfd == -1) &#123;</div><div class="line">        abort ();</div><div class="line">    &#125;</div><div class="line">    s = make_socket_non_blocking (sfd);</div><div class="line">    if (s == -1) &#123;</div><div class="line">        abort ();</div><div class="line">    &#125;</div><div class="line">    s = listen(sfd, SOMAXCONN);</div><div class="line">    if (s == -1) &#123;</div><div class="line">        perror (&quot;listen&quot;);</div><div class="line">        abort ();</div><div class="line">    &#125;</div><div class="line">    efd = epoll_create(MAXEVENTS);</div><div class="line">    if (efd == -1) &#123;</div><div class="line">        perror(&quot;epoll_create&quot;);</div><div class="line">        abort();</div><div class="line">    &#125;</div><div class="line">    event.data.fd = sfd;</div><div class="line">    event.events = EPOLLIN | EPOLLEXCLUSIVE;</div><div class="line">    s = epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &amp;event);</div><div class="line">    if (s == -1) &#123;</div><div class="line">        perror(&quot;epoll_ctl&quot;);</div><div class="line">        abort();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Buffer where events are returned */</div><div class="line">    events = (struct epoll_event*)calloc(MAXEVENTS, sizeof event);</div><div class="line">    int k;</div><div class="line">    for(k = 0; k &lt; PROCESS_NUM; k++) &#123;</div><div class="line">        printf(&quot;Create worker %d\n&quot;, k+1);</div><div class="line">        int pid = fork();</div><div class="line">        if(pid == 0) &#123;</div><div class="line">            worker(sfd, efd, events, k);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int status;</div><div class="line">    wait(&amp;status);</div><div class="line">    free (events);</div><div class="line">    close (sfd);</div><div class="line">    return EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行server端后用telnet连，出现了2个进程被唤醒的情况，并不是每次都出现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">worker  3 return from epoll_wait!</div><div class="line">worker 3 accept successed!</div><div class="line">worker  2 return from epoll_wait!</div><div class="line">worker 2 accept failed!</div></pre></td></tr></table></figure></p>
<p>也就是说，到目前为止，还没有得到一个确定的答案。但后来，在下面这篇博客中看到这样一个评论：<a href="http://blog.csdn.net/spch2008/article/details/18301357" target="_blank" rel="external">http://blog.csdn.net/spch2008/article/details/18301357</a></p>
<p>这个总结，需要进一步阐述，你的实验，看上去是只有4个进程唤醒了，而事实上，其余进程没有被唤醒的原因是你的某个进程已经处理完这个 accept，内核队列上已经没有这个事件，无需唤醒其他进程。你可以在 epoll 获知这个 accept 事件的时候，不要立即去处理，而是 sleep 下，这样所有的进程都会被唤起</p>
<p>看到这个评论后，我顿时如醍醐灌顶，重新修改了上面的测试程序，即在 epoll_wait 返回后，加了个 sleep 语句，这时再测试，果然发现所有的进程都被唤醒了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">worker  1 return from epoll_wait!</div><div class="line">worker  3 return from epoll_wait!</div><div class="line">worker 1 accept successed!</div><div class="line">worker 3 accept failed!</div><div class="line">worker  2 return from epoll_wait!</div><div class="line">worker 2 accept failed!</div><div class="line">worker  0 return from epoll_wait!</div><div class="line">worker 0 accept failed!</div></pre></td></tr></table></figure></p>
<p>所以，epoll_wait上的惊群确实是存在的。</p>
<h1 id="为什么内核不处理-epoll-惊群"><a href="#为什么内核不处理-epoll-惊群" class="headerlink" title="为什么内核不处理 epoll 惊群"></a>为什么内核不处理 epoll 惊群</h1><p>看到这里，我们可能有疑惑了，为什么内核对 accept 的惊群做了处理，而现在仍然存在 epoll 的惊群现象呢？</p>
<p>accept 确实应该只能被一个进程调用成功，内核很清楚这一点。但 epoll 不一样，他监听的文件描述符，除了可能后续被 accept 调用外，还有可能是其他网络 IO 事件的，而其他 IO 事件是否只能由一个进程处理，是不一定的，内核不能保证这一点，这是一个由用户决定的事情，例如可能一个文件会由多个进程来读写。所以，对 epoll 的惊群，内核则不予处理。</p>
<h1 id="Nginx-是如何处理惊群问题的"><a href="#Nginx-是如何处理惊群问题的" class="headerlink" title="Nginx 是如何处理惊群问题的"></a>Nginx 是如何处理惊群问题的</h1><h1 id="使用EPOLLEXCLUSIVE"><a href="#使用EPOLLEXCLUSIVE" class="headerlink" title="使用EPOLLEXCLUSIVE"></a>使用EPOLLEXCLUSIVE</h1><p>Linux 4.5解决了这一问题，使用EPOLLEXCLUSIVE标记，但我自己的系统还没这么新，留待之后验证。<br><a href="http://www.man7.org/linux/man-pages/man2/epoll_ctl.2.html" target="_blank" rel="external">http://www.man7.org/linux/man-pages/man2/epoll_ctl.2.html</a></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>现在我们对惊群及 Nginx 的处理总结如下：</p>
<ul>
<li>accept 不会有惊群(since linux2.6)，epoll_wait 才会。</li>
<li>Nginx 的 accept_mutex,并不是解决 accept 惊群问题，而是解决 epoll_wait 惊群问题。</li>
<li>说Nginx 解决了 epoll_wait 惊群问题，也是不对的，它只是控制是否将监听套接字加入到epoll 中。监听套接字只在一个子进程的 epoll 中，当新的连接来到时，其他子进程当然不会惊醒了。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[各种锁的总结]]></title>
      <url>http://hlei.io/2018/03/13/multithread-lock-summary/</url>
      <content type="html"><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。</p>
<p>使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。</p>
<p>在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。</p>
<p>在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。</p>
<p>可能引起的问题：</p>
<ol>
<li><p>过多占据CPU时间：如果锁的当前持有者长时间不释放该锁，那么等待者将长时间的占据cpu时间片，导致CPU资源的浪费，因此可以设定一个时间，当锁持有者超过这个时间不释放锁时，等待者会放弃CPU时间片阻塞；</p>
</li>
<li><p>死锁问题：试想一下，有一个线程连续两次试图获得自旋锁（比如在递归程序中），第一次这个线程获得了该锁，当第二次试图加锁的时候，检测到锁已被占用（其实是被自己占用），那么这时，线程会一直等待自己释放该锁，而不能继续执行，这样就引起了死锁。因此递归程序使用自旋锁应该遵循以下原则：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。</p>
</li>
</ol>
<h1 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h1><p>让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。。</p>
<p>JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()\notify()</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下<strong>ReentrantLock</strong>和<strong>synchronized</strong>都是可重入锁</p>
<p>3、可重入锁</p>
<p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class Test implements Runnable&#123;</div><div class="line"></div><div class="line">	public synchronized void get()&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public synchronized void set()&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Test ss=new Test();</div><div class="line">		new Thread(ss).start();</div><div class="line">		new Thread(ss).start();</div><div class="line">		new Thread(ss).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test implements Runnable &#123;</div><div class="line">	ReentrantLock lock = new ReentrantLock();</div><div class="line"></div><div class="line">	public void get() &#123;</div><div class="line">		lock.lock();</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void set() &#123;</div><div class="line">		lock.lock();</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Test ss = new Test();</div><div class="line">		new Thread(ss).start();</div><div class="line">		new Thread(ss).start();</div><div class="line">		new Thread(ss).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两个例子最后的结果都是正确的，即 同一个线程id被连续输出两次。</p>
<p>结果如下：</p>
<p>Threadid: 8</p>
<p>Threadid: 8</p>
<p>Threadid: 10</p>
<p>Threadid: 10</p>
<p>Threadid: 9</p>
<p>Threadid: 9</p>
<p>可重入锁最大的作用是避免死锁</p>
<p>我们以自旋锁作为例子，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SpinLock &#123;  </div><div class="line">    private AtomicReference&lt;Thread&gt; owner =new AtomicReference&lt;&gt;();  </div><div class="line">    public void lock()&#123;  </div><div class="line">        Thread current = Thread.currentThread();  </div><div class="line">        while(!owner.compareAndSet(null, current))&#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    public void unlock ()&#123;  </div><div class="line">        Thread current = Thread.currentThread();  </div><div class="line">        owner.compareAndSet(current, null);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于自旋锁来说，</p>
<ol>
<li>若有同一线程两调用lock() ，会导致第二次调用lock位置进行自旋，产生了死锁<br>说明这个锁并不是可重入的。（在lock函数内，应验证线程是否为已经获得锁的线程）</li>
<li>若1问题已经解决，当unlock（）第一次调用时，就已经将锁释放了。实际上不应释放锁。</li>
</ol>
<p>（采用计数次进行统计）<br>修改之后，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class SpinLock1 &#123;</div><div class="line">	private AtomicReference&lt;Thread&gt; owner =new AtomicReference&lt;&gt;();</div><div class="line">	private int count =0;</div><div class="line">	public void lock()&#123;</div><div class="line">		Thread current = Thread.currentThread();</div><div class="line">		if(current==owner.get()) &#123;</div><div class="line">			count++;</div><div class="line">			return ;</div><div class="line">		&#125;</div><div class="line">		while(!owner.compareAndSet(null, current))&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void unlock ()&#123;</div><div class="line">		Thread current = Thread.currentThread();</div><div class="line">		if(current==owner.get())&#123;</div><div class="line">			if(count!=0)&#123;</div><div class="line">				count--;</div><div class="line">			&#125;else&#123;</div><div class="line">				owner.compareAndSet(current, null);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该自旋锁即为可重入锁。</p>
<h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><p>悲观锁(Pessimistic Lock), 顾名思义就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。独占锁是悲观锁的一种实现</p>
<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。使用CAS来保证,保证这个操作的原子性</p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<h1 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读-写锁"></a>读-写锁</h1><p>Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。</p>
<p>Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock，详细的API可以查看JavaAPI文档。</p>
<p>ReentrantReadWriteLock 和 ReentrantLock 不是继承关系，但都是基于 AbstractQueuedSynchronizer 来实现。lock方法是基于CAS来实现的</p>
<p>ReadWriteLock中暴露了两个Lock对象：<br>在读写锁的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。读写锁是一种性能优化的策略。<br>RentrantReadWriteLock在构造时也可以选择是一个非公平的锁（默认）还是公平的锁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内存布局]]></title>
      <url>http://hlei.io/2018/03/12/os-memory-layout/</url>
      <content type="html"><![CDATA[<h1 id="进程的内存空间布局"><a href="#进程的内存空间布局" class="headerlink" title="进程的内存空间布局"></a>进程的内存空间布局</h1><p>进程的内存布局在结构上是有规律的，具体来说对于 linux 系统上的进程，其内存空间一般可以粗略地分为以下几大段【1】，从高内存到低内存排列：</p>
<ol>
<li><p>内核态内存空间，其大小一般比较固定（可以编译时调整），但 32 位系统和 64 位系统的值不一样。</p>
</li>
<li><p>用户态的堆栈，大小不固定，可以用 ulimit -s 进行调整，默认一般为 8M，从高地址向低地址增长。</p>
</li>
<li><p>mmap 区域，进程茫茫内存空间里的主要部分，既可以从高地址到低地址延伸(所谓 flexible layout)，也可以从低到高延伸(所谓 legacy layout)，看进程具体情况【2】【3】。</p>
</li>
<li><p>brk 区域，紧邻数据段(甚至贴着)，从低位向高位伸展，但它的大小主要取决于 mmap 如何增长，一般来说，即使是 32 位的进程以传统方式延伸，也有差不多 1 GB 的空间（准确地说是 TASK_SIZE/3 - 代码段数据段，参看 arch/x86/include/asm/processor.h 里的定义)【4】</p>
</li>
<li><p>数据段，主要是进程里初始化和未初始化的全局数据总和，当然还有编译器生成一些辅助数据结构等等)，大小取决于具体进程，其位置紧贴着代码段。</p>
</li>
<li><p>代码段，主要是进程的指令，包括用户代码和编译器生成的辅助代码，其大小取决于具体程序，但起始位置根据 32 位还是 64 位一般固定(-fPIC, -fPIE等除外【5】)。<br><img src="/2018/03/12/os-memory-layout/os_memory_layout.png" alt="img01"></p>
</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>【1】<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Growing_the_Oracle_SGA_to_2.7_GB_in_x86_Red_Hat_Enterprise_Linux_2.1_Without_VLM-Linux_Memory_Layout.html" target="_blank" rel="external">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Growing_the_Oracle_SGA_to_2.7_GB_in_x86_Red_Hat_Enterprise_Linux_2.1_Without_VLM-Linux_Memory_Layout.html</a></li>
<li>【2】understanding the linux kernel, page 819, flexible memory region layout: <a href="https://books.google.com.hk/books?id=h0lltXyJ8aIC&amp;pg=PT925&amp;lpg=PT925&amp;dq=linux+flexible+memory&amp;source=bl&amp;ots=gO7rIYb8HR&amp;sig=pirB5pswdHFHSljy57EksxS3ABw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjpkfa-2_rRAhVGFJQKHcETDSUQ6AEITDAH#v=onepage&amp;q=linux%20flexible%20memory&amp;f=false" target="_blank" rel="external">https://books.google.com.hk/books?id=h0lltXyJ8aIC&amp;pg=PT925&amp;lpg=PT925&amp;dq=linux+flexible+memory&amp;source=bl&amp;ots=gO7rIYb8HR&amp;sig=pirB5pswdHFHSljy57EksxS3ABw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjpkfa-2_rRAhVGFJQKHcETDSUQ6AEITDAH#v=onepage&amp;q=linux%20flexible%20memory&amp;f=false</a></li>
<li>【3】<a href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4" target="_blank" rel="external">https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4</a></li>
<li>【4】<a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h#L770" target="_blank" rel="external">http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h#L770</a></li>
<li>【5】<a href="https://access.redhat.com/blogs/766093/posts/1975793" target="_blank" rel="external">https://access.redhat.com/blogs/766093/posts/1975793</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序的编译与链接]]></title>
      <url>http://hlei.io/2018/03/12/c-compile/</url>
      <content type="html"><![CDATA[<h1 id="编译过程预览"><a href="#编译过程预览" class="headerlink" title="编译过程预览"></a>编译过程预览</h1><p><img src="/2018/03/12/c-compile/c_compile01.png" alt="img01"></p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><ul>
<li>预处理(Prepressing) :   -E 表示只进行预处理, 即 : gcc –E hello.c –o hello.i<ul>
<li>展开所有 #define 定义的宏</li>
<li>处理所有条件预编译指令,如 #if, #ifdef</li>
<li>递归的将 #include 的文件插入到该预编译文件中</li>
<li>删除各类注释</li>
<li>添加行和文件标识,如  #2 “hello.c” 2 ,用于调试或编译出错报警</li>
<li>保留所有的 #pragma 编译指令,编译器要使用</li>
</ul>
</li>
<li>对于C++ 来说,预处理后的文件扩展名是 .ii</li>
</ul>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ul>
<li>编译(Compilation):  gcc –S hello.i –o hello.s<br>编译过程就是把预处理完的文件进行一系列词法分析,语法分析,语义分析及优化后生成相应的汇编代码文件.</li>
<li>现在的gcc 把预处理和编译两个步骤合成一个步骤,C语言使用一个叫做 cc1 的程序来完成,C++则是 cc1plus ,位于 /usr/libexec/gcc/x86_64-redhat-linux/4.1.2/</li>
<li>gcc 实际上是这些后台程序的包装,它会根据参数要求去调用 cc1(cclplus), 汇编器 as 和链接器 ld</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li>链接(Linking):解决一个程序被分割成多个模块后,模块间最后如何组合成一个单一程序的问题.</li>
<li>链接的主要任务是把各个模块之间相互引用的部分处理好,使各个模块之间能正确的衔接.</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux-command]]></title>
      <url>http://hlei.io/2018/03/12/linux-command/</url>
      <content type="html"><![CDATA[<h1 id="查看某个进程的线程数量"><a href="#查看某个进程的线程数量" class="headerlink" title="查看某个进程的线程数量"></a>查看某个进程的线程数量</h1><ol>
<li>根据进程号进行查询：<ul>
<li><h1 id="pstree-p-进程号"><a href="#pstree-p-进程号" class="headerlink" title="pstree -p 进程号"></a>pstree -p 进程号</h1></li>
</ul>
</li>
</ol>
<p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~/myspace/test/network$ pstree -p 5629</div><div class="line">test05(5629)─┬─&#123;test05&#125;(5630)</div><div class="line">             ├─&#123;test05&#125;(5631)</div><div class="line">             ├─&#123;test05&#125;(5632)</div><div class="line">             └─&#123;test05&#125;(5633)</div></pre></td></tr></table></figure></p>
<ul>
<li><h1 id="top-Hp-进程号"><a href="#top-Hp-进程号" class="headerlink" title="top -Hp 进程号"></a>top -Hp 进程号</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND </div><div class="line">  5629 chris     20   0 47680 1420 1188 S    0  0.1   0:00.02 test05                                          </div><div class="line"> 5630 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05                                          </div><div class="line"> 5631 chris     20   0 47680 1420 1188 S    0  0.1   0:00.03 test05                                          </div><div class="line"> 5632 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05                                          </div><div class="line"> 5633 chris     20   0 47680 1420 1188 S    0  0.1   0:00.00 test05</div><div class="line"> ``` </div><div class="line"></div><div class="line">2. 根据进程名字进行查询：</div></pre></td></tr></table></figure>
<h1 id="pstree-p-ps-e-grep-test05-awk-39-print-1-39"><a href="#pstree-p-ps-e-grep-test05-awk-39-print-1-39" class="headerlink" title="pstree -p ps -e | grep test05 | awk &#39;{print $1}&#39;"></a>pstree -p <code>ps -e | grep test05 | awk &#39;{print $1}&#39;</code></h1><h1 id="pstree-p-ps-e-grep-test05-awk-39-print-1-39-wc-l"><a href="#pstree-p-ps-e-grep-test05-awk-39-print-1-39-wc-l" class="headerlink" title="pstree -p ps -e | grep test05 | awk &#39;{print $1}&#39; | wc -l"></a>pstree -p <code>ps -e | grep test05 | awk &#39;{print $1}&#39;</code> | wc -l</h1><p>```<br>执行效果和上面的命令是一样的</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一致性哈希算法]]></title>
      <url>http://hlei.io/2018/03/07/distributed-system-consistent-hashing/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一些场景希望同样的请求尽量落到一台机器上，比如访问缓存集群时，我们往往希望同一种请求能落到同一个后端上，以充分利用其上已有的缓存，不同的机器承载不同的稳定working set。而不是随机地散落到所有机器上，那样的话会迫使所有机器缓存所有的内容，最终由于存不下形成颠簸而表现糟糕。 我们都知道hash能满足这个要求，比如当有n台服务器时，输入x总是会发送到第hash(x) % n台服务器上。但当服务器变为m台时，hash(x) % n和hash(x) % m很可能都不相等，这会使得几乎所有请求的发送目的地都发生变化，如果目的地是缓存服务，所有缓存将失效，继而对原本被缓存遮挡的数据库或计算服务造成请求风暴，触发雪崩。一致性哈希是一种特殊的哈希算法，在增加服务器时，发向每个老节点的请求中只会有一部分转向新节点，从而实现平滑的迁移。这篇论文中提出了一致性hash的概念。</p>
<p>一致性hash满足以下四个性质：</p>
<ul>
<li>平衡性 (Balance) : 每个节点被选到的概率是O(1/n)。</li>
<li>单调性 (Monotonicity) : 当新节点加入时， 不会有请求在老节点间移动， 只会从老节点移动到新节点。当有节点被删除时，也不会影响落在别的节点上的请求。</li>
<li>分散性 (Spread) : 当上游的机器看到不同的下游列表时(在上线时及不稳定的网络中比较常见), 同一个请求尽量映射到少量的节点中。</li>
<li>负载 (Load) : 当上游的机器看到不同的下游列表的时候， 保证每台下游分到的请求数量尽量一致。</li>
</ul>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>所有server的32位hash值在32位整数值域上构成一个环(Hash Ring)，环上的每个区间和一个server唯一对应，如果一个key落在某个区间内， 它就被分流到对应的server上。<br><img src="/2018/03/07/distributed-consistent-hashing/chash.png" alt="img01"><br>当删除一个server的， 它对应的区间会归属于相邻的server，所有的请求都会跑过去。当增加一个server时，它会分割某个server的区间并承载落在这个区间上的所有请求。单纯使用Hash Ring很难满足我们上节提到的属性，主要两个问题：</p>
<ul>
<li>在机器数量较少的时候， 区间大小会不平衡。</li>
<li>当一台机器故障的时候， 它的压力会完全转移到另外一台机器， 可能无法承载。<br>为了解决这个问题，我们为每个server计算m个hash值，从而把32位整数值域划分为n*m个区间，当key落到某个区间时，分流到对应的server上。那些额外的hash值使得区间划分更加均匀，被称为Virtual Node。当删除一个server时，它对应的m个区间会分别合入相邻的区间中，那个server上的请求会较为平均地转移到其他server上。当增加server时，它会分割m个现有区间，从对应server上分别转移一些请求过来。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Raft一致性算法]]></title>
      <url>http://hlei.io/2018/03/07/distributed-system-raft/</url>
      <content type="html"><![CDATA[<h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>在分布式系统中,一致性问题(consensus problem)是指对于一组服务器，给定一组操作，我们需要一个协议使得最后它们的结果达成一致。</p>
<p>在理论计算机科学中，计算机科学家Eric Brewer之后命名为布鲁尔定理的CAP定理指出，分布式数据存储不可能同时提供以下三种保证中的两种以上：</p>
<table>
<thead>
<tr>
<th>一致性</th>
<th>可用性</th>
<th>分区容忍</th>
</tr>
</thead>
<tbody>
<tr>
<td>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</td>
<td>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</td>
<td>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</td>
</tr>
</tbody>
</table>
<p>换句话说，<strong>CAP</strong>定理指出，在存在网络分区的情况下，必须在一致性和可用性之间进行选择。请注意，CAP定理中定义的一致性与ACID 数据库事务中保证的一致性完全不同。</p>
<p>由于CAP理论告诉我们对于分布式系统，如果不想牺牲一致性，我们就只能放弃可用性，所以，数据一致性模型主要有以下几种：强一致性、弱一致性和最终一致性等，在本篇章中，我们主要讨论的算法Raft，是一种分布式系统中的强一致性的实现算法。</p>
<p>强一致性的一般实现的原理：当其中某个服务器收到客户端的一组指令时,它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令,这样的话所有的服务器会产生一致的结果,看起来就像是一台机器一样.</p>
<h2 id="Raft算法描述"><a href="#Raft算法描述" class="headerlink" title="Raft算法描述"></a>Raft算法描述</h2><p>在Raft被提出来之前，Paxos协议是第一个被证明的一致性算法，但是Paxos的论文非常难懂，导致基于Paxos的工程实践和教学都十分头疼，于是Raft在设计的过程中，就从可理解性出发，使用算法分解和减少状态等手段，目前已经应用非常广泛。</p>
<p>在Raft中，问题分解为：领导选取、日志复制、安全和成员变化。</p>
<h3 id="复制状态机（Replicated-State-Machine）"><a href="#复制状态机（Replicated-State-Machine）" class="headerlink" title="复制状态机（Replicated State Machine）"></a>复制状态机（Replicated State Machine）</h3><p><img src="/2018/03/07/distributed-system-raft/raft01.png" alt="img01"></p>
<ul>
<li><p>复制状态机通过复制日志来实现：</p>
<ul>
<li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li>
<li>状态机：状态机会按顺序执行这些命令</li>
<li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li>
</ul>
</li>
<li><p>一致性算法作用于一致性模型，一般有以下特性：</p>
<ul>
<li>safety：在非拜占庭问题下（网络延时，网络分区，丢包，重复发包以及包乱序等），结果是正确的</li>
<li>availability：在半数以上机器能正常工作时，则系统可用</li>
<li>timing-unindependent：不依赖于时钟来保证日志一致性，错误的时钟以及极端的消息时延最多会造成可用性问题</li>
</ul>
</li>
</ul>
<h3 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h3><p>每台服务器一定会处于三种状态：</p>
<ul>
<li>领导者</li>
<li>候选人</li>
<li>追随者<br><img src="/2018/03/07/distributed-system-raft/raft02.png" alt="img02"><br>追随者只响应其他服务器的请求。如果追随者没有收到任何消息，它会成为一个候选人并且开始一次选举。收到大多数服务器投票的候选人会成为新的领导人。领导人在它们宕机之前会一直保持领导人的状态。</li>
</ul>
<h3 id="任期-Term"><a href="#任期-Term" class="headerlink" title="任期(Term)"></a>任期(Term)</h3><p>Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。<br><img src="/2018/03/07/distributed-system-raft/raft03.png" alt="img03"></p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起，然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制。为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。<br>RPC有三种：</p>
<ol>
<li>RequestVote RPC：候选人在选举期间发起</li>
<li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li>
<li>InstallSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。</li>
</ol>
<p>超时设置：</p>
<ol>
<li>BroadcastTime: 领导者的心跳超时时间</li>
<li>Election Timeout: 追随者设置的候选超时时间</li>
<li>MTBT: 指的是单个服务器发生故障的间隔时间的平均数<br>BroadcastTime &lt;&lt; ElectionTimeout &lt;&lt; MTBF</li>
</ol>
<p>两个原则：</p>
<ol>
<li>BroadcastTime应该比ElectionTimeout小一个数量级，为的是使领导人能够持续发送心跳信息（heartbeat）来阻止追随者们开始选举；</li>
<li>ElectionTimeout也要比MTBF小几个数量级，为的是使得系统稳定运行。<br>一般BroadcastTime大约为0.5毫秒到20毫秒，ElectionTimeout一般在10ms到500ms之间。大多数服务器的MTBF都在几个月甚至更长。</li>
</ol>
<h3 id="领导人选取"><a href="#领导人选取" class="headerlink" title="领导人选取"></a>领导人选取</h3><ul>
<li>触发条件：</li>
</ul>
<ol>
<li>一般情况下，追随者接到领导者的心跳时，把ElectionTimeout清零，不会触发；</li>
<li>领导者故障，追随者的ElectionTimeout超时发生时，会变成候选者，触发领导人选取；</li>
</ol>
<ul>
<li>候选操作过程：</li>
</ul>
<p>追随者自增当前任期，转换为Candidate，对自己投票，并发起RequestVote RPC，等待下面三种情形发生；</p>
<ol>
<li>获得超过半数服务器的投票，赢得选举，成为领导者；</li>
<li>另一台服务器赢得选举，并接收到对应的心跳，成为追随者；</li>
<li>选举超时，没有任何一台服务器赢得选举，自增当前任期，重新发起选举；</li>
</ol>
<p>注意事项：</p>
<ol>
<li>服务器在一个任期内，最多能给一个候选人投票，采用先到先服务原则；</li>
<li>候选者等待投票时，可能会接收到来自其它声明为领导人的的AppendEntries RPC。如果该领导人的任期（RPC中有）比当前候选人的当前任期要大，则候选人认为该领导人合法，并转换成追随者；如果RPC中的任期小于候选人的当前任期，则候选人拒绝此次RPC，继续保持候选人状态；</li>
<li>候选人既没有赢得选举也没有输掉选举：如果许多追随者在同一时刻都成为了候选人，选票会被分散，可能没有候选人能获得大多数的选票。当这种情形发生时，每一个候选人都会超时，并且通过自增任期号和发起另一轮 RequestVote RPC 来开始新的选举。然而，如果没有其它手段来分配选票的话，这种情形可能会无限的重复下去。所以Raft使用的随机的选举超时时间（150~300ms之间），来避免这种情况发生。</li>
</ol>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p><img src="/2018/03/07/distributed-system-raft/raft04.png" alt="img04"><br>接受命令的过程：</p>
<ol>
<li>领导者接受客户端请求；</li>
<li>领导者把指令追加到日志；</li>
<li>发送AppendEntries RPC到追随者；</li>
<li>领导者收到大多数追随者的确认后，领导者Commit该日志，把日志在状态机中回放，并返回结果给客户端；</li>
</ol>
<p>提交过程：</p>
<ol>
<li>在下一个心跳阶段，领导者再次发送AppendEntries RPC给追随者，日志已经commited；</li>
<li>追随者收到Commited日志后，将日志在状态机中回放。</li>
</ol>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令，例如：一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p>
<ol>
<li><p>领导者追加日志（Append-Only)<br>领导者永远不会覆盖已经存在的日志条目；<br>日志永远只有一个流向：从领导者到追随者；</p>
</li>
<li><p>选举限制：投票阻止没有全部日志条目的服务器赢得选举<br>如果投票者的日志比候选人的新，拒绝投票请求；<br>这意味着要赢得选举，候选者的日志至少和大多数服务器的日志一样新，那么它一定包含全部的已经提交的日志条目。</p>
</li>
<li><p>永远不提交任期之前的日志条目（只提交任期内的日志条目）<br>在Raft算法中，当一个日志被安全的复制到绝大多数的机器上面，即AppendEntries RPC在绝大多数服务器正确返回了，那么这个日志就是被提交了，然后领导者会更新commit index。<br><img src="/2018/03/07/distributed-system-raft/raft05.png" alt="img05"></p>
</li>
</ol>
<p>如果允许提交任期之前的日志条目，那么在步骤c中，我们就会把之前任期为2的日志提交到其他服务器中去，并造成了大多数机器存在了日志为2的情况。所以造成了d中S5中任期为3的日志条目会覆盖掉已经提交的日志的情况。</p>
<p>Raft 从来不会通过计算复制的数目来提交之前人气的日志条目。只有领导人当前任期的日志条目才能通过计算数目来进行提交。一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配原则（Log Matching Property），之前的日志条目也都会被间接的提交。</p>
<p>论文中的这段话比较难理解，更加直观的说：由于Raft不会提交任期之前的日志条目，那么就不会从b过渡到c的情况，只能从b发生S5down机的情况下直接过渡到e，这样就产生的更新的任期，这样S5就没有机会被选为领导者了。</p>
<ol>
<li>候选者和追随者崩溃<br>候选者和追随者崩溃的情况处理要简单的多。如果这类角色崩溃了，那么后续发送给他们的 RequestVote和AppendEntries的所有RCP都会失败，Raft算法中处理这类失败就是简单的无限重试的方式。<br>　　如果这些服务器重新可用，那么这些RPC就会成功返回。如果一个服务器完成了一个RPC，但是在响应Leader前崩溃了，那么当他再次可用的时候还会收到相同的RPC请求，此时接收服务器负责检查，比如如果收到了已经包含该条日志的RPC请求，可以直接忽略这个请求，确保对系统是无害的。</li>
</ol>
<h3 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h3><p>集群成员的变更和成员的宕机与重启不同，因为前者会修改成员个数进而影响到领导者的选取和决议过程，因为在分布式系统这对于majority这个集群中成员大多数的概念是极为重要的。</p>
<p>简单的做法是，运维人员将系统临时下线，修改配置，重新上线。但是这种做法存在两个缺点：</p>
<ol>
<li>更改时集群不可用</li>
<li>人为操作失误风险<br>直接从一种配置转到新的配置是十分不安全的<br>如下图所示：<br><img src="/2018/03/07/distributed-system-raft/raft06.png" alt="img06"></li>
</ol>
<p>因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</p>
<p>两阶段方法保证安全性：<br>为了保证安全性，配置更改必须使用两阶段方法。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合。</p>
<p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程人依然响应服务器请求。</p>
<p>一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定。领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。当C-old,new日志条目被提交以后，领导人在使用相同的策略提交C-new，如下图所示，C-old 和 C-new 没有任何机会同时做出单方面的决定，这就保证了安全性。<br><img src="/2018/03/07/distributed-system-raft/raft07.png" alt="img07"></p>
<p>一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的条目，实线表示最后被提交的日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old,new 的大多数和 C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在 C-new 和 C-old 可以同时做出决定的时间点。</p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>日志会随着系统的不断运行会无限制的增长，这会给存储带来压力，几乎所有的分布式系统(Chubby、ZooKeeper)都采用快照的方式进行日志压缩，做完快照之后快照会在稳定持久存储中保存，而快照之前的日志和快照就可以丢弃掉。</p>
<p>Raft的具体做法如下图所示：<br><img src="/2018/03/07/distributed-system-raft/raft08.png" alt="img08"><br>与Raft其它操作Leader-Based不同，snapshot是由各个节点独立生成的。除了日志压缩这一个作用之外，snapshot还可以用于同步状态：slow-follower以及new-server，Raft使用InstallSnapshot RPC完成该过程，不再赘述。</p>
<p>Client交互<br>Client只向领导者发送请求；<br>Client开始会向追随者发送请求，追随者拒绝Client的请求，并重定向到领导者；<br>Client请求失败，会超时重新发送请求；<br>Raft算法要求Client的请求线性化，防止请求被多次执行。有两个解决方案：</p>
<p>Raft算法提出要求每个请求有个唯一标识；<br>Raft的请求保持幂等性；</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内存管理比较:ptmalloc & tcmalloc & jemalloc]]></title>
      <url>http://hlei.io/2018/02/28/os-memory-management/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>系统的物理内存是有限的，而对内存的需求是变化的, 程序的动态性越强，内存管理就越重要，选择合适的内存管理算法会带来明显的性能提升。<br>比如nginx， 它在每个连接accept后会malloc一块内存，作为整个连接生命周期内的内存池。 当HTTP请求到达的时候，又会malloc一块当前请求阶段的内存池, 因此对malloc的分配速度有一定的依赖关系。(而apache的内存池是有父子关系的，请求阶段的内存池会和连接阶段的使用相同的分配器，如果连接内存池释放则请求阶段的子内存池也会自动释放)。</p>
<p>内存管理可以分为三个层次，自底向上分别是：</p>
<ol>
<li>操作系统内核的内存管理</li>
<li>glibc层使用系统调用维护的内存管理算法</li>
<li>应用程序从glibc动态分配内存后，根据应用程序本身的程序特性进行优化， 比如使用引用计数std::shared_ptr，apache的内存池方式等等。<br>当然应用程序也可以直接使用系统调用从内核分配内存，自己根据程序特性来维护内存，但是会大大增加开发成本。</li>
</ol>
<p>一个优秀的通用内存分配器应具有以下特性:</p>
<ul>
<li>额外的空间损耗尽量少</li>
<li>分配速度尽可能快</li>
<li>尽量避免内存碎片</li>
<li>缓存本地化友好</li>
<li>通用性，兼容性，可移植性，易调试</li>
</ul>
<p>目前大部分服务端程序使用glibc提供的malloc/free系列函数，而glibc使用的ptmalloc2在性能上远远弱后于google的tcmalloc和facebook的jemalloc。 而且后两者只需要使用LD_PRELOAD环境变量启动程序即可，甚至并不需要重新编译。</p>
<h2 id="glibc-ptmalloc2"><a href="#glibc-ptmalloc2" class="headerlink" title="glibc ptmalloc2"></a>glibc ptmalloc2</h2><h3 id="ptmalloc原理"><a href="#ptmalloc原理" class="headerlink" title="ptmalloc原理"></a>ptmalloc原理</h3><h4 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h4><p><img src="/2018/02/28/os-memory-management/os_mem_manage01.png" alt="os-mem01"></p>
<p>上图是 x86_64 下 Linux 进程的默认地址空间, 对 heap 的操作, 操作系统提供了brk()系统调用，设置了Heap的上边界； 对 mmap 映射区域的操作,操作系 统 供了 mmap()和 munmap()函数。<br>因为系统调用的代价很高，不可能每次申请内存都从内核分配空间，尤其是对于小内存分配。 而且因为mmap的区域容易被munmap释放，所以一般大内存采用mmap()，小内存使用brk()。</p>
<h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h4><ul>
<li>Ptmalloc2有一个主分配区(main arena)， 有多个非主分配区。 非主分配区只能使用mmap向操作系统批发申请HEAP_MAX_SIZE（64位系统为64MB）大小的虚拟内存。 当某个线程调用malloc的时候，会先查看线程私有变量中是否已经存在一个分配区，如果存在则尝试加锁，如果加锁失败则遍历arena链表试图获取一个没加锁的arena， 如果依然获取不到则创建一个新的非主分配区。</li>
<li>free()的时候也要获取锁。分配小块内存容易产生碎片，ptmalloc在整理合并的时候也要对arena做加锁操作。在线程多的时候，锁的开销就会增大。</li>
</ul>
<h4 id="ptmalloc内存管理"><a href="#ptmalloc内存管理" class="headerlink" title="ptmalloc内存管理"></a>ptmalloc内存管理</h4><p>用户请求分配的内存在ptmalloc中使用chunk表示， 每个chunk至少需要8个字节额外的开销。 用户free掉的内存不会马上归还操作系统，ptmalloc会统一管理heap和mmap区域的空闲chunk，避免了频繁的系统调用。<br>ptmalloc 将相似大小的 chunk 用双向链表链接起来, 这样的一个链表被称为一个 bin。Ptmalloc 一共 维护了 128 个 bin,并使用一个数组来存储这些 bin(如下图所示)。<br><img src="/2018/02/28/os-memory-management/os_mem_manage02.png" alt="os-mem02"><br>数组中的第一个为 unsorted bin, 数组中从 2 开始编号的前 64 个 bin 称为 small bins, 同一个small bin中的chunk具有相同的大小。small bins后面的bin被称作large bins。</p>
<ul>
<li>当free一个chunk并放入bin的时候， ptmalloc 还会检查它前后的 chunk 是否也是空闲的, 如果是的话,ptmalloc会首先把它们合并为一个大的 chunk, 然后将合并后的 chunk 放到 unstored bin 中。 另外ptmalloc 为了提高分配的速度,会把一些小的(不大于64B) chunk先放到一个叫做 fast bins 的容器内。</li>
<li>在fast bins和bins都不能满足需求后，ptmalloc会设法在一个叫做top chunk的空间分配内存。 对于非主分配区会预先通过mmap分配一大块内存作为top chunk， 当bins和fast bins都不能满足分配需要的时候, ptmalloc会设法在top chunk中分出一块内存给用户, 如果top chunk本身不够大, 分配程序会重新mmap分配一块内存chunk, 并将 top chunk 迁移到新的chunk上，并用单链表链接起来。如果free()的chunk恰好 与 top chunk 相邻,那么这两个 chunk 就会合并成新的 top chunk，如果top chunk大小大于某个阈值才还给操作系统。主分配区类似，不过通过sbrk()分配和调整top chunk的大小，只有heap顶部连续内存空闲超过阈值的时候才能回收内存。</li>
<li>需要分配的 chunk 足够大,而且 fast bins 和 bins 都不能满足要求,甚至 top chunk 本身也不能满足分配需求时,ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。</li>
</ul>
<h4 id="ptmalloc分配流程"><a href="#ptmalloc分配流程" class="headerlink" title="ptmalloc分配流程"></a>ptmalloc分配流程</h4><p><img src="/2018/02/28/os-memory-management/os_mem_manage03.png" alt="os-mem03"></p>
<h4 id="ptmalloc的缺陷"><a href="#ptmalloc的缺陷" class="headerlink" title="ptmalloc的缺陷"></a>ptmalloc的缺陷</h4><ul>
<li>后分配的内存先释放,因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放。</li>
<li>多线程锁开销大， 需要避免多线程频繁分配释放。</li>
<li>内存从thread的areana中分配， 内存不能从一个arena移动到另一个arena， 就是说如果多线程使用内存不均衡，容易导致内存的浪费。 比如说线程1使用了300M内存，完成任务后glibc没有释放给操作系统，线程2开始创建了一个新的arena， 但是线程1的300M却不能用了。</li>
<li>每个chunk至少8字节的开销很大</li>
<li>不定期分配长生命周期的内存容易造成内存碎片，不利于回收。 64位系统最好分配32M以上内存，这是使用mmap的阈值。</li>
</ul>
<h2 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a>tcmalloc</h2><p>tcmalloc是Google开源的一个内存管理库， 作为glibc malloc的替代品。目前已经在chrome、safari等知名软件中运用。<br>根据官方测试报告，ptmalloc在一台2.8GHz的P4机器上（对于小对象）执行一次malloc及free大约需要300纳秒。而TCMalloc的版本同样的操作大约只需要50纳秒。</p>
<h3 id="小对象分配"><a href="#小对象分配" class="headerlink" title="小对象分配"></a>小对象分配</h3><p>tcmalloc为每个线程分配了一个线程本地ThreadCache，小内存从ThreadCache分配，此外还有个中央堆（CentralCache），ThreadCache不够用的时候，会从CentralCache中获取空间放到ThreadCache中。<br>小对象（&lt;=32K）从ThreadCache分配，大对象从CentralCache分配。大对象分配的空间都是4k页面对齐的，多个pages也能切割成多个小对象划分到ThreadCache中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage04.png" alt="os-mem04"><br>小对象有将近170个不同的大小分类(class)，每个class有个该大小内存块的FreeList单链表，分配的时候先找到best fit的class，然后无锁的获取该链表首元素返回。如果链表中无空间了，则到CentralCache中划分几个页面并切割成该class的大小，放入链表中。</p>
<h3 id="CentralCache分配管理"><a href="#CentralCache分配管理" class="headerlink" title="CentralCache分配管理"></a>CentralCache分配管理</h3><ul>
<li>大对象(&gt;32K)先4k对齐后，从CentralCache中分配。 CentralCache维护的PageHeap如下图所示， 数组中第256个元素是所有大于255个页面都挂到该链表中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage05.png" alt="os-mem05"></li>
<li>当best fit的页面链表中没有空闲空间时，则一直往更大的页面空间则，如果所有256个链表遍历后依然没有成功分配。 则使用sbrk, mmap, /dev/mem从系统中分配。</li>
<li>tcmalloc PageHeap管理的连续的页面被称为span.<br>如果span未分配， 则span是PageHeap中的一个链表元素<br>如果span已经分配，它可能是返回给应用程序的大对象， 或者已经被切割成多小对象，该小对象的size-class会被记录在span中</li>
<li>在32位系统中，使用一个中央数组(central array)映射了页面和span对应关系， 数组索引号是页面号，数组元素是页面所在的span。 在64位系统中，使用一个3-level radix tree记录了该映射关系。</li>
</ul>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><ul>
<li>当一个object free的时候，会根据地址对齐计算所在的页面号，然后通过central array找到对应的span。</li>
<li>如果是小对象，span会告诉我们他的size class，然后把该对象插入当前线程的ThreadCache中。如果此时ThreadCache超过一个预算的值（默认2MB），则会使用垃圾回收机制把未使用的object从ThreadCache移动到CentralCache的central free lists中。</li>
<li>如果是大对象，span会告诉我们对象锁在的页面号范围。 假设这个范围是[p,q]， 先查找页面p-1和q+1所在的span，如果这些临近的span也是free的，则合并到[p,q]所在的span， 然后把这个span回收到PageHeap中。</li>
<li>CentralCache的central free lists类似ThreadCache的FreeList，不过它增加了一级结构，先根据size-class关联到spans的集合， 然后是对应span的object链表。如果span的链表中所有object已经free， 则span回收到PageHeap中。</li>
</ul>
<h3 id="tcmalloc的改进"><a href="#tcmalloc的改进" class="headerlink" title="tcmalloc的改进"></a>tcmalloc的改进</h3><ul>
<li>ThreadCache会阶段性的回收内存到CentralCache里。 解决了ptmalloc2中arena之间不能迁移的问题。</li>
<li>Tcmalloc占用更少的额外空间。例如，分配N个8字节对象可能要使用大约8N * 1.01字节的空间。即，多用百分之一的空间。Ptmalloc2使用最少8字节描述一个chunk。</li>
<li>更快。小对象几乎无锁， &gt;32KB的对象从CentralCache中分配使用自旋锁。 并且&gt;32KB对象都是页面对齐分配，多线程的时候应尽量避免频繁分配，否则也会造成自旋锁的竞争和页面对齐造成的浪费。</li>
</ul>
<h2 id="Jemalloc"><a href="#Jemalloc" class="headerlink" title="Jemalloc"></a>Jemalloc</h2><p>jemalloc是facebook推出的， 最早的时候是freebsd的libc malloc实现。 目前在firefox、facebook服务器各种组件中大量使用。</p>
<h3 id="jemalloc原理"><a href="#jemalloc原理" class="headerlink" title="jemalloc原理"></a>jemalloc原理</h3><ul>
<li>与tcmalloc类似，每个线程同样在&lt;32KB的时候无锁使用线程本地cache。</li>
<li>Jemalloc在64bits系统上使用下面的size-class分类：<ul>
<li>Small: [8], [16, 32, 48, …, 128], [192, 256, 320, …, 512], [768, 1024, 1280, …, 3840]</li>
<li>Large: [4 KiB, 8 KiB, 12 KiB, …, 4072 KiB] </li>
<li>Huge: [4 MiB, 8 MiB, 12 MiB, …]</li>
</ul>
</li>
<li>small/large对象查找metadata需要常量时间， huge对象通过全局红黑树在对数时间内查找。</li>
<li>虚拟内存被逻辑上分割成chunks（默认是4MB，1024个4k页），应用线程通过round-robin算法在第一次malloc的时候分配arena， 每个arena都是相互独立的，维护自己的chunks， chunk切割pages到small/large对象。free()的内存总是返回到所属的arena中，而不管是哪个线程调用free()。<br><img src="/2018/02/28/os-memory-management/os_mem_manage06.png" alt="os-mem06"><br>上图可以看到每个arena管理的arena chunk结构， 开始的header主要是维护了一个page map（1024个页面关联的对象状态）， header下方就是它的页面空间。 Small对象被分到一起， metadata信息存放在起始位置。 large chunk相互独立，它的metadata信息存放在chunk header map中。<ul>
<li>通过arena分配的时候需要对arena bin（每个small size-class一个，细粒度）加锁，或arena本身加锁。<br>并且线程cache对象也会通过垃圾回收指数退让算法返回到arena中。<br><img src="/2018/02/28/os-memory-management/os_mem_manage07.png" alt="os-mem07"></li>
</ul>
</li>
</ul>
<h3 id="jemalloc的优化"><a href="#jemalloc的优化" class="headerlink" title="jemalloc的优化"></a>jemalloc的优化</h3><ul>
<li>Jmalloc小对象也根据size-class，但是它使用了低地址优先的策略，来降低内存碎片化。</li>
<li>Jemalloc大概需要2%的额外开销。（tcmalloc 1%， ptmalloc最少8B）</li>
<li>Jemalloc和tcmalloc类似的线程本地缓存，避免锁的竞争</li>
<li>相对未使用的页面，优先使用dirty page，提升缓存命中。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>jemalloc <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919" target="_blank" rel="external">https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919</a></li>
<li>tcmalloc <a href="https://yq.aliyun.com/articles/6045" target="_blank" rel="external">https://yq.aliyun.com/articles/6045</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySQL索引原理剖析]]></title>
      <url>http://hlei.io/2018/02/27/mysql-index-analysis/</url>
      <content type="html"><![CDATA[<p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p>
<p>文章主要内容分为三个部分。</p>
<ul>
<li>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</li>
<li>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</li>
<li>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。</li>
</ul>
<h2 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h2><h3 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是一种数据结构。</p>
<p>数据库查询是数据库的主要功能之一，最基本的查询算法是顺序查找（linear search）时间复杂度为O(n)，显然在数据量很大时效率很低。优化的查找算法如二分查找（binary search）、二叉树查找（binary tree search）等，虽然查找效率提高了。但是各自对检索的数据都有要求：二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织）。所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</p>
<p>看一个例子：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index01.png" alt="pic01"></p>
<p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
<h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h3><p>关于B树和B+树请参考关于B树的一些总结，这篇文章介绍的比较详细，同时容易理解。</p>
<p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<ol>
<li>d&gt;=2，即B-Tree的度；</li>
<li>h为B-Tree的高；</li>
<li>每个非叶子结点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d；</li>
<li>每个叶子结点至少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶结点的指针均为NULL；</li>
<li>所有叶结点都在同一层，深度等于树高h；</li>
<li>key和指针相互间隔，结点两端是指针；</li>
<li>一个结点中的key从左至右非递减排列；</li>
<li>如果某个指针在结点node最左边且不为null，则其指向结点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</li>
<li>如果某个指针在结点node最右边且不为null，则其指向结点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</li>
<li>如果某个指针在结点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向结点的所有key小于v(keyi+1)且大于v(keyi)。<br>图2是一个d=2的B-Tree示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index02.png" alt="pic02"></li>
</ol>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">BTree_Search(node, key) &#123;</div><div class="line">    if(node == null) return null;</div><div class="line">    foreach(node.key)</div><div class="line">    &#123;</div><div class="line">        if(node.key[i] == key) return node.data[i];</div><div class="line">            if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</div><div class="line">    &#125;</div><div class="line">    return BTree_Search(point[i+1]-&gt;node);</div><div class="line">&#125;</div><div class="line">data = BTree_Search(root, my_key);</div></pre></td></tr></table></figure></p>
<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找结点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<ul>
<li>每个结点的指针上限为2d而不是2d+1。</li>
<li>内结点不存储data，只存储key；叶子结点不存储指针。<br>图3是一个简单的B+Tree示意。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index03.png" alt="pic03"></li>
</ul>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶结点和内结点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个结点的域和上限是一致的，所以在实现中B-Tree往往对每个结点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<h4 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h4><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index04.png" alt="pic04"><br>如图4所示，在B+Tree的每个叶子结点增加一个指向相邻叶子结点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着结点和指针顺序遍历就可以一次性访问到所有数据结点，极大提到了区间查询效率。</p>
<p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p>
<h4 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h4><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h4 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h4><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index05.png" alt="pic05"><br>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h4 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h4><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>图6是磁盘的整体结构示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index06.png" alt="pic06"><br>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p>
<p>图7是磁盘结构的示意图。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index07.png" alt="pic07"><br>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>从使用磁盘I/O次数评价索引结构的优劣性：根据B-Tree的定义，可知检索一次最多需要访问h个结点。数据库系统的设计者巧妙的利用了磁盘预读原理，将一个结点的大小设为等于一个页面，这样每个结点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根结点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出读d是非常大的数字，通常超过100，因此h非常小。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树结构，h明显要深得多。由于逻辑上很近的结点（父子结点）物理上可能离得很远，无法利用局部性原理。所以即使红黑树的I/O渐进复杂度也为O(h)，但是查找效率明显比B-Tree差得多。</p>
<p>B+Tree更适合外存索引，是和内结点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于结点内key和data的大小：dmax=floor(pagesize/(keysize+datasize+pointsize))。</p>
<p>floor表示向下取整。由于B+Tree内结点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>
<h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎(MySQL数据库MyISAM和InnoDB存储引擎的比较)的索引实现方式。</p>
<h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶结点的data域存放的是数据记录的地址。下面是MyISAM索引的原理图：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index08.png" alt="pic08"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index09.png" alt="pic09"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做<em>“非聚集”</em>的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶结点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。<br><img src="/2018/02/27/mysql-index-analysis/mysql_index10.png" alt="pic10"><br>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶结点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：<br><img src="/2018/02/27/mysql-index-analysis/mysql_index11.png" alt="pic11"><br>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h2 id="聚簇索引-amp-非聚簇索引"><a href="#聚簇索引-amp-非聚簇索引" class="headerlink" title="聚簇索引 &amp; 非聚簇索引"></a>聚簇索引 &amp; 非聚簇索引</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。</li>
<li>非聚簇索引，叶级页指向表中的记录，记录的物理顺序与逻辑顺序没有必然的联系</li>
</ul>
<p>在mysql数据库中，myisam引擎和innodb引擎使用的索引类型不同，myisam对应的是非聚簇索引，而innodb对应的是聚簇索引。聚簇索引也叫复合索引、聚集索引等等。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在聚簇索引中，数据会被按照顺序整理排列，当使用where进行顺序、范围、大小检索时，会大大加速检索效率。非聚簇索引在存储时不会对数据进行排序，相对产生的数据文件体积也比较大。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis-analysis-sentinel01]]></title>
      <url>http://hlei.io/2018/02/26/redis-analysis-sentinel01/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（二十二）--- Redis 复制(replicate)源码详细解析]]></title>
      <url>http://hlei.io/2018/02/23/redis-analysis-replicatesource/</url>
      <content type="html"><![CDATA[<h2 id="1-复制的介绍"><a href="#1-复制的介绍" class="headerlink" title="1. 复制的介绍"></a>1. 复制的介绍</h2><p>Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="2-复制的实现"><a href="#2-复制的实现" class="headerlink" title="2. 复制的实现"></a>2. 复制的实现</h2><h3 id="2-1-主从关系的建立"><a href="#2-1-主从关系的建立" class="headerlink" title="2.1 主从关系的建立"></a>2.1 主从关系的建立</h3><p>复制的建立方法有三种。</p>
<ol>
<li>在redis.conf文件中配置slaveof <masterip> <masterport>选项，然后指定该配置文件启动Redis生效。</masterport></masterip></li>
<li>在redis-server启动命令后加上–slaveof <masterip> <masterport>启动生效。</masterport></masterip></li>
<li>直接使用 slaveof <masterip> <masterport>命令在从节点执行生效。<br>无论是通过哪一种方式来建立主从复制，都是从节点来执行slaveof命令，那么从节点执行了这个命令到底做了什么，我们上源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// SLAVEOF host port命令实现</div><div class="line">void slaveofCommand(client *c) &#123;</div><div class="line">    // 如果当前处于集群模式，不能进行复制操作</div><div class="line">    if (server.cluster_enabled) &#123;</div><div class="line">        addReplyError(c,&quot;SLAVEOF not allowed in cluster mode.&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // SLAVEOF NO ONE命令使得这个从节点关闭复制功能，并从从节点转变回主节点，原来同步所得的数据集不会被丢弃。</div><div class="line">    if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;no&quot;) &amp;&amp;</div><div class="line">        !strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;one&quot;)) &#123;</div><div class="line">        // 如果保存了主节点IP</div><div class="line">        if (server.masterhost) &#123;</div><div class="line">            // 取消复制操作，设置服务器为主服务器</div><div class="line">            replicationUnsetMaster();</div><div class="line">            // 获取client的每种信息，并以sds形式返回，并打印到日志中</div><div class="line">            sds client = catClientInfoString(sdsempty(),c);</div><div class="line">            serverLog(LL_NOTICE,&quot;MASTER MODE enabled (user request from &apos;%s&apos;)&quot;,</div><div class="line">                client);</div><div class="line">            sdsfree(client);</div><div class="line">        &#125;</div><div class="line">    // SLAVEOF host port</div><div class="line">    &#125; else &#123;</div><div class="line">        long port;</div><div class="line"></div><div class="line">        // 获取端口号</div><div class="line">        if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;port, NULL) != C_OK))</div><div class="line">            return;</div><div class="line"></div><div class="line">        // 如果已存在从属于masterhost主节点且命令参数指定的主节点和masterhost相等，端口也相等，直接返回</div><div class="line">        if (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[1]-&gt;ptr)</div><div class="line">            &amp;&amp; server.masterport == port) &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.&quot;);</div><div class="line">            addReplySds(c,sdsnew(&quot;+OK Already connected to specified master\r\n&quot;));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 第一次执行设置端口和ip，或者是重新设置端口和IP</div><div class="line">        // 设置服务器复制操作的主节点IP和端口</div><div class="line">        replicationSetMaster(c-&gt;argv[1]-&gt;ptr, port);</div><div class="line">        // 获取client的每种信息，并以sds形式返回，并打印到日志中</div><div class="line">        sds client = catClientInfoString(sdsempty(),c);</div><div class="line">        serverLog(LL_NOTICE,&quot;SLAVE OF %s:%d enabled (user request from &apos;%s&apos;)&quot;,</div><div class="line">            server.masterhost, server.masterport, client);</div><div class="line">        sdsfree(client);</div><div class="line">    &#125;</div><div class="line">    // 回复ok</div><div class="line">    addReply(c,shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</masterport></masterip></li>
</ol>
<p>当从节点的client执行SLAVEOF命令后，该命令会被构建成Redis协议格式，发送给从节点服务器，然后节点服务器会调用slaveofCommand()函数执行该命令。</p>
<p>而SLAVEOF命令做的操作并不多，主要以下三步：</p>
<ul>
<li>判断当前环境是否在集群模式下，因为集群模式下不行执行该命令。</li>
<li>是否执行的是SLAVEOF NO ONE命令，该命令会断开主从的关系，设置当前节点为主节点服务器。</li>
<li>设置从节点所属主节点的IP和port。调用了replicationSetMaster()函数。</li>
</ul>
<p>SLAVEOF命令能做的只有这么多，我们来具体看下replicationSetMaster()函数的代码，看看它做了哪些与复制相关的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 设置复制操作的主节点IP和端口</div><div class="line">void replicationSetMaster(char *ip, int port) &#123;</div><div class="line">    // 按需清除原来的主节点信息</div><div class="line">    sdsfree(server.masterhost);</div><div class="line">    // 设置ip和端口</div><div class="line">    server.masterhost = sdsnew(ip);</div><div class="line">    server.masterport = port;</div><div class="line">    // 如果有其他的主节点，在释放</div><div class="line">    // 例如服务器1是服务器2的主节点，现在服务器2要同步服务器3，服务器3要成为服务器2的主节点，因此要释放服务器1</div><div class="line">    if (server.master) freeClient(server.master);</div><div class="line">    // 解除所有客户端的阻塞状态</div><div class="line">    disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */</div><div class="line">    // 关闭所有从节点服务器的连接，强制从节点服务器进行重新同步操作</div><div class="line">    disconnectSlaves(); /* Force our slaves to resync with us as well. */</div><div class="line">    // 释放主节点结构的缓存，不会执行部分重同步PSYNC</div><div class="line">    replicationDiscardCachedMaster(); /* Don&apos;t try a PSYNC. */</div><div class="line">    // 释放复制积压缓冲区</div><div class="line">    freeReplicationBacklog(); /* Don&apos;t allow our chained slaves to PSYNC. */</div><div class="line">    // 取消执行复制操作</div><div class="line">    cancelReplicationHandshake();</div><div class="line">    // 设置复制必须重新连接主节点的状态</div><div class="line">    server.repl_state = REPL_STATE_CONNECT;</div><div class="line">    // 初始化复制的偏移量</div><div class="line">    server.master_repl_offset = 0;</div><div class="line">    // 清零连接断开的时长</div><div class="line">    server.repl_down_since = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由代码知，replicationSetMaster()函数执行操作的也很简单，总结为两步：</p>
<ul>
<li>清理之前所属的主节点的信息。</li>
<li>设置新的主节点IP和port等。<br>因为，当前从节点有可能之前从属于另外的一个主节点服务器，因此要清理所有关于之前主节点的缓存、关闭旧的连接等等。然后设置该从节点的新主节点，设置了IP和port，还设置了以下状态：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 设置复制必须重新连接主节点的状态</div><div class="line">server.repl_state = REPL_STATE_CONNECT;</div><div class="line">// 初始化全局复制的偏移量</div><div class="line">server.master_repl_offset = 0;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后，就没有然后了，然后就会执行复制操作吗？这也没有什么关于复制的操作执行了，那么复制操作是怎么开始的呢？</p>
<h3 id="2-2-主从网络连接建立"><a href="#2-2-主从网络连接建立" class="headerlink" title="2.2 主从网络连接建立"></a>2.2 主从网络连接建立</h3><p>slaveof命令是一个异步命令，执行命令时，从节点保存主节点的信息，确立主从关系后就会立即返回，后续的复制流程在节点内部异步执行。那么，如何触发复制的执行呢？</p>
<p>周期性执行的函数：replicationCron()函数，该函数被服务器的时间事件的回调函数serverCron()所调用，而serverCron()函数在Redis服务器初始化时，被设置为时间事件的处理函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// void initServer(void) Redis服务器初始化</div><div class="line">aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL)</div></pre></td></tr></table></figure></p>
<p>replicationCron()函数执行频率为1秒一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 节选自serverCron函数</div><div class="line">// 周期性执行复制的任务</div><div class="line">run_with_period(1000) replicationCron();</div></pre></td></tr></table></figure></p>
<p>主从关系建立后，从节点服务器的server.repl_state被设置为REPL_STATE_CONNECT，而replicationCron()函数会被每秒执行一次，该函数会发现我（从节点）现在有主节点了，而且我要的状态是要连接主节点（REPL_STATE_CONNECT）。</p>
<p>replicationCron()函数处理这以情况的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* Check if we should connect to a MASTER */</div><div class="line">// 如果处于要必须连接主节点的状态，尝试连接</div><div class="line">if (server.repl_state == REPL_STATE_CONNECT) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Connecting to MASTER %s:%d&quot;,</div><div class="line">        server.masterhost, server.masterport);</div><div class="line">    // 以非阻塞的方式连接主节点</div><div class="line">    if (connectWithMaster() == C_OK) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;MASTER &lt;-&gt; SLAVE sync started&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>replicationCron()函数根据从节点的状态，调用connectWithMaster()非阻塞连接主节点。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 以非阻塞的方式连接主节点</div><div class="line">int connectWithMaster(void) &#123;</div><div class="line">    int fd;</div><div class="line"></div><div class="line">    // 连接主节点</div><div class="line">    fd = anetTcpNonBlockBestEffortBindConnect(NULL,</div><div class="line">        server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);</div><div class="line">    if (fd == -1) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to connect to MASTER: %s&quot;,</div><div class="line">            strerror(errno));</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 监听主节点fd的可读和可写事件的发生，并设置其处理程序为syncWithMaster</div><div class="line">    if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) == AE_ERR)</div><div class="line">    &#123;</div><div class="line">        close(fd);</div><div class="line">        serverLog(LL_WARNING,&quot;Can&apos;t create readable event for SYNC&quot;);</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 最近一次读到RDB文件内容的时间</div><div class="line">    server.repl_transfer_lastio = server.unixtime;</div><div class="line">    // 从节点和主节点的同步套接字</div><div class="line">    server.repl_transfer_s = fd;</div><div class="line">    // 处于和主节点正在连接的状态</div><div class="line">    server.repl_state = REPL_STATE_CONNECTING;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>connectWithMaster()函数执行的操作可以总结为：</p>
<ul>
<li>根据IP和port非阻塞的方式连接主节点，得到主从节点进行通信的文件描述符fd，并保存到从节点服务器server.repl_transfer_s中，并且将刚才的REPL_STATE_CONNECT状态设置为REPL_STATE_CONNECTING。</li>
<li>监听fd的可读和可写事件，并且设置事件发生的处理程序syncWithMaster()函数。<br>至此，主从网络建立就完成了。</li>
</ul>
<h3 id="2-3-发送PING命令"><a href="#2-3-发送PING命令" class="headerlink" title="2.3 发送PING命令"></a>2.3 发送PING命令</h3><p>主从建立网络时，同时注册fd的AE_READABLE|AE_WRITABLE事件，因此会触发一个AE_WRITABLE事件，调用syncWithMaster()函数，处理写事件。</p>
<p>根据当前的REPL_STATE_CONNECTING状态，从节点向主节点发送PING命令，PING命令的目的有：</p>
<ul>
<li>检测主从节点之间的网络是否可用。</li>
<li>检查主从节点当前是否接受处理命令。<br>syncWithMaster()函数中相关操作的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Send a PING to check the master is able to reply without errors. */</div><div class="line">// 如果复制的状态为REPL_STATE_CONNECTING，发送一个PING去检查主节点是否能正确回复一个PONG</div><div class="line">if (server.repl_state == REPL_STATE_CONNECTING) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Non blocking connect for SYNC fired the event.&quot;);</div><div class="line">    // 暂时取消接听fd的写事件，以便等待PONG回复时，注册可读事件</div><div class="line">    aeDeleteFileEvent(server.el,fd,AE_WRITABLE);</div><div class="line">    // 设置复制状态为等待PONG回复</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</div><div class="line">    // 发送一个PING命令</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PING&quot;,NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>发送PING命令主要的操作是：</p>
<ul>
<li>先取消监听fd的写事件，因为接下来要读主节点服务器发送过来的PONG回复，因此只监听可读事件的发生。</li>
<li>设置从节点的复制状态为REPL_STATE_RECEIVE_PONG。等待一个主节点回复一个PONG命令。</li>
<li>以写的方式调用sendSynchronousCommand()函数发送一个PING命令给主节点。<br>主节点服务器从fd会读到一个PING命令，然后会回复一个PONG命令到fd中，执行的命令就是addReply(c,shared.pong);。</li>
</ul>
<p>此时，会触发fd的可读事件，调用syncWithMaster()函数来处理，此时从节点的复制状态为REPL_STATE_RECEIVE_PONG，等待主节点回复PONG。syncWithMaster()函数中处理这一状态的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/* Receive the PONG command. */</div><div class="line">// 如果复制的状态为REPL_STATE_RECEIVE_PONG，等待接受PONG命令</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</div><div class="line">   // 从主节点读一个PONG命令sendSynchronousCommand</div><div class="line">   err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line"></div><div class="line">    // 只接受两种有效的回复。一种是 &quot;+PONG&quot;，一种是认证错误&quot;-NOAUTH&quot;。</div><div class="line">    // 旧版本的返回有&quot;-ERR operation not permitted&quot;</div><div class="line">    if (err[0] != &apos;+&apos; &amp;&amp;</div><div class="line">        strncmp(err,&quot;-NOAUTH&quot;,7) != 0 &amp;&amp;</div><div class="line">        strncmp(err,&quot;-ERR operation not permitted&quot;,28) != 0)</div><div class="line">    &#123;   // 没有收到正确的PING命令的回复</div><div class="line">        serverLog(LL_WARNING,&quot;Error reply to PING from master: &apos;%s&apos;&quot;,err);</div><div class="line">        sdsfree(err);</div><div class="line">        goto error;</div><div class="line">     &#125; else &#123;</div><div class="line">       serverLog(LL_NOTICE,&quot;Master replied to PING, replication can continue...&quot;);</div><div class="line">     &#125;</div><div class="line">     sdsfree(err);</div><div class="line">     // 已经收到PONG，更改状态设置为发送认证命令AUTH给主节点</div><div class="line">     server.repl_state = REPL_STATE_SEND_AUTH;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，以读的方式调用sendSynchronousCommand()，并将读到的”+PONG\r\n”返回到err中，如果从节点正确接收到主节点发送的PONG命令，会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_AUTH。等待进行权限的认证。</p>
<h3 id="2-4-认证权限"><a href="#2-4-认证权限" class="headerlink" title="2.4 认证权限"></a>2.4 认证权限</h3><p>权限认证会在syncWithMaster()函数继续执行，紧接着刚才的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* AUTH with the master if required. */</div><div class="line">// 如果需要，发送AUTH认证给主节点</div><div class="line">if (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</div><div class="line">   // 如果服务器设置了认证密码</div><div class="line">   if (server.masterauth) &#123;</div><div class="line">        // 写AUTH给主节点</div><div class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;AUTH&quot;,server.masterauth,NULL);</div><div class="line">        if (err) goto write_error;</div><div class="line">        // 设置状态为等待接受认证回复</div><div class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</div><div class="line">        return;</div><div class="line">    // 如果没有设置认证密码，直接设置复制状态为发送端口号给主节点</div><div class="line">    &#125; else &#123;</div><div class="line">        server.repl_state = REPL_STATE_SEND_PORT;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果从节点的服务器设置了认证密码，则会以写方式调用sendSynchronousCommand()函数，将AUTH命令和密码写到fd中，并且将从节点的复制状态设置为server.repl_state = REPL_STATE_RECEIVE_AUTH，接受AUTH的验证。</p>
<p>如果从节点服务器没有设置认证密码，就直接将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_PORT，准发发送一个端口号。</p>
<p>主节点会读取到AUTH命令，调用authCommand()函数来处理，主节点服务器会比较从节点发送过来的server.masterauth和主节点服务器保存的server.requirepass是否一致，如果一致，会回复一个”+OK\r\n”。</p>
<p>当主节点将回复写到fd时，又会触发从节点的可读事件，紧接着调用syncWithMaster()函数来处理接收AUTH认证结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Receive AUTH reply. */</div><div class="line">// 接受AUTH认证的回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</div><div class="line">    // 从主节点读回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 回复错误，认证失败</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to AUTH to MASTER: %s&quot;,err);</div><div class="line">        sdsfree(err);</div><div class="line">        goto error;</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送端口号给主节点</div><div class="line">    server.repl_state = REPL_STATE_SEND_PORT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以读方式从fd中读取一个回复，判断认证是否成功，认证成功，则会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_PORT表示要发送一个端口号给主节点。这和没有设置认证的情况结果相同。</p>
<h3 id="2-5-发送端口号"><a href="#2-5-发送端口号" class="headerlink" title="2.5 发送端口号"></a>2.5 发送端口号</h3><p>从节点在认证完权限后，会继续在syncWithMaster()函数执行，处理发送端口号的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Set the slave port, so that Master&apos;s INFO command can list the</div><div class="line"> * slave listening port correctly. */</div><div class="line">// 如果复制状态是，发送从节点端口号给主节点，主节点的INFO命令就能够列出从节点正在监听的端口号</div><div class="line">if (server.repl_state == REPL_STATE_SEND_PORT) &#123;</div><div class="line">    // 获取端口号</div><div class="line">    sds port = sdsfromlonglong(server.slave_announce_port ?</div><div class="line">        server.slave_announce_port : server.port);</div><div class="line">    // 将端口号写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;listening-port&quot;,port, NULL);</div><div class="line">    sdsfree(port);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受端口号</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发送端口号，以REPLCONF listening-port命令的方式，写到fd中。然后将复制状态设置为server.repl_state = REPL_STATE_RECEIVE_PORT，等待接受主节点的回复。</p>
<p>主节点从fd中读到REPLCONF listening-port <port>命令，调用replconfCommand()命令来处理，而replconfCommand()函数的定义就在replication.c文件中，REPLCONF命令可以设置多种不同的选项，解析到端口号后，将端口号保存从节点对应client状态的c-&gt;slave_listening_port = port中。最终回复一个”+OK\r\n”状态的回复，写在fd中。</port></p>
<p>当主节点将回复写到fd时，又会触发从节点的可读事件，紧接着调用syncWithMaster()函数来处理接受端口号，验证主节点是否正确的接收到从节点的端口号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Receive REPLCONF listening-port reply. */</div><div class="line">// 复制状态为接受端口号</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</div><div class="line">    // 从主节点读取端口号</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    /* Ignore the error if any, not all the Redis versions support</div><div class="line">     * REPLCONF listening-port. */</div><div class="line">    // 忽略所有的错误，因为不是所有的Redis版本都支持REPLCONF listening-port命令</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF listening-port: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送IP</div><div class="line">    server.repl_state = REPL_STATE_SEND_IP;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确的接收到从节点的端口号，会将从节点的复制状态设置为server.repl_state = REPL_STATE_SEND_IP表示要送一个IP给主节点。</p>
<h3 id="2-6-发送-IP-地址"><a href="#2-6-发送-IP-地址" class="headerlink" title="2.6 发送 IP 地址"></a>2.6 发送 IP 地址</h3><p>从节点发送完端口号并且正确收到主节点的回复后，紧接着syncWithMaster()函数执行发送IP的代码。发送IP和发送端口号过程几乎一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送IP</div><div class="line">if (server.repl_state == REPL_STATE_SEND_IP) &#123;</div><div class="line">    // 将IP写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;ip-address&quot;,server.slave_announce_ip, NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受IP</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样是以REPLCONF ip-address命令的方式，将从节点的IP写到fd中。并且设置从节点的复制状态为server.repl_state = REPL_STATE_RECEIVE_IP，等待接受主节点的回复。然后就直接返回，等待fd可读发生。</p>
<p>主节点仍然会调用replication.c文件中实现的replconfCommand()函数来处理REPLCONF命令，解析出REPLCONF ip-address ip命令，保存从节点的ip到主节点的对应从节点的client的c-&gt;slave_ip中。然后回复”+OK\r\n”状态，写到fd中。</p>
<p>此时，从节点监听到fd触发了可读事件，会调用syncWithMaster()函数来处理，验证主节点是否正确接收到从节点的IP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Receive REPLCONF ip-address reply. */</div><div class="line">// 复制状态为接受IP回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</div><div class="line">    // 从主节点读一个IP回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 错误回复</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF ip-address: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送一个capa（能力？能否解析出RDB文件的EOF流格式）</div><div class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确接收了从节点IP，就会设置从节点的复制状态server.repl_state = REPL_STATE_SEND_CAPA表示发送从节点的能力（capability）。</p>
<h3 id="2-7-发送能力（capability）"><a href="#2-7-发送能力（capability）" class="headerlink" title="2.7 发送能力（capability）"></a>2.7 发送能力（capability）</h3><p>发送能力和发送端口和IP也是如出一辙，紧接着syncWithMaster()函数执行发送capa的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送capa，通知主节点从节点的能力</div><div class="line">if (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</div><div class="line">    // 将从节点的capa写给主节点</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,&quot;capa&quot;,&quot;eof&quot;,NULL);</div><div class="line">    if (err) goto write_error;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为接受从节点的capa</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从节点将REPLCONF capa eof命令发送给主节点，写到fd中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">目前只支持一种能力，就是能够解析出RDB文件的EOF流格式。用于无盘复制的方式中。</div></pre></td></tr></table></figure></p>
<p>主节点仍然会调用replication.c文件中实现的replconfCommand()函数来处理REPLCONF命令，解析出REPLCONF capa eof命令，将eof对应的标识，按位与到主节点的对应从节点的client的c-&gt;slave_capa中。然后回复”+OK\r\n”状态，写到fd中。</p>
<p>此时，从节点监听到fd触发了可读事件，会调用syncWithMaster()函数来处理，验证主节点是否正确接收到从节点的capa。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Receive CAPA reply. */</div><div class="line">// 复制状态为接受从节点的capa回复</div><div class="line">if (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</div><div class="line">    // 从主节点读取capa回复</div><div class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">    // 错误回复</div><div class="line">    if (err[0] == &apos;-&apos;) &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand REPLCONF capa: %s&quot;, err);</div><div class="line">    &#125;</div><div class="line">    sdsfree(err);</div><div class="line">    // 设置复制状态为发送PSYNC命令</div><div class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主节点正确接收了从节点capa，就会设置从节点的复制状态server.repl_state = REPL_STATE_SEND_PSYNC表示发送一个PSYNC命令</p>
<h3 id="2-8-发送PSYNC命令"><a href="#2-8-发送PSYNC命令" class="headerlink" title="2.8 发送PSYNC命令"></a>2.8 发送PSYNC命令</h3><p>从节点发送PSYNC命令给主节点，尝试进行同步主节点的数据集。同步分为两种：</p>
<ul>
<li>全量同步：第一次执行复制的场景。</li>
<li>部分同步：用于主从复制因为网络中断等原因造成数据丢失的场景。<br>因为这是第一次执行同步，因此会进行全量同步。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 复制状态为发送PSYNC命令。尝试进行部分重同步。</div><div class="line">// 如果没有缓冲主节点的结构，slaveTryPartialResynchronization()函数将会至少尝试使用PSYNC去进行一个全同步，这样就能得到主节点的运行runid和全局复制偏移量。并且在下次重连接时可以尝试进行部分重同步。</div><div class="line">if (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</div><div class="line">    // 向主节点发送一个部分重同步命令PSYNC，参数0表示不读主节点的回复，只获取主节点的运行runid和全局复制偏移量</div><div class="line">    if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) &#123;</div><div class="line">        // 发送PSYNC出错</div><div class="line">        err = sdsnew(&quot;Write error sending the PSYNC command.&quot;);</div><div class="line">        goto write_error;</div><div class="line">    &#125;</div><div class="line">    // 设置复制状态为等待接受一个PSYNC回复</div><div class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从节点调用slaveTryPartialResynchronization()函数尝试进行重同步，注意第二个参数是0。因为slaveTryPartialResynchronization()分成两部分，一部分是写，一部分是读，因为第二个参数是0，因此执行写的一部分，发送一个PSYNC命令给主节点。只列举出写的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* Writing half */</div><div class="line">// 如果read_reply为0，则该函数往socket上会写入一个PSYNC命令</div><div class="line">if (!read_reply) &#123;</div><div class="line">    // 将repl_master_initial_offset设置为-1表示主节点的run_id和全局复制偏移量是无效的。</div><div class="line">    // 如果能使用PSYNC命令执行一个全量同步，会正确设置全复制偏移量，以便这个信息被正确传播主节点的所有从节点中</div><div class="line">    server.repl_master_initial_offset = -1;</div><div class="line"></div><div class="line">    // 主节点的缓存不为空，可以尝试进行部分重同步。PSYNC &lt;master_run_id&gt; &lt;repl_offset&gt;</div><div class="line">    if (server.cached_master) &#123;</div><div class="line">        // 保存缓存runid</div><div class="line">        psync_runid = server.cached_master-&gt;replrunid;</div><div class="line">        // 获取已经复制的偏移量</div><div class="line">        snprintf(psync_offset,sizeof(psync_offset),&quot;%lld&quot;, server.cached_master-&gt;reploff+1);</div><div class="line">        serverLog(LL_NOTICE,&quot;Trying a partial resynchronization (request %s:%s).&quot;, psync_runid, psync_offset);</div><div class="line">    // 主节点的缓存为空，发送PSYNC ? -1。请求全量同步</div><div class="line">    &#125; else &#123;</div><div class="line">        serverLog(LL_NOTICE,&quot;Partial resynchronization not possible (no cached master)&quot;);</div><div class="line">        psync_runid = &quot;?&quot;;</div><div class="line">        memcpy(psync_offset,&quot;-1&quot;,3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Issue the PSYNC command */</div><div class="line">    // 发送一个PSYNC命令给主节点</div><div class="line">    reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PSYNC&quot;,psync_runid,psync_offset,NULL);</div><div class="line">    // 写成功失败会返回一个&quot;-&quot;开头的字符串</div><div class="line">    if (reply != NULL) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Unable to send PSYNC to master: %s&quot;,reply);</div><div class="line">        sdsfree(reply);</div><div class="line">        // 删除文件的可读事件，返回写错误PSYNC_WRITE_ERROR</div><div class="line">        aeDeleteFileEvent(server.el,fd,AE_READABLE);</div><div class="line">        return PSYNC_WRITE_ERROR;</div><div class="line">    &#125;</div><div class="line">    // 返回等待回复的标识PSYNC_WAIT_REPLY，调用者会将read_reply设置为1，然后再次调用该函数，执行下面的读部分。</div><div class="line">    return PSYNC_WAIT_REPLY;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于从节点是第一次和主节点进行同步操作，因此从节点缓存的主节点client状态erver.cached_master为空，所以就会发送一个PSYNC ? -1命令给主节点，表示进行一次全量同步。</p>
<p>主节点会接收到PSYNC ? -1命令，然后调用replication.c文件中实现的syncCommand()函数处理PSYNC命令。</p>
<p>syncCommand()函数先会判断执行的是PSYNC还是SYNC命令，如果是PSYNC命令会调用masterTryPartialResynchronization()命令执行部分同步，但是由于这是第一次执行复制操作，所以会执行失败。进而执行全量同步。</p>
<p>syncCommand()函数的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">/* SYNC and PSYNC command implemenation. */</div><div class="line">// SYNC and PSYNC 命令实现</div><div class="line">void syncCommand(client *c) &#123;</div><div class="line">    ..........//为了简洁，删除一些判断条件的代码</div><div class="line"></div><div class="line">    // 尝试执行一个部分同步PSYNC的命令，则masterTryPartialResynchronization()会回复一个 &quot;+FULLRESYNC &lt;runid&gt; &lt;offset&gt;&quot;,如果失败则执行全量同步</div><div class="line">    // 所以，从节点会如果和主节点连接断开，从节点会知道runid和offset，随后会尝试执行PSYNC</div><div class="line">    // 如果是执行PSYNC命令</div><div class="line">    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;psync&quot;)) &#123;</div><div class="line">        // 主节点尝试执行部分重同步，执行成功返回C_OK</div><div class="line">        if (masterTryPartialResynchronization(c) == C_OK) &#123;</div><div class="line">            // 可以执行PSYNC命令，则将接受PSYNC命令的个数加1</div><div class="line">            server.stat_sync_partial_ok++;</div><div class="line">            // 不需要执行后面的全量同步，直接返回</div><div class="line">            return; /* No full resync needed, return. */</div><div class="line">        // 不能执行PSYNC部分重同步，需要进行全量同步</div><div class="line">        &#125; else &#123;</div><div class="line">            char *master_runid = c-&gt;argv[1]-&gt;ptr;</div><div class="line">            // 从节点以强制全量同步为目的，所以不能执行部分重同步，因此增加PSYNC命令失败的次数</div><div class="line">            if (master_runid[0] != &apos;?&apos;) server.stat_sync_partial_err++;</div><div class="line">        &#125;</div><div class="line">    // 执行SYNC命令</div><div class="line">    &#125; else &#123;</div><div class="line">        // 设置标识，执行SYNC命令，不接受REPLCONF ACK</div><div class="line">        c-&gt;flags |= CLIENT_PRE_PSYNC;</div><div class="line">    &#125;</div><div class="line">    // 全量重同步次数加1</div><div class="line">    server.stat_sync_full++;</div><div class="line"></div><div class="line">    // 设置client状态为：从服务器节点等待BGSAVE节点的开始</div><div class="line">    c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</div><div class="line">    // 执行SYNC命令后是否关闭TCP_NODELAY</div><div class="line">    if (server.repl_disable_tcp_nodelay)</div><div class="line">        // 是的话，则启用nagle算法</div><div class="line">        anetDisableTcpNoDelay(NULL, c-&gt;fd); /* Non critical if it fails. */</div><div class="line">    // 保存主服务器传来的RDB文件的fd，设置为-1</div><div class="line">    c-&gt;repldbfd = -1;</div><div class="line">    // 设置client状态为从节点，标识client是一个从服务器</div><div class="line">    c-&gt;flags |= CLIENT_SLAVE;</div><div class="line">    // 添加到服务器从节点链表中</div><div class="line">    listAddNodeTail(server.slaves,c);</div><div class="line"></div><div class="line">    /* CASE 1: BGSAVE is in progress, with disk target. */</div><div class="line">    // 情况1. 正在执行 BGSAVE ，且是同步到磁盘上</div><div class="line">    if (server.rdb_child_pid != -1 &amp;&amp;</div><div class="line">        server.rdb_child_type == RDB_CHILD_TYPE_DISK)</div><div class="line">    &#123;</div><div class="line">        client *slave;</div><div class="line">        listNode *ln;</div><div class="line">        listIter li;</div><div class="line"></div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            slave = ln-&gt;value;</div><div class="line">            // 如果有从节点已经创建子进程执行写RDB操作，等待完成，那么退出循环</div><div class="line">            // 从节点的状态为 SLAVE_STATE_WAIT_BGSAVE_END 在情况三中被设置</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) break;</div><div class="line">        &#125;</div><div class="line">        // 对于这个从节点，我们检查它是否具有触发当前BGSAVE操作的能力</div><div class="line">        if (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</div><div class="line">            // 将slave的输出缓冲区所有内容拷贝给c的所有输出缓冲区中</div><div class="line">            copyClientOutputBuffer(c,slave);</div><div class="line">            // 设置全量重同步从节点的状态，设置部分重同步的偏移量</div><div class="line">            replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</div><div class="line">            serverLog(LL_NOTICE,&quot;Waiting for end of BGSAVE for SYNC&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Can&apos;t attach the slave to the current BGSAVE. Waiting for next BGSAVE for SYNC&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    /* CASE 2: BGSAVE is in progress, with socket target. */</div><div class="line">    // 情况2. 正在执行BGSAVE，且是无盘同步，直接写到socket中</div><div class="line">    &#125; else if (server.rdb_child_pid != -1 &amp;&amp;</div><div class="line">               server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</div><div class="line">    &#123;</div><div class="line">        // 虽然有子进程在执行写RDB，但是它直接写到socket中，所以等待下次执行BGSAVE</div><div class="line">        serverLog(LL_NOTICE,&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;);</div><div class="line"></div><div class="line">    /* CASE 3: There is no BGSAVE is progress. */</div><div class="line">    // 情况3：没有执行BGSAVE的进程</div><div class="line">    &#125; else &#123;</div><div class="line">        // 服务器支持无盘同步</div><div class="line">        if (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</div><div class="line">            // 无盘同步复制的子进程被创建在replicationCron()中，因为想等待更多的从节点可以到来而延迟</div><div class="line">            if (server.repl_diskless_sync_delay)</div><div class="line">                serverLog(LL_NOTICE,&quot;Delay next BGSAVE for diskless SYNC&quot;);</div><div class="line">        // 服务器不支持无盘复制</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果没有正在执行BGSAVE，且没有进行写AOF文件，则开始为复制执行BGSAVE，并且是将RDB文件写到磁盘上</div><div class="line">            if (server.aof_child_pid == -1) &#123;</div><div class="line">                startBgsaveForReplication(c-&gt;slave_capa);</div><div class="line">            &#125; else &#123;</div><div class="line">                serverLog(LL_NOTICE,</div><div class="line">                    &quot;No BGSAVE in progress, but an AOF rewrite is active. BGSAVE for replication delayed&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 只有一个从节点，且backlog为空，则创建一个新的backlog</div><div class="line">    if (listLength(server.slaves) == 1 &amp;&amp; server.repl_backlog == NULL)</div><div class="line">        createReplicationBacklog();</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先先明确，主节点执行处理从节点发来PSYNC命令的操作。所以主节点会将从节点视为自己的从节点客户端来操作。会将从节点的复制设置为SLAVE_STATE_WAIT_BGSAVE_START状态表示</p>
<p>主节点执行全量同步的情况有三种：</p>
<ul>
<li>主节点服务器正在执行BGSAVE命令，且将RDB文件写到磁盘上。<br>这种情况，如果有已经设置过全局重同步偏移量的从节点，可以共用输出缓冲区的数据。</li>
<li>主节点服务器正在执行BGSAVE命令，且将RDB文件写到网络socket上，无盘同步。<br>由于本次BGSAVE命令直接将RDB写到socket中，因此只能等待下一BGSAVE。</li>
<li>主节点服务器没有正在执行BGSAVE。<br>如果也没有进行AOF持久化的操作，那么开始为复制操作执行BGSAVE，生成一个写到磁盘上的RDB文件。<br>我们针对第三种情况来分析。调用了startBgsaveForReplication()来开始执行BGSAVE命令。我们贴出主要的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 开始为复制执行BGSAVE，根据配置选择磁盘或套接字作为RDB发送的目标，在开始之前确保冲洗脚本缓存</div><div class="line">// mincapa参数是SLAVE_CAPA_*按位与的结果</div><div class="line">int startBgsaveForReplication(int mincapa) &#123;</div><div class="line">    int retval;</div><div class="line">    // 是否直接写到socket</div><div class="line">    int socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);</div><div class="line">    listIter li;</div><div class="line">    listNode *ln;</div><div class="line"></div><div class="line">    if (socket_target)</div><div class="line">        // 直接写到socket中</div><div class="line">        // fork一个子进程将rdb写到 状态为等待BGSAVE开始 的从节点的socket中</div><div class="line">        retval = rdbSaveToSlavesSockets();</div><div class="line">    else</div><div class="line">        // 否则后台进行RDB持久化BGSAVE操作，保存到磁盘上</div><div class="line">        retval = rdbSaveBackground(server.rdb_filename);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    // 如果是直接写到socket中，rdbSaveToSlavesSockets()已经会设置从节点为全量复制</div><div class="line">    // 否则直接写到磁盘上，执行以下代码</div><div class="line">    if (!socket_target) &#123;</div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = ln-&gt;value;</div><div class="line">            // 设置等待全量同步的从节点的状态</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</div><div class="line">                    // 设置要执行全量重同步从节点的状态</div><div class="line">                    replicationSetupSlaveForFullResync(slave,</div><div class="line">                            getPsyncInitialOffset());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>replicationSetupSlaveForFullResync()函数源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int replicationSetupSlaveForFullResync(client *slave, long long offset) &#123;</div><div class="line">    char buf[128];</div><div class="line">    int buflen;</div><div class="line"></div><div class="line">    // 设置全量重同步的偏移量</div><div class="line">    slave-&gt;psync_initial_offset = offset;</div><div class="line">    // 设置从节点复制状态，开始累计差异数据</div><div class="line">    slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END;</div><div class="line">    // 将slaveseldb设置为-1，是为了强制发送一个select命令在复制流中</div><div class="line">    server.slaveseldb = -1;</div><div class="line"></div><div class="line">    // 如果从节点的状态是CLIENT_PRE_PSYNC，则表示是Redis是2.8之前的版本，则不将这些信息发送给从节点。</div><div class="line">    // 因为在2.8之前只支持SYNC的全量复制同步，而在之后的版本提供了部分的重同步</div><div class="line">    if (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;</div><div class="line">        buflen = snprintf(buf,sizeof(buf),&quot;+FULLRESYNC %s %lld\r\n&quot;,</div><div class="line">                          server.runid,offset);</div><div class="line">        // 否则会将全量复制的信息写给从节点</div><div class="line">        if (write(slave-&gt;fd,buf,buflen) != buflen) &#123;</div><div class="line">            freeClientAsync(slave);</div><div class="line">            return C_ERR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>哇，主节点终于回复从节点的PSYNC命令了，回复了一个+FULLRESYNC，写到主从同步的fd。表示要进行全量同步啊！！！</p>
<p>此时，从节点的复制状态一定为REPL_STATE_RECEIVE_PSYNC，fd的读事件发生，调用syncWithMaster()函数进行处理。</p>
<p>处理这种情况的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 那么尝试进行第二次部分重同步，从主节点读取指令来决定执行部分重同步还是全量同步</div><div class="line">psync_result = slaveTryPartialResynchronization(fd,1);</div></pre></td></tr></table></figure></p>
<p>这次的第二个参数是1，因此会执行该函数的读部分。(因为这个函数有两个部分，上一次执行了写部分，因为第二个参数是0)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/* Reading half */</div><div class="line">// 从主节点读一个命令保存在reply中</div><div class="line">reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);</div><div class="line">if (sdslen(reply) == 0) &#123;</div><div class="line">    // 主节点为了保持连接的状态，可能会在接收到PSYNC命令后发送一个空行</div><div class="line">    sdsfree(reply);</div><div class="line">    // 所以就返回PSYNC_WAIT_REPLY，调用者会将read_reply设置为1，然后再次调用该函数。</div><div class="line">    return PSYNC_WAIT_REPLY;</div><div class="line">&#125;</div><div class="line">// 如果读到了一个命令，删除fd的可读事件</div><div class="line">aeDeleteFileEvent(server.el,fd,AE_READABLE);</div><div class="line"></div><div class="line">// 接受到的是&quot;+FULLRESYNC&quot;，表示进行一次全量同步</div><div class="line">if (!strncmp(reply,&quot;+FULLRESYNC&quot;,11)) &#123;</div><div class="line">    char *runid = NULL, *offset = NULL;</div><div class="line">    // 解析回复中的内容，将runid和复制偏移量提取出来</div><div class="line">    runid = strchr(reply,&apos; &apos;);</div><div class="line">    if (runid) &#123;</div><div class="line">        runid++;    //定位到runid的地址</div><div class="line">        offset = strchr(runid,&apos; &apos;);</div><div class="line">        if (offset) offset++;   //定位offset</div><div class="line">    &#125;</div><div class="line">    // 如果runid和offset任意为空，那么发生不期望错误</div><div class="line">    if (!runid || !offset || (offset-runid-1) != CONFIG_RUN_ID_SIZE) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;Master replied with wrong +FULLRESYNC syntax.&quot;);</div><div class="line">        // 将主节点的运行ID重置为0</div><div class="line">        memset(server.repl_master_runid,0,CONFIG_RUN_ID_SIZE+1);</div><div class="line">    // runid和offset获取成功</div><div class="line">    &#125; else &#123;</div><div class="line">        // 设置服务器保存的主节点的运行ID</div><div class="line">        memcpy(server.repl_master_runid, runid, offset-runid-1);</div><div class="line">        server.repl_master_runid[CONFIG_RUN_ID_SIZE] = &apos;\0&apos;;</div><div class="line">        // 主节点的偏移量</div><div class="line">        server.repl_master_initial_offset = strtoll(offset,NULL,10);</div><div class="line">        serverLog(LL_NOTICE,&quot;Full resync from master: %s:%lld&quot;,server.repl_master_runid,          server.repl_master_initial_offset);</div><div class="line">    &#125;</div><div class="line">    // 执行全量同步，所以缓存的主节点结构没用了，将其清空</div><div class="line">    replicationDiscardCachedMaster();</div><div class="line">    sdsfree(reply);</div><div class="line">    // 返回执行的状态</div><div class="line">    return PSYNC_FULLRESYNC;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接受到的是&quot;+CONTINUE&quot;，表示进行一次部分重同步</div><div class="line">if (!strncmp(reply,&quot;+CONTINUE&quot;,9)) &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Successful partial resynchronization with master.&quot;);</div><div class="line">    sdsfree(reply);</div><div class="line">    // 因为执行部分重同步，因此要使用缓存的主节点结构，所以将其设置为当前的主节点，被同步的主节点</div><div class="line">    replicationResurrectCachedMaster(fd);</div><div class="line">    // 返回执行的状态</div><div class="line">    return PSYNC_CONTINUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收到了错误，两种情况。</div><div class="line">// 1. 主节点不支持PSYNC命令，Redis版本低于2.8</div><div class="line">// 2. 从主节点读取了一个不期望的回复</div><div class="line">if (strncmp(reply,&quot;-ERR&quot;,4)) &#123;</div><div class="line">    /* If it&apos;s not an error, log the unexpected event. */</div><div class="line">    serverLog(LL_WARNING,&quot;Unexpected reply to PSYNC from master: %s&quot;, reply);</div><div class="line">&#125; else &#123;</div><div class="line">    serverLog(LL_NOTICE,&quot;Master does not support PSYNC or is in error state (reply: %s)&quot;, reply);</div><div class="line">&#125;</div><div class="line">sdsfree(reply);</div><div class="line">replicationDiscardCachedMaster();</div><div class="line">// 发送不支持PSYNC命令的状态</div><div class="line">return PSYNC_NOT_SUPPORTED;</div></pre></td></tr></table></figure></p>
<p>至此，从节点监听主节点的读命令事件已经完成，所以取消监听了读事件。等到主节点开始传送数据给从节点时，从节点会新创建读事件。</p>
<p>该函数可以解析出主节点发过来的命令是哪一个，一共有三种：</p>
<ul>
<li>“+FULLRESYNC”：代表要进行一次全量复制。</li>
<li>“+CONTINUE”：代表要进行一次部分重同步。</li>
<li>“-ERR”：发生了错误。有两种可能：Redis版本过低不支持PSYNC命令和从节点读到一个错误回复。<br>我们关注第一个全量同步的操作。如果读到了主节点发来的”+FULLRESYNC”，那么会将同时发来的主节点运行ID和全局的复制偏移量保存到从节点的服务器属性中server.repl_master_runid和server.repl_master_initial_offset。然后返回PSYNC_FULLRESYNC。</li>
</ul>
<p>回到syncWithMaster函数，继续处理全量同步。由于要进行全量同步，如果当前从节点还作为其他节点的主节点，因此要断开所有从节点的连接，让他们也重新同步当前节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 执行到这里，psync_result == PSYNC_FULLRESYNC或PSYNC_NOT_SUPPORTED</div><div class="line">    // 准备一个合适临时文件用来写入和保存主节点传来的RDB文件数据</div><div class="line">    while(maxtries--) &#123;</div><div class="line">        // 设置文件的名字</div><div class="line">        snprintf(tmpfile,256,</div><div class="line">            &quot;temp-%d.%ld.rdb&quot;,(int)server.unixtime,(long int)getpid());</div><div class="line">        // 以读写，可执行权限打开临时文件</div><div class="line">        dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);</div><div class="line">        // 打开成功，跳出循环</div><div class="line">        if (dfd != -1) break;</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">    /* Setup the non blocking download of the bulk file. */</div><div class="line">    // 监听一个fd的读事件，并设置该事件的处理程序为readSyncBulkPayload</div><div class="line">    if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL)</div><div class="line">            == AE_ERR)</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_WARNING,</div><div class="line">            &quot;Can&apos;t create readable event for SYNC: %s (fd=%d)&quot;,</div><div class="line">            strerror(errno),fd);</div><div class="line">        goto error;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 复制状态为正从主节点接受RDB文件</div><div class="line">    server.repl_state = REPL_STATE_TRANSFER;</div><div class="line">    // 初始化RDB文件的大小</div><div class="line">    server.repl_transfer_size = -1;</div><div class="line">    // 已读的大小</div><div class="line">    server.repl_transfer_read = 0;</div><div class="line">    // 最近一个执行fsync的偏移量为0</div><div class="line">    server.repl_transfer_last_fsync_off = 0;</div><div class="line">    // 传输RDB文件的临时fd</div><div class="line">    server.repl_transfer_fd = dfd;</div><div class="line">    // 最近一次读到RDB文件内容的时间</div><div class="line">    server.repl_transfer_lastio = server.unixtime;</div><div class="line">    // 保存RDB文件的临时文件名</div><div class="line">    server.repl_transfer_tmpfile = zstrdup(tmpfile);</div><div class="line">    return;</div></pre></td></tr></table></figure></p>
<p> 准备好了所有，接下来就要等待主节点来发送RDB文件了。因此上面做了这三件事：</p>
<ul>
<li>打开一个临时文件，用来保存主节点发来的RDB文件数据的。</li>
<li>监听fd的读事件，等待主节点发送RDB文件数据，触发可读事件执行readSyncBulkPayload()函数，该函数就会把主节点发来的数据读到一个缓冲区中，然后将缓冲区的数据写到刚才打开的临时文件中，接着要载入到从节点的数据库中，最后同步到磁盘中。</li>
<li>设置复制操作的状态为server.repl_state = REPL_STATE_TRANSFER。并且初始化复制的信息，例如：RDB文件的大小，偏移量，等等。（具体看上面的代码）<br>主节点要发送RDB文件，但是回复完”+FULLRESYNC”就再也没有操作了。而子节点创建了监听主节点写RDB文件的事件，等待主节点来写，才调用readSyncBulkPayload()函数来处理。这又有问题了，到底主节点什么时候发送RDB文件呢？如果不是主动执行，那么一定就在周期性函数内被执行。</li>
</ul>
<p>它的调用关系如下：</p>
<p>serverCron()-&gt;backgroundSaveDoneHandler()-&gt;backgroundSaveDoneHandlerDisk()-&gt;updateSlavesWaitingBgsave()</p>
<p>updateSlavesWaitingBgsave()函数定义在replication.c中，主要操作有两步，我们简单介绍：</p>
<ul>
<li>只读打开主节点的临时RDB文件，然后设置从节点client复制状态为SLAVE_STATE_SEND_BULK。</li>
<li>立刻创建监听可写的事件，并设置sendBulkToSlave()函数为可写事件的处理程序。<br>当主节点执行周期性函数时，主节点会先清除之前监听的可写事件，然后立即监听新的可写事件，这样就会触发可写的事件，调用sendBulkToSlave()函数将RDB文件写入到fd中，触发从节点的读事件，从节点调用readSyncBulkPayload()函数，来将RDB文件的数据载入数据库中，至此，就保证了主从同步了。</li>
</ul>
<p>我们来简单介绍sendBulkToSlave()函数在写RDB文件时做了什么：</p>
<ul>
<li>将RDB文件的大小写给从节点，以协议格式的字符串表示的大小。</li>
<li>从RDB文件的repldbfd中读出RDB文件数据，然后写到主从同步的fd中。</li>
<li>写入完成后，又一次取消监听文件可写事件，等待下一次发送缓冲区数据时在监听触发，并且调用putSlaveOnline()函数将从节点client的复制状态设置为SLAVE_STATE_ONLINE。表示已经发送RDB文件完毕，发送缓存更新。</li>
</ul>
<h3 id="2-9-发送输出缓冲区数据"><a href="#2-9-发送输出缓冲区数据" class="headerlink" title="2.9 发送输出缓冲区数据"></a>2.9 发送输出缓冲区数据</h3><p>主节点发送完RDB文件后，调用putSlaveOnline()函数将从节点client的复制状态设置为SLAVE_STATE_ONLINE，表示已经发送RDB文件完毕，要发送缓存更新了。于是会新创建一个事件，监听写事件的发生，设置sendReplyToClient为可写的处理程序，而且会将从节点client当做私有数据闯入sendReplyToClient()当做发送缓冲区的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE,sendReplyToClient, slave)</div></pre></td></tr></table></figure></p>
<p>创建可写事件的时候，就会触发第一次可写，执行sendReplyToClient()，该函数还直接调用了riteToClient(fd,privdata,1)函数，于是将从节点client输出缓冲区的数据发送给了从节点服务器。</p>
<p>riteToClient()函数数据Redis网络连接库的函数，定义在network.c中，具体分析请看：Redis 网络连接库源码分析</p>
<p>这样就保证主从服务器的数据库状态一致了。</p>
<h3 id="2-10-命令传播"><a href="#2-10-命令传播" class="headerlink" title="2.10 命令传播"></a>2.10 命令传播</h3><p>主从节点在第一次全量同步之后就达到了一致，但是之后主节点如果执行了写命令，主节点的数据库状态就又可能发生变化，导致主从再次不一致。为了让主从节点回到一致状态，主机的执行命令后都需要将命令传播到从节点。</p>
<p>传播时会调用server.c中的propagate()函数，如果传播到从节点会调用replicationFeedSlaves(server.slaves,dbid,argv,argc)函数，该函数则会将执行的命令以协议的传输格式写到从节点client的输出缓冲区中，这就是为什么主节点会将从节点client的输出缓冲区发送到从节点（具体见标题2.9），也会添加到server.repl_backlog中。</p>
<p>我们来看看replicationFeedSlaves()函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">// 将参数列表中的参数发送给从服务器</div><div class="line">void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) &#123;</div><div class="line">    listNode *ln;</div><div class="line">    listIter li;</div><div class="line">    int j, len;</div><div class="line">    char llstr[LONG_STR_SIZE];</div><div class="line"></div><div class="line">    // 如果没有backlog且没有从节点服务器，直接返回</div><div class="line">    if (server.repl_backlog == NULL &amp;&amp; listLength(slaves) == 0) return;</div><div class="line"></div><div class="line">    /* We can&apos;t have slaves attached and no backlog. */</div><div class="line">    serverAssert(!(listLength(slaves) != 0 &amp;&amp; server.repl_backlog == NULL));</div><div class="line"></div><div class="line">    // 如果当前从节点使用的数据库不是目标的数据库，则要生成一个select命令</div><div class="line">    if (server.slaveseldb != dictid) &#123;</div><div class="line">        robj *selectcmd;</div><div class="line"></div><div class="line">        // 0 &lt;= id &lt; 10 ，可以使用共享的select命令对象</div><div class="line">        if (dictid &gt;= 0 &amp;&amp; dictid &lt; PROTO_SHARED_SELECT_CMDS) &#123;</div><div class="line">            selectcmd = shared.select[dictid];</div><div class="line">        // 否则自行按照协议格式构建select命令对象</div><div class="line">        &#125; else &#123;</div><div class="line">            int dictid_len;</div><div class="line"></div><div class="line">            dictid_len = ll2string(llstr,sizeof(llstr),dictid);</div><div class="line">            selectcmd = createObject(OBJ_STRING,</div><div class="line">                sdscatprintf(sdsempty(),</div><div class="line">                &quot;*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n&quot;,</div><div class="line">                dictid_len, llstr));</div><div class="line">        &#125;</div><div class="line">        // 将select 命令添加到backlog中</div><div class="line">        if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);</div><div class="line"></div><div class="line">        // 发送给从服务器</div><div class="line">        listRewind(slaves,&amp;li);</div><div class="line">        // 遍历所有的从服务器节点</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = ln-&gt;value;</div><div class="line">            // 从节点服务器状态为等待BGSAVE的开始，因此跳过回复，遍历下一个节点</div><div class="line">            if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;</div><div class="line">            // 添加select命令到当前从节点的回复中</div><div class="line">            addReply(slave,selectcmd);</div><div class="line">        &#125;</div><div class="line">        // 释放临时对象</div><div class="line">        if (dictid &lt; 0 || dictid &gt;= PROTO_SHARED_SELECT_CMDS)</div><div class="line">            decrRefCount(selectcmd);</div><div class="line">    &#125;</div><div class="line">    // 设置当前从节点使用的数据库ID</div><div class="line">    server.slaveseldb = dictid;</div><div class="line"></div><div class="line">    // 将命令写到backlog中</div><div class="line">    if (server.repl_backlog) &#123;</div><div class="line">        char aux[LONG_STR_SIZE+3];</div><div class="line"></div><div class="line">        // 将参数个数构建成协议标准的字符串</div><div class="line">        // *&lt;argc&gt;\r\n</div><div class="line">        aux[0] = &apos;*&apos;;</div><div class="line">        len = ll2string(aux+1,sizeof(aux)-1,argc);</div><div class="line">        aux[len+1] = &apos;\r&apos;;</div><div class="line">        aux[len+2] = &apos;\n&apos;;</div><div class="line">        // 添加到backlog中</div><div class="line">        feedReplicationBacklog(aux,len+3);</div><div class="line"></div><div class="line">        // 遍历所有的参数</div><div class="line">        for (j = 0; j &lt; argc; j++) &#123;</div><div class="line">            // 返回参数对象的长度</div><div class="line">            long objlen = stringObjectLen(argv[j]);</div><div class="line"></div><div class="line">            // 构建成协议标准的字符串，并添加到backlog中</div><div class="line">            // $&lt;len&gt;\r\n&lt;argv&gt;\r\n</div><div class="line">            aux[0] = &apos;$&apos;;</div><div class="line">            len = ll2string(aux+1,sizeof(aux)-1,objlen);</div><div class="line">            aux[len+1] = &apos;\r&apos;;</div><div class="line">            aux[len+2] = &apos;\n&apos;;</div><div class="line">            // 添加$&lt;len&gt;\r\n</div><div class="line">            feedReplicationBacklog(aux,len+3);</div><div class="line">            // 添加参数对象&lt;argv&gt;</div><div class="line">            feedReplicationBacklogWithObject(argv[j]);</div><div class="line">            // 添加\r\n</div><div class="line">            feedReplicationBacklog(aux+len+1,2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 将命令写到每一个从节点中</div><div class="line">    listRewind(server.slaves,&amp;li);</div><div class="line">    // 遍历从节点链表</div><div class="line">    while((ln = listNext(&amp;li))) &#123;</div><div class="line">        client *slave = ln-&gt;value;</div><div class="line"></div><div class="line">        // 从节点服务器状态为等待BGSAVE的开始，因此跳过回复，遍历下一个节点</div><div class="line">        if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;</div><div class="line"></div><div class="line">        // 将命令写给正在等待初次SYNC的从节点（所以这些命令在输出缓冲区中排队，直到初始SYNC完成），或已经与主节点同步</div><div class="line">        /* Add the multi bulk length. */</div><div class="line">        // 添加回复的长度</div><div class="line">        addReplyMultiBulkLen(slave,argc);</div><div class="line"></div><div class="line">        // 将所有的参数列表添加到从节点的输出缓冲区</div><div class="line">        for (j = 0; j &lt; argc; j++)</div><div class="line">            addReplyBulk(slave,argv[j]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和AOF持久化一样，再给从节点client写命令时，会将SELECT命令强制写入，以保证命令正确读到数据库中。</p>
<p>不仅写入了从节点client的输出缓冲区，而且还会将命令记录到主节点服务器的复制积压缓冲区server.repl_backlog中，这是为了网络闪断后进行部分重同步。</p>
<h2 id="3-部分重同步实现"><a href="#3-部分重同步实现" class="headerlink" title="3. 部分重同步实现"></a>3. 部分重同步实现</h2><p>刚才剖析完全量同步，但是没有考虑特殊的情况。如果在传输RDB文件的过程中，网络发生故障，主节点和从节点的连接中断，Redis会咋么做呢？</p>
<p>Redis 2.8 版本之前会在进行一次连接然后进行全量复制，但是这样效率非常地下，之后的版本都提供了部分重同步的实现。那么我们就分析一下部分重同步的实现过程。</p>
<p>部分重同步在复制的过程中，相当于标题2.8的发送PSYNC命令的部分，其他所有的部分都要进行，他只是主节点回复从节点的命令不同，回复+CONTINUE则执行部分重同步，回复+FULLRESYNC则执行全量同步。</p>
<h3 id="3-1-心跳机制"><a href="#3-1-心跳机制" class="headerlink" title="3.1 心跳机制"></a>3.1 心跳机制</h3><p>主节点是如何发现和从节点连接中断？在主从节点建立连接后，他们之间都维护者长连接并彼此发送心跳命令。主从节点彼此都有心跳机制，各自模拟成对方的客户端进行通信。</p>
<ul>
<li>主节点默认每隔10秒发送PING命令，判断从节点的连接状态。 </li>
<li><p>文件配置项：repl-ping-salve-period，默认是10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 首先，根据当前节点发送PING命令给从节点的频率发送PING命令 </div><div class="line">// 如果当前节点是某以节点的 主节点 ，那么发送PING给从节点</div><div class="line">if ((replication_cron_loops % server.repl_ping_slave_period) == 0) &#123;</div><div class="line">    // 创建PING命令对象</div><div class="line">    ping_argv[0] = createStringObject(&quot;PING&quot;,4);</div><div class="line">    // 将PING发送给从服务器</div><div class="line">    replicationFeedSlaves(server.slaves, server.slaveseldb, ping_argv, 1);</div><div class="line">    decrRefCount(ping_argv[0]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从节点在主线程中每隔1秒发送REPLCONF ACK <offset>命令，给主节点报告自己当前复制偏移量。</offset></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 定期发送ack给主节点，旧版本的Redis除外</div><div class="line">if (server.masterhost &amp;&amp; server.master &amp;&amp; !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</div><div class="line">    // 发送一个REPLCONF ACK命令给主节点去报告关于当前处理的offset。</div><div class="line">    replicationSendAck();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在周期性函数replicationCron()，每次都要检查和主节点处于连接状态的从节点和主节点的交互时间是否超时，如果超时则会调用cancelReplicationHandshake()函数，取消和主节点的连接。等到下一个周期在和主节点重新建立连接，进行复制。</p>
<h3 id="3-2-复制积压缓冲区-backlog"><a href="#3-2-复制积压缓冲区-backlog" class="headerlink" title="3.2 复制积压缓冲区(backlog)"></a>3.2 复制积压缓冲区(backlog)</h3><p>复制积压缓冲区是一个大小为1M的循环队列。主节点在命令传播时，不仅会将命令发送给所有的从节点，还会将命令写入复制积压缓冲区中（具体请看标题2.10）。</p>
<p>也就是说，复制积压缓冲区最多可以备份1M大小的数据，如果主从节点断线时间过长，复制积压缓冲区的数据会被新数据覆盖，那么当从主从中断连接起，主节点接收到的数据超过1M大小，那么从节点就无法进行部分重同步，只能进行全量复制。</p>
<p>在标题2.8，介绍的syncCommand()命令中，调用masterTryPartialResynchronization()函数会进行尝试部分重同步，在我们之前分析的第一次全量同步时，该函数会执行失败，然后返回syncCommand()函数执行全量同步，而在进行恢复主从连接后，则会进行部分重同步，masterTryPartialResynchronization()函数代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">// 该函数从主节点接收到部分重新同步请求的角度处理PSYNC命令</div><div class="line">// 成功返回C_OK，否则返回C_ERR</div><div class="line">int masterTryPartialResynchronization(client *c) &#123;</div><div class="line">    long long psync_offset, psync_len;</div><div class="line">    char *master_runid = c-&gt;argv[1]-&gt;ptr;   //主节点的运行ID</div><div class="line">    char buf[128];</div><div class="line">    int buflen;</div><div class="line"></div><div class="line">    // 主节点的运行ID是否和从节点执行PSYNC的参数提供的运行ID相同。</div><div class="line">    // 如果运行ID发生了改变，则主节点是一个不同的实例，那么就不能进行继续执行原有的复制进程</div><div class="line">    if (strcasecmp(master_runid, server.runid)) &#123;</div><div class="line">        /* Run id &quot;?&quot; is used by slaves that want to force a full resync. */</div><div class="line">        // 如果从节点的运行ID是&quot;?&quot;，表示想要强制进行一个全量同步</div><div class="line">        if (master_runid[0] != &apos;?&apos;) &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Partial resynchronization not accepted: &quot;</div><div class="line">                &quot;Runid mismatch (Client asked for runid &apos;%s&apos;, my runid is &apos;%s&apos;)&quot;,</div><div class="line">                master_runid, server.runid);</div><div class="line">        &#125; else &#123;</div><div class="line">            serverLog(LL_NOTICE,&quot;Full resync requested by slave %s&quot;,</div><div class="line">                replicationGetSlaveName(c));</div><div class="line">        &#125;</div><div class="line">        goto need_full_resync;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从参数对象中获取psync_offset</div><div class="line">    if (getLongLongFromObjectOrReply(c,c-&gt;argv[2],&amp;psync_offset,NULL) !=</div><div class="line">       C_OK) goto need_full_resync;</div><div class="line">    // 如果psync_offset小于repl_backlog_off，说明backlog所备份的数据的已经太新了，有一些数据被覆盖，则需要进行全量复制</div><div class="line">    // 如果psync_offset大于(server.repl_backlog_off + server.repl_backlog_histlen)，表示当前backlog的数据不够全，则需要进行全量复制</div><div class="line">    if (!server.repl_backlog ||</div><div class="line">        psync_offset &lt; server.repl_backlog_off ||</div><div class="line">        psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_NOTICE,</div><div class="line">            &quot;Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld).&quot;, replicationGetSlaveName(c), psync_offset);</div><div class="line">        if (psync_offset &gt; server.master_repl_offset) &#123;</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Warning: slave %s tried to PSYNC with an offset that is greater than the master replication offset.&quot;, replicationGetSlaveName(c));</div><div class="line">        &#125;</div><div class="line">        goto need_full_resync;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行到这里，则可以进行部分重同步</div><div class="line">    // 1. 设置client状态为从节点</div><div class="line">    // 2. 向从节点发送 +CONTINUE 表示接受 partial resync 被接受</div><div class="line">    // 3. 发送backlog的数据给从节点</div><div class="line"></div><div class="line">    // 设置client状态为从节点</div><div class="line">    c-&gt;flags |= CLIENT_SLAVE;</div><div class="line">    // 设置复制状态为在线，此时RDB文件传输完成，发送差异数据</div><div class="line">    c-&gt;replstate = SLAVE_STATE_ONLINE;</div><div class="line">    // 设置从节点收到ack的时间</div><div class="line">    c-&gt;repl_ack_time = server.unixtime;</div><div class="line">    // slave向master发送ack标志设置为0</div><div class="line">    c-&gt;repl_put_online_on_ack = 0;</div><div class="line">    // 将当前client加入到从节点链表中</div><div class="line">    listAddNodeTail(server.slaves,c);</div><div class="line">    // 向从节点发送 +CONTINUE</div><div class="line">    buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE\r\n&quot;);</div><div class="line">    if (write(c-&gt;fd,buf,buflen) != buflen) &#123;</div><div class="line">        freeClientAsync(c);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">    // 将backlog的数据发送从节点</div><div class="line">    psync_len = addReplyReplicationBacklog(c,psync_offset);</div><div class="line">    serverLog(LL_NOTICE,</div><div class="line">        &quot;Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.&quot;, replicationGetSlaveName(c), psync_len, psync_offset);</div><div class="line">    // 计算延迟值小于min-slaves-max-lag的从节点的个数</div><div class="line">    refreshGoodSlavesCount();</div><div class="line">    return C_OK; /* The caller can return, no full resync needed. */</div><div class="line"></div><div class="line">need_full_resync:</div><div class="line">    return C_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果可以进行部分重同步，主节点则会发送”+CONTINUE\r\n”作为从节点发送PSYNC回复（看标题2.8）。然后调用addReplyReplicationBacklog()函数，将backlog中的数据发送给从节点。于是就完成了部分重同步。</p>
<p>addReplyReplicationBacklog()函数所做的就是将backlog写到从节点的client的输出缓冲区中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（十二）--- Redis 复制(replicate)源码详细解析]]></title>
      <url>http://hlei.io/2018/02/23/redis-analysis-replicate/</url>
      <content type="html"><![CDATA[<h2 id="1-复制介绍"><a href="#1-复制介绍" class="headerlink" title="1. 复制介绍"></a>1. 复制介绍</h2><p>分布式数据库为了获取更大的存储容量和更高的并发访问量，会将原来集中式数据库中的数据分散存储到多个通过网络连接的数据存储节点上。Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="2-复制的建立"><a href="#2-复制的建立" class="headerlink" title="2. 复制的建立"></a>2. 复制的建立</h2><p>建立复制的配置方式有三种。</p>
<ul>
<li>在redis.conf文件中配置slaveof <masterip> <masterport>选项，然后指定该配置文件启动Redis生效。</masterport></masterip></li>
<li>在redis-server启动命令后加上–slaveof <masterip> <masterport>启动生效。</masterport></masterip></li>
<li><p>直接使用 slaveof <masterip> <masterport>命令在从节点执行生效。<br>我们以最简单的一主一从模型，使用第2种方式建立复制。</masterport></masterip></p>
</li>
<li><p>首先先开启主节点master实例，端口8888</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --port 8888</div></pre></td></tr></table></figure>
</li>
<li><p>接着开启从节点slave实例，端口9999，并指定指定主节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis-server --port 9999 --slaveof 127.0.0.1 8888</div><div class="line">//命令行开启Redis服务器后，会打印如下日志信息，已经开启复制了</div><div class="line">Connecting to MASTER 127.0.0.1:8888</div><div class="line">MASTER &lt;-&gt; SLAVE sync started</div><div class="line">Non blocking connect for SYNC fired the event.</div><div class="line">Master replied to PING, replication can continue...</div><div class="line">Partial resynchronization not possible (no cached master)</div><div class="line">Full resync from master: 1aff09ecd70ca640e33083f8422018b29883b9d1:1</div><div class="line">MASTER &lt;-&gt; SLAVE sync: receiving 76 bytes from master</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Flushing old data</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</div><div class="line">MASTER &lt;-&gt; SLAVE sync: Finished with success</div></pre></td></tr></table></figure>
</li>
<li><p>开启一个client，连接上从节点服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  ~ redis-cli -p 9999</div><div class="line">127.0.0.1:9999&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:slave                      //节点角色</div><div class="line">master_host:127.0.0.1           //主节点的IP</div><div class="line">master_port:8888                //主节点的端口</div><div class="line">master_link_status:up           //与主节点的连接状态</div><div class="line">master_last_io_seconds_ago:0    //主节点最后与从节点的通信时间间隔，单位秒</div><div class="line">master_sync_in_progress:0       //从节点是否正在全量同步主节点的RDB文件</div><div class="line">slave_repl_offset:407           //复制偏移量</div><div class="line">slave_priority:100              //从节点的优先级</div><div class="line">slave_read_only:1               //从节点是否只读</div><div class="line">connected_slaves:0              //连接从节点的个数</div><div class="line">master_repl_offset:0            //当前从节点作为其他从节点的主节点时的复制偏移量</div><div class="line">//以下四种信息为通用的配置</div><div class="line">repl_backlog_active:0           //复制缓冲区的状态</div><div class="line">repl_backlog_size:1048576       //复制缓冲区的大小</div><div class="line">repl_backlog_first_byte_offset:0//复制缓冲区起始偏移量，标识当前缓冲区可用的范围</div><div class="line">repl_backlog_histlen:0          //标识复制缓冲区已存在的有效数据长度</div><div class="line">127.0.0.1:9999&gt; KEYS *          //由于主节点的键空间为空，所以从节点的键空间也为空。</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，我们查看主节点的INFO replication 信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//通过INFO replication命令可以查看当前的复制信息</div><div class="line">127.0.0.1:6380&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:master                                                     //节点角色</div><div class="line">connected_slaves:1                                              //连接从节点的个数</div><div class="line">slave0:ip=127.0.0.1,port=9999,state=online,offset=631,lag=0     //连接从节点的信息</div><div class="line">master_repl_offset:631                                          //主节点的偏移量</div><div class="line">//以下四种信息为通用的配置  </div><div class="line">repl_backlog_active:1                                           //复制缓冲区的状态</div><div class="line">repl_backlog_size:1048576                                       //复制缓冲区的大小</div><div class="line">repl_backlog_first_byte_offset:2                                //复制缓冲区起始偏移量，标识当前缓冲区可用的范围</div><div class="line">repl_backlog_histlen:630                                        //由于主节点的键空间为空，所以从节点的键空间也为空。</div></pre></td></tr></table></figure></p>
<p>到此，一主一从模型的复制就建立成功了。我们可以在主节点建立一些新的键，然后查看从节点的键空间的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//根据端口区别主从节点</div><div class="line">127.0.0.1:8888&gt; HSET hash_key hello world</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:9999&gt; KEYS *  //从节点的键空间已经更新</div><div class="line">1) &quot;hash_key&quot;</div></pre></td></tr></table></figure></p>
<p>我们在查看从节点的INFO replication信息时，可以知道slave_read_only:1，从节点默认只能读不能写，因此执行写命令会得到如下回复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; SET key value</div><div class="line">(error) READONLY You can&apos;t write against a read only slave.</div></pre></td></tr></table></figure></p>
<p>只读模式由 redis.conf 文件中的 slave-read-only 选项控制，也可以通过 CONFIG SET命令来开启或关闭这个模式。</p>
<p>我们在查看从节点的INFO replication信息时，还发现有connected_slaves:0选项 ，说明Redis的复制拓扑结构支持单层或多层复制关系，从节点还可以作为其他从节点的主节点进行复制。</p>
<p>根据拓扑关系可以分为三种：</p>
<ul>
<li><p>一主一从<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication01.jpg" alt="replicate01"></p>
</li>
<li><p>一主多从<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication02.jpg" alt="replicate01"></p>
</li>
<li><p>树型主从结构<br><img src="/2018/02/23/redis-analysis-replicate/redis-replication03.jpg" alt="replicate01"></p>
</li>
</ul>
<h2 id="3-复制的断开"><a href="#3-复制的断开" class="headerlink" title="3. 复制的断开"></a>3. 复制的断开</h2><p>复制断开也是在从节点执行命令slaveof no one来断开于主节点的复制关系。例如，将刚才端口为9999的从节点断开复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; SLAVEOF no one</div><div class="line">OK</div><div class="line">//从节点服务器会打印如下日志</div><div class="line">Connection with master lost.</div><div class="line">Caching the disconnected master state.</div><div class="line">Discarding previously cached master state.</div><div class="line">MASTER MODE enabled (user request from &apos;id=3 addr=127.0.0.1:40218 fd=7 name= age=2218 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=slaveof&apos;)</div><div class="line">//主节点服务器也会打印断开的信息</div><div class="line">Connection with slave 127.0.0.1:9999 lost.</div></pre></td></tr></table></figure></p>
<p>从节点服务器断开后，从节点会晋升为主节点。从日志中可以看到MASTER MODE enabled，也可以从INFO命令查看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:9999&gt; INFO replication</div><div class="line"># Replication</div><div class="line">role:master     //角色发生变化</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="4-min-slaves配置选项"><a href="#4-min-slaves配置选项" class="headerlink" title="4. min-slaves配置选项"></a>4. min-slaves配置选项</h2><p>Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主节点在不安全的情况下执行写命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">min-slaves-to-write 3   //从节点数量少于3个，主节点拒绝执行写命令</div><div class="line">min-slaves-max-lag 10   //3个从节点的延迟(lag)值，大于或等于10，主节点拒绝执行写命令</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（九）--- 字符串命令的实现(t_string)]]></title>
      <url>http://hlei.io/2018/02/10/redis-analysis-t-string/</url>
      <content type="html"><![CDATA[<h2 id="1-字符串命令介绍"><a href="#1-字符串命令介绍" class="headerlink" title="1. 字符串命令介绍"></a>1. 字符串命令介绍</h2><table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET key value：设置指定 key 的值</td>
</tr>
<tr>
<td>2</td>
<td>GET key： 获取指定 key 的值。</td>
</tr>
<tr>
<td>3</td>
<td>GETRANGE key start end： 返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>4</td>
<td>GETSET key value：将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td>5</td>
<td>GETBIT key offset：对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>6</td>
<td>MGET key1 [key2..]：获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td>7</td>
<td>SETBIT key offset value：对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>8</td>
<td>SETEX key seconds value：将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td>9</td>
<td>SETNX key value：只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td>10</td>
<td>SETRANGE key offset value：用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td>11</td>
<td>STRLEN key：返回 key 所储存的字符串值的长度。</td>
</tr>
<tr>
<td>12</td>
<td>MSET key value [key value …]：同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td>13</td>
<td>MSETNX key value [key value …]：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td>14</td>
<td>PSETEX key milliseconds value：这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td>15</td>
<td>INCR key：将 key 中储存的数字值增一。</td>
</tr>
<tr>
<td>16</td>
<td>INCRBY key increment将 key： 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td>17</td>
<td>INCRBYFLOAT key increment：将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td>18</td>
<td>DECR key：将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td>19</td>
<td>DECRBY key decrementkey： 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td>20</td>
<td>APPEND key value：如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</td>
</tr>
</tbody>
</table>
<h2 id="2-字符串命令的实现"><a href="#2-字符串命令的实现" class="headerlink" title="2. 字符串命令的实现"></a>2. 字符串命令的实现</h2><p>字符串命令底层数据结构为 简单动态字符串SDS 。对于字符串命令，无论是命令本身还是参数，都是作为成一个对象对待的。关于redis的对象系统，请参考文章：redis对象系统源码剖析和注释。</p>
<p>在redis的对象系统中，字符串对象的底层实现类型有如下三种：</p>
<table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串实现的字符串对象</td>
</tr>
</tbody>
</table>
<p>因此，一个字符串对象的结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，字符串对象应该为 OBJ_STRING</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，分别为OBJ_STRING、OBJ_ENCODING_INT或OBJ_ENCODING_EMBSTR</div><div class="line">    unsigned encoding:4;</div><div class="line">    //暂且不关心该成员</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<p>我们假设一个key的值为”Hello World” ，因此它的空间结构如图所示：<br>[url01]</p>
<h2 id="3-字符串命令源码注释"><a href="#3-字符串命令源码注释" class="headerlink" title="3. 字符串命令源码注释"></a>3. 字符串命令源码注释</h2><p>这里列出几个重要的命令。</p>
<h3 id="3-1-SET-一类命令的最底层实现"><a href="#3-1-SET-一类命令的最底层实现" class="headerlink" title="3.1 SET 一类命令的最底层实现"></a>3.1 SET 一类命令的最底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#define OBJ_SET_NO_FLAGS 0</div><div class="line">#define OBJ_SET_NX (1&lt;&lt;0)     /* Set if key not exists. */          //在key不存在的情况下才会设置</div><div class="line">#define OBJ_SET_XX (1&lt;&lt;1)     /* Set if key exists. */              //在key存在的情况下才会设置</div><div class="line">#define OBJ_SET_EX (1&lt;&lt;2)     /* Set if time in seconds is given */ //以秒(s)为单位设置键的key过期时间</div><div class="line">#define OBJ_SET_PX (1&lt;&lt;3)     /* Set if time in ms in given */      //以毫秒(ms)为单位设置键的key过期时间</div><div class="line"></div><div class="line">//setGenericCommand()函数是以下命令: SET, SETEX, PSETEX, SETNX.的最底层实现</div><div class="line">//flags 可以是NX或XX，由上面的宏提供</div><div class="line">//expire 定义key的过期时间，格式由unit指定</div><div class="line">//ok_reply和abort_reply保存着回复client的内容，NX和XX也会改变回复</div><div class="line">//如果ok_reply为空，则使用 &quot;+OK&quot;</div><div class="line">//如果abort_reply为空，则使用 &quot;$-1&quot;</div><div class="line">void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) &#123;</div><div class="line">    long long milliseconds = 0; /* initialized to avoid any harmness warning */ //初始化，避免错误</div><div class="line"></div><div class="line">    //如果定义了key的过期时间</div><div class="line">    if (expire) &#123;</div><div class="line">        //从expire对象中取出值，保存在milliseconds中，如果出错发送默认的信息给client</div><div class="line">        if (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) != C_OK)</div><div class="line">            return;</div><div class="line">        // 如果过期时间小于等于0，则发送错误信息给client</div><div class="line">        if (milliseconds &lt;= 0) &#123;</div><div class="line">            addReplyErrorFormat(c,&quot;invalid expire time in %s&quot;,c-&gt;cmd-&gt;name);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //如果unit的单位是秒，则需要转换为毫秒保存</div><div class="line">        if (unit == UNIT_SECONDS) milliseconds *= 1000;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //lookupKeyWrite函数是为执行写操作而取出key的值对象</div><div class="line">    //如果设置了NX(不存在)，并且在数据库中 找到 该key，或者</div><div class="line">    //设置了XX(存在)，并且在数据库中 没有找到 该key</div><div class="line">    //回复abort_reply给client</div><div class="line">    if ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != NULL) ||</div><div class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == NULL))</div><div class="line">    &#123;</div><div class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //在当前db设置键为key的值为val</div><div class="line">    setKey(c-&gt;db,key,val);</div><div class="line"></div><div class="line">    //设置数据库为脏(dirty)，服务器每次修改一个key后，都会对脏键(dirty)增1</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //设置key的过期时间</div><div class="line">    //mstime()返回毫秒为单位的格林威治时间</div><div class="line">    if (expire) setExpire(c-&gt;db,key,mstime()+milliseconds);</div><div class="line"></div><div class="line">    //发送&quot;set&quot;事件的通知，用于发布订阅模式，通知客户端接受发生的事件</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;set&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //发送&quot;expire&quot;事件通知</div><div class="line">    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</div><div class="line">        &quot;expire&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //设置成功，则向客户端发送ok_reply</div><div class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-GET-一类命令的最底层实现"><a href="#3-2-GET-一类命令的最底层实现" class="headerlink" title="3.2 GET 一类命令的最底层实现"></a>3.2 GET 一类命令的最底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GET 命令的底层实现</div><div class="line">int getGenericCommand(client *c) &#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    //lookupKeyReadOrReply函数是为执行读操作而返回key的值对象，找到返回该对象，找不到会发送信息给client</div><div class="line">    //如果key不存在直接，返回0表示GET命令执行成功</div><div class="line">    if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.nullbulk)) == NULL)</div><div class="line">        return C_OK;</div><div class="line"></div><div class="line">    //如果key的值的编码类型不是字符串对象</div><div class="line">    if (o-&gt;type != OBJ_STRING) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);    //返回类型错误的信息给client，返回-1表示GET命令执行失败</div><div class="line">        return C_ERR;</div><div class="line">    &#125; else &#123;</div><div class="line">        addReplyBulk(c,o);  //返回之前找到的对象作为回复给client，返回0表示GET命令执行成功</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-DECR-和-INCR-底层实现"><a href="#3-3-DECR-和-INCR-底层实现" class="headerlink" title="3.3 DECR 和 INCR 底层实现"></a>3.3 DECR 和 INCR 底层实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">// DECR key</div><div class="line">// INCR key</div><div class="line">//INCR和DECR命令的底层实现</div><div class="line">void incrDecrCommand(client *c, long long incr) &#123;</div><div class="line">    long long value, oldvalue;</div><div class="line">    robj *o, *new;</div><div class="line"></div><div class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);   //以写操作获取key的value对象</div><div class="line"></div><div class="line">    //找到了value对象但是value对象不是字符串类型，直接返回</div><div class="line">    if (o != NULL &amp;&amp; checkType(c,o,OBJ_STRING)) return;</div><div class="line"></div><div class="line">    //将字符串类型的value转换为longlong类型保存在value中</div><div class="line">    if (getLongLongFromObjectOrReply(c,o,&amp;value,NULL) != C_OK) return;</div><div class="line"></div><div class="line">    oldvalue = value;   //备份旧的value</div><div class="line"></div><div class="line">    //如果incr超出longlong类型所能表示的范围，发送错误信息</div><div class="line">    if ((incr &lt; 0 &amp;&amp; oldvalue &lt; 0 &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</div><div class="line">        (incr &gt; 0 &amp;&amp; oldvalue &gt; 0 &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</div><div class="line">        addReplyError(c,&quot;increment or decrement would overflow&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    value += incr;  //计算新的value值</div><div class="line"></div><div class="line">    //value对象目前非共享，编码为整型类型，且新value值不在共享范围，且value处于long类型所表示的范围内</div><div class="line">    if (o &amp;&amp; o-&gt;refcount == 1 &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</div><div class="line">        (value &lt; 0 || value &gt;= OBJ_SHARED_INTEGERS) &amp;&amp;</div><div class="line">        value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX)</div><div class="line">    &#123;</div><div class="line">        new = o;</div><div class="line">        o-&gt;ptr = (void*)((long)value);  //设置vlaue对象的值</div><div class="line">    &#125; else &#123;</div><div class="line">        //当不满足以上任意条件，则新创建一个字符串对象</div><div class="line">        new = createStringObjectFromLongLong(value);</div><div class="line"></div><div class="line">        //如果之前的value对象存在</div><div class="line">        if (o) &#123;</div><div class="line">            dbOverwrite(c-&gt;db,c-&gt;argv[1],new);  //用new对象去重写key的值</div><div class="line">        &#125; else &#123;</div><div class="line">            dbAdd(c-&gt;db,c-&gt;argv[1],new);        //如果之前的value不存在，将key和new组成新的key-value对</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);    //当数据库的键被改动，则会调用该函数发送信号</div><div class="line">    //发送&quot;incrby&quot;事件通知</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;incrby&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    //设置脏键</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //回复信息给client</div><div class="line">    addReply(c,shared.colon);</div><div class="line">    addReply(c,new);</div><div class="line">    addReply(c,shared.crlf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-APPEND-实现"><a href="#4-APPEND-实现" class="headerlink" title=".4 APPEND 实现"></a>.4 APPEND 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// APPEND key value</div><div class="line">// APPEND命令的实现</div><div class="line">void appendCommand(client *c) &#123;</div><div class="line">    size_t totlen;</div><div class="line">    robj *o, *append;</div><div class="line"></div><div class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);   //以写操作获取key的value对象</div><div class="line"></div><div class="line">    //如果没有获取到vlaue，则要创建一个</div><div class="line">    if (o == NULL) &#123;</div><div class="line">        /* Create the key */</div><div class="line">        c-&gt;argv[2] = tryObjectEncoding(c-&gt;argv[2]); //对参数value进行优化编码</div><div class="line">        dbAdd(c-&gt;db,c-&gt;argv[1],c-&gt;argv[2]); //将key和value组成新的key-value对</div><div class="line">        incrRefCount(c-&gt;argv[2]);           //增加value的引用计数</div><div class="line">        totlen = stringObjectLen(c-&gt;argv[2]);   //返回vlaue的长度</div><div class="line">    &#125; else &#123;    //获取到value</div><div class="line">        /* Key exists, check type */</div><div class="line">        if (checkType(c,o,OBJ_STRING))  //如果value不是字符串类型的对象直接返回</div><div class="line">            return;</div><div class="line"></div><div class="line">        /* &quot;append&quot; is an argument, so always an sds */</div><div class="line">        //获得追加的值对象</div><div class="line">        append = c-&gt;argv[2];</div><div class="line">        //计算追加后的长度</div><div class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</div><div class="line">        //如果追加后的长度超出范围，则返回</div><div class="line">        if (checkStringLength(c,totlen) != C_OK)</div><div class="line">            return;</div><div class="line"></div><div class="line">        /* Append the value */</div><div class="line">        //因为要根据value修改key的值，因此如果key原来的值是共享的，需要解除共享，新创建一个值对象与key组对</div><div class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);</div><div class="line">        //将vlaue对象的值后面追加上append的值</div><div class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</div><div class="line">        //计算出追加后值的长度</div><div class="line">        totlen = sdslen(o-&gt;ptr);</div><div class="line">    &#125;</div><div class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);//当数据库的键被改动，则会调用该函数发送信号</div><div class="line">    //发送&quot;append&quot;事件通知</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;append&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    //设置脏键</div><div class="line">    server.dirty++;</div><div class="line">    //发送追加后value的长度给client</div><div class="line">    addReplyLongLong(c,totlen);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（二十一）--- 单机服务器实现]]></title>
      <url>http://hlei.io/2018/02/10/redis-analysis-standalone/</url>
      <content type="html"><![CDATA[<h2 id="1-Redis-服务器"><a href="#1-Redis-服务器" class="headerlink" title="1. Redis 服务器"></a>1. Redis 服务器</h2><p>Redis服务器负责与客户端建立网络连接，处理发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并且通过一系列资源管理措施来维持服务器自身的正常运转。本次主要剖析server.c文件，本文主要介绍Redis服务器的一下几个实现：</p>
<ul>
<li>命令的执行过程</li>
<li>Redis服务器的周期性任务</li>
<li>maxmemory的策略</li>
<li>Redis服务器的main函数</li>
</ul>
<h2 id="2-命令的执行过程"><a href="#2-命令的执行过程" class="headerlink" title="2. 命令的执行过程"></a>2. 命令的执行过程</h2><p>Redis一个命令的完整执行过程如下：</p>
<ul>
<li>客户端发送命令请求</li>
<li>服务器接收命令请求</li>
<li>服务器执行命令请求</li>
<li>将回复发送给客户端<br>关于命令接收与命令回复，在Redis 网络连接库剖析一文已经详细剖析过，本篇主要针对第三步，也就是服务器执行命令的过程进行剖析。</li>
</ul>
<p>服务器在接收到命令后，会将命令以对象的形式保存在服务器client的参数列表robj **argv中，因此服务器执行命令请求时，服务器已经读入了一套命令参数保存在参数列表中。执行命令的过程对应的函数是processCommand()，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div></pre></td><td class="code"><pre><div class="line">// 如果client没有被关闭则返回C_OK，调用者可以继续执行其他的操作，否则返回C_ERR，表示client被销毁</div><div class="line">int processCommand(client *c) &#123;</div><div class="line">    // 如果是 quit 命令，则单独处理</div><div class="line">    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;quit&quot;)) &#123;</div><div class="line">        addReply(c,shared.ok);</div><div class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;   //设置client的状态为回复后立即关闭，返回C_ERR</div><div class="line">        return C_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从数据库的字典中查找该命令</div><div class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</div><div class="line">    // 不存在的命令</div><div class="line">    if (!c-&gt;cmd) &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReplyErrorFormat(c,&quot;unknown command &apos;%s&apos;&quot;,</div><div class="line">            (char*)c-&gt;argv[0]-&gt;ptr);</div><div class="line">        return C_OK;</div><div class="line">    // 参数数量不匹配</div><div class="line">    &#125; else if ((c-&gt;cmd-&gt;arity &gt; 0 &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</div><div class="line">               (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReplyErrorFormat(c,&quot;wrong number of arguments for &apos;%s&apos; command&quot;,</div><div class="line">            c-&gt;cmd-&gt;name);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if the user is authenticated */</div><div class="line">    // 如果服务器设置了密码，但是没有认证成功</div><div class="line">    if (server.requirepass &amp;&amp; !c-&gt;authenticated &amp;&amp; c-&gt;cmd-&gt;proc != authCommand)</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c); //如果是事务状态的命令，则设置事务为失败</div><div class="line">        addReply(c,shared.noautherr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果开启了集群模式，则执行集群的重定向操作，下面的两种情况例外：</div><div class="line">    /*</div><div class="line">        1. 命令的发送是主节点服务器</div><div class="line">        2. 命令没有key</div><div class="line">    */</div><div class="line">    if (server.cluster_enabled &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</div><div class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0 &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != execCommand))</div><div class="line">    &#123;</div><div class="line">        int hashslot;</div><div class="line">        int error_code;</div><div class="line">        // 从集群中返回一个能够执行命令的节点</div><div class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</div><div class="line">                                        &amp;hashslot,&amp;error_code);</div><div class="line">        // 返回的节点不合格</div><div class="line">        if (n == NULL || n != server.cluster-&gt;myself) &#123;</div><div class="line">            // 如果是执行事务的命令，则取消事务</div><div class="line">            if (c-&gt;cmd-&gt;proc == execCommand) &#123;</div><div class="line">                discardTransaction(c);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 将事务状态设置为失败</div><div class="line">                flagTransaction(c);</div><div class="line">            &#125;</div><div class="line">            // 执行client的重定向操作</div><div class="line">            clusterRedirectClient(c,n,hashslot,error_code);</div><div class="line">            return C_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器有最大内存的限制</div><div class="line">    if (server.maxmemory) &#123;</div><div class="line">        // 按需释放一部分内存</div><div class="line">        int retval = freeMemoryIfNeeded();</div><div class="line">        // freeMemoryIfNeeded()函数之后需要冲洗从节点的输出缓冲区，这可能导致被释放的从节点是一个活跃的client</div><div class="line">        // 如果当前的client被释放，返回C_ERR</div><div class="line">        if (server.current_client == NULL) return C_ERR;</div><div class="line"></div><div class="line">        // 如果命令会耗费大量的内存但是释放内存失败</div><div class="line">        if ((c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM) &amp;&amp; retval == C_ERR) &#123;</div><div class="line">            // 将事务状态设置为失败</div><div class="line">            flagTransaction(c);</div><div class="line">            addReply(c, shared.oomerr);</div><div class="line">            return C_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果 BGSAVE 命令执行错误而且服务器是一个主节点，那么不接受写命令</div><div class="line">    if (((server.stop_writes_on_bgsave_err &amp;&amp;</div><div class="line">          server.saveparamslen &gt; 0 &amp;&amp;</div><div class="line">          server.lastbgsave_status == C_ERR) ||</div><div class="line">          server.aof_last_write_status == C_ERR) &amp;&amp;</div><div class="line">        server.masterhost == NULL &amp;&amp;</div><div class="line">        (c-&gt;cmd-&gt;flags &amp; CMD_WRITE ||</div><div class="line">         c-&gt;cmd-&gt;proc == pingCommand))</div><div class="line">    &#123;</div><div class="line">        // 将事务状态设置为失败</div><div class="line">        flagTransaction(c);</div><div class="line">        // 如果上一次执行AOF成功回复BGSAVE错误回复</div><div class="line">        if (server.aof_last_write_status == C_OK)</div><div class="line">            addReply(c, shared.bgsaveerr);</div><div class="line">        else</div><div class="line">            addReplySds(c,</div><div class="line">                sdscatprintf(sdsempty(),</div><div class="line">                &quot;-MISCONF Errors writing to the AOF file: %s\r\n&quot;,</div><div class="line">                strerror(server.aof_last_write_errno)));</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有足够的良好的从节点而且用户配置了 min-slaves-to-write，那么不接受写命令</div><div class="line">    if (server.masterhost == NULL &amp;&amp;</div><div class="line">        server.repl_min_slaves_to_write &amp;&amp;</div><div class="line">        server.repl_min_slaves_max_lag &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;flags &amp; CMD_WRITE &amp;&amp;</div><div class="line">        server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</div><div class="line">    &#123;</div><div class="line">        // 将事务状态设置为失败</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.noreplicaserr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果这是一个只读的从节点服务器，则不接受写命令</div><div class="line">    if (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;flags &amp; CMD_WRITE)</div><div class="line">    &#123;</div><div class="line">        addReply(c, shared.roslaveerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果处于发布订阅模式，但是执行的不是发布订阅命令，返回</div><div class="line">    if (c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != punsubscribeCommand) &#123;</div><div class="line">        addReplyError(c,&quot;only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context&quot;);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果是从节点且和主节点断开了连接，不允许从服务器带有过期数据，返回</div><div class="line">    if (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</div><div class="line">        server.repl_serve_stale_data == 0 &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;flags &amp; CMD_STALE))</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.masterdownerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器处于载入状态，如果命令不是CMD_LOADING标识，则不执行，返回</div><div class="line">    if (server.loading &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING)) &#123;</div><div class="line">        addReply(c, shared.loadingerr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果lua脚本超时，限制执行一部分命令，如shutdown、scriptCommand</div><div class="line">    if (server.lua_timedout &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</div><div class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</div><div class="line">          c-&gt;argc == 2 &amp;&amp;</div><div class="line">          tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == &apos;n&apos;) &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</div><div class="line">          c-&gt;argc == 2 &amp;&amp;</div><div class="line">          tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == &apos;k&apos;))</div><div class="line">    &#123;</div><div class="line">        flagTransaction(c);</div><div class="line">        addReply(c, shared.slowscripterr);</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行命令</div><div class="line">    // client处于事务环境中，但是执行命令不是exec、discard、multi和watch</div><div class="line">    if (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</div><div class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</div><div class="line">    &#123;</div><div class="line">        // 除了上述的四个命令，其他的命令添加到事务队列中</div><div class="line">        queueMultiCommand(c);</div><div class="line">        addReply(c,shared.queued);</div><div class="line">    // 执行普通的命令</div><div class="line">    &#125; else &#123;</div><div class="line">        call(c,CMD_CALL_FULL);</div><div class="line">        // 保存写全局的复制偏移量</div><div class="line">        c-&gt;woff = server.master_repl_offset;</div><div class="line">        // 如果因为BLPOP而阻塞的命令已经准备好，则处理client的阻塞状态</div><div class="line">        if (listLength(server.ready_keys))</div><div class="line">            handleClientsBlockedOnLists();</div><div class="line">    &#125;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们总结出执行命令的大致过程：</p>
<ul>
<li>查找命令。对应的代码是：c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</li>
<li>执行命令前的准备。对应这些判断语句。</li>
<li>执行命令。对应代码是：call(c,CMD_CALL_FULL);</li>
</ul>
<p>我们就大致就这三个过程详细解释。</p>
<h3 id="2-1-查找命令"><a href="#2-1-查找命令" class="headerlink" title="2.1 查找命令"></a>2.1 查找命令</h3><p>lookupCommand()函数是对dictFetchValue(server.commands, name);的封装。而这个函数的意思是：从server.commands字典中查找name命令。这个保存命令表的字典，键是命令的名称，值是命令表的地址。因此我们介绍服务器初始化时的一个操作，就是创建一张命令表。命令表代码简化表示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct redisCommand redisCommandTable[] = &#123;</div><div class="line">    &#123;&quot;get&quot;,getCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0&#125;,</div><div class="line">    &#123;&quot;set&quot;,setCommand,-3,&quot;wm&quot;,0,NULL,1,1,1,0,0&#125;,</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们只展示了命令表的两条，可以通过COMMAND COUNT命令查看命令的个数。虽然只有两条，但是可以说明问题。</p>
<p>首先命令表是就是一个数组，数组的每个成员都是一个struct redisCommand结构体，对每个数组成员都进行了初始化。我们一次对每个值进行分析：以GET命令为例子。</p>
<ul>
<li>char *name：命令的名字。对应 “get”。</li>
<li>redisCommandProc *proc：命令实现的函数。对应 getCommand。</li>
<li>int arity：参数个数，-N表示大于等于N。对应2。</li>
<li>char *sflags：命令的属性，用以下字符作为标识。对应”rF”。 <ul>
<li>w：写入命令，会修改数据库。</li>
<li>r：读取命令，不会修改数据库。</li>
<li>m：一旦执行会增加内存使用，如果内存短缺则不被允许执行。</li>
<li>a：管理员命令，例如：SAVE or SHUTDOWN。</li>
<li>p：发布订阅有关的命令。</li>
<li>f：强制进行复制的命令，无视服务器的脏键。</li>
<li>s：不能在脚本中执行的命令。</li>
<li>R：随机命令。相同的键有相同的参数，在相同的数据库中，可能会有不同的结果。</li>
<li>S：如果在脚本中调用，那么会对这个命令的输出进行一次排序。</li>
<li>l：当载入数据库时，允许执行该命令。</li>
<li>t：从节点服务器持有过期数据时，允许执行的命令。</li>
<li>M：不能在 MONITOR 下自动传播的命令。</li>
<li>k：为该命令执行一个隐式的ASKING，所以在集群模式下，如果槽被标记为’importing’，那这个命令会被接收。<br>*F：快速执行的命令。时间复杂度为O(1) or O(log(N))的命令只要内核调度为Redis分配时间片，那么就不应该在执行时被延迟。</li>
</ul>
</li>
<li>int flags：sflags的二进制标识形式，可以通过位运算进行组合。对应0。</li>
<li>redisGetKeysProc *getkeys_proc：从命令中获取键的参数，是一个可选的功能，一般用于三个字段不够执行键的参数的情况。对应NULL。</li>
<li>int firstkey：第一个参数是 key。对应1。</li>
<li>int lastkey：最后一个参数是 key。对应1。</li>
<li>int keystep：从第一个 key 到最后一个 key 的步长。MSET 的步长是 2 因为：key,val,key,val,…。对应1。</li>
<li>long long microseconds：记录执行命令的耗费总时长。对应0。</li>
<li>long long calls：记录命令被执行的总次数。对应0。<br>当从命令表中找到命令后，会将找到的命令的地址，返回给struct redisCommand <em>cmd, </em>lastcmd;这两个指针保存起来。到此查找命令的操作就完成。</li>
</ul>
<h2 id="2-2-执行命令前的准备"><a href="#2-2-执行命令前的准备" class="headerlink" title="2.2 执行命令前的准备"></a>2.2 执行命令前的准备</h2><p>此时，命令已经在命令表中查找到，并且保存在了对应的指针中。但是真正执行前，还进行了许多的情况的判断。我们简单列举几种。</p>
<ul>
<li>首先就是判断命令的参数是否匹配。</li>
<li>检查服务器的认证是否通过。</li>
<li>集群模式下的判断。</li>
<li>服务器最大内存限制是否通过。</li>
<li>某些情况下，不接受写命令。</li>
<li>发布订阅模式。</li>
<li>是否是lua脚本中的命令。<br>等等……<br>所以，命令执行的过程还是很复杂的，简单总结一句：命令不易，何况人生。</li>
</ul>
<p>2.3 执行命令<br>执行命令调用了call(c,CMD_CALL_FULL)函数，该函数是执行命令的核心。但是不用想，这个函数一定是对回调函数c-&gt;cmd-&gt;proc(c)的封装，因为proc指向命令的实现函数。我们贴出该函数的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">void call(client *c, int flags) &#123;</div><div class="line">    long long dirty, start, duration;</div><div class="line">    int client_old_flags = c-&gt;flags;    //备份client的flags</div><div class="line"></div><div class="line">    // 将命令发送给 MONITOR</div><div class="line">    if (listLength(server.monitors) &amp;&amp;</div><div class="line">        !server.loading &amp;&amp;</div><div class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</div><div class="line">    &#123;</div><div class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清除一些需要按照命令需求设置的标志，以防干扰</div><div class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line">    // 初始化Redis操作数组，用来追加命令的传播</div><div class="line">    redisOpArrayInit(&amp;server.also_propagate);</div><div class="line"></div><div class="line">    /* Call the command. */</div><div class="line">    // 备份脏键数</div><div class="line">    dirty = server.dirty;</div><div class="line">    // 获取执行命令的开始时间</div><div class="line">    start = ustime();</div><div class="line">    // 执行命令</div><div class="line">    c-&gt;cmd-&gt;proc(c);</div><div class="line">    // 命令的执行时间</div><div class="line">    duration = ustime()-start;</div><div class="line">    // 命令修改的键的个数</div><div class="line">    dirty = server.dirty-dirty;</div><div class="line">    if (dirty &lt; 0) dirty = 0;</div><div class="line"></div><div class="line">    // 当执行 EVAL 命令时正在加载AOF，而且不希望Lua调用的命令进入slowlog或填充统计信息</div><div class="line">    if (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</div><div class="line">        flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);  //取消慢查询和记录统计信息的标志</div><div class="line"></div><div class="line">    // 如果函数调用者是Lua脚本，且命令的flags或客户端的flags指定了强制传播，我们要强制EVAL调用者传播脚本</div><div class="line">    if (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) &#123;</div><div class="line">        // 如果指定了强制将命令传播到从节点</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_REPL)</div><div class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;  //强制执行lua脚本的client要传播命令到从节点</div><div class="line">        // 如果指定了强制将节点传播到AOF中</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_AOF)</div><div class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;   //强制执行lua脚本的client要传播命令到AOF文件</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 命令的flags指定了慢查询标志，要将总的统计信息推入慢查询日志中</div><div class="line">    if (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; c-&gt;cmd-&gt;proc != execCommand) &#123;</div><div class="line">        char *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</div><div class="line">                              &quot;fast-command&quot; : &quot;command&quot;;</div><div class="line">        // 记录将延迟事件和延迟时间关联到延迟诊断的字典中</div><div class="line">        latencyAddSampleIfNeeded(latency_event,duration/1000);</div><div class="line">        // 将总的统计信息推入慢查询日志中</div><div class="line">        slowlogPushEntryIfNeeded(c-&gt;argv,c-&gt;argc,duration);</div><div class="line">    &#125;</div><div class="line">    // 命令的flags指定了CMD_CALL_STATS，更新命令的统计信息</div><div class="line">    if (flags &amp; CMD_CALL_STATS) &#123;</div><div class="line">        c-&gt;lastcmd-&gt;microseconds += duration;</div><div class="line">        c-&gt;lastcmd-&gt;calls++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器或追加到AOF中</div><div class="line">    if (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</div><div class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</div><div class="line">    &#123;</div><div class="line">        // 保存传播的标志，初始化为空</div><div class="line">        int propagate_flags = PROPAGATE_NONE;</div><div class="line"></div><div class="line">        // 如果命令修改了数据库中的键，则要传播到AOF和从节点中</div><div class="line">        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</div><div class="line"></div><div class="line">        // 如果client设置了强制AOF和复制的标志，则设置传播的标志</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</div><div class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</div><div class="line"></div><div class="line">        // 如果client的flags设置了CLIENT_PREVENT_REPL/AOF_PROP，表示阻止命令的传播到从节点或AOF，则取消传播对应标志</div><div class="line">        if (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</div><div class="line">            !(flags &amp; CMD_CALL_PROPAGATE_REPL))</div><div class="line">                propagate_flags &amp;= ~PROPAGATE_REPL;</div><div class="line">        if (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</div><div class="line">            !(flags &amp; CMD_CALL_PROPAGATE_AOF))</div><div class="line">                propagate_flags &amp;= ~PROPAGATE_AOF;</div><div class="line"></div><div class="line">        // 如果至少设置了一种传播，则执行相应传播命令操作</div><div class="line">        if (propagate_flags != PROPAGATE_NONE)</div><div class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清除一些需要按照命令需求设置的标志，以防干扰</div><div class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line">    // 恢复client原始的flags</div><div class="line">    c-&gt;flags |= client_old_flags &amp;</div><div class="line">        (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</div><div class="line"></div><div class="line">    // 传播追加在Redis操作数组中的命令</div><div class="line">    if (server.also_propagate.numops) &#123;</div><div class="line">        int j;</div><div class="line">        redisOp *rop;</div><div class="line">        // 如果命令的flags设置传播的标志</div><div class="line">        if (flags &amp; CMD_CALL_PROPAGATE) &#123;</div><div class="line">            // 遍历所有的命令</div><div class="line">            for (j = 0; j &lt; server.also_propagate.numops; j++) &#123;</div><div class="line">                rop = &amp;server.also_propagate.ops[j];</div><div class="line">                int target = rop-&gt;target;</div><div class="line">                /* Whatever the command wish is, we honor the call() flags. */</div><div class="line">                // 执行相应传播命令操作</div><div class="line">                if (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</div><div class="line">                if (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</div><div class="line">                if (target)</div><div class="line">                    propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 释放Redis操作数组</div><div class="line">        redisOpArrayFree(&amp;server.also_propagate);</div><div class="line">    &#125;</div><div class="line">    // 命令执行的次数加1</div><div class="line">    server.stat_numcommands++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行命令时，可以指定一个flags。这个flags是用于执行完命令之后的一些后续工作。我们说明这些flags的含义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CMD_CALL_NONE：没有指定flags</div><div class="line">CMD_CALL_SLOWLOG：检查命令的执行速度，如果需要记录在慢查询日志中</div><div class="line">CMD_CALL_STATS：记录命令的统计信息</div><div class="line">CMD_CALL_PROPAGATE_AOF：如果client设置了强制传播的标志或修改了数据集，则将命令追加到AOF文件中</div><div class="line">CMD_CALL_PROPAGATE_REPL：如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器中</div><div class="line">CMD_CALL_PROPAGATE：如果client设置了强制传播的标志或修改了数据集，则将命令发送给从节点服务器或追加到AOF中</div><div class="line">CMD_CALL_FULL：包含以上所有的含义</div></pre></td></tr></table></figure></p>
<p>执行命令c-&gt;cmd-&gt;proc(c)就相当于执行了命令实现的函数，然后会在执行完成后，由这些函数产生相应的命令回复，根据回复的大小，会将回复保存在输出缓冲区buf或回复链表repl中。然后服务器会调用writeToClient()函数来将回复写到fd中。详细请看：Redis 网络连接库剖析。</p>
<p>至此，一条命令的执行过程就很清楚明了了。</p>
<h2 id="3-Redis服务器的周期性任务"><a href="#3-Redis服务器的周期性任务" class="headerlink" title="3. Redis服务器的周期性任务"></a>3. Redis服务器的周期性任务</h2><p>我们曾经在Redis 事件处理实现一文中说到，Redis的事件分为文件事件（file event）和时间事件（time event）。时间事件虽然是晚于文件事件执行，但是会每隔100ms都会执行一次。话不多说直接上代码：Redis 单机服务器实现源码注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div></pre></td><td class="code"><pre><div class="line">// 使用一个宏定义：run_with_period(milliseconds) &#123; .... &#125;，实现一部分代码有次数限制的被执行</div><div class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;</div><div class="line">    int j;</div><div class="line">    UNUSED(eventLoop);</div><div class="line">    UNUSED(id);</div><div class="line">    UNUSED(clientData);</div><div class="line"></div><div class="line">    // 如果设置了看门狗，则在过期时间内，递达一个 SIGALRM 信号</div><div class="line">    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);</div><div class="line"></div><div class="line">    // 设置服务器的时间缓存</div><div class="line">    updateCachedTime();</div><div class="line"></div><div class="line">    // 更新服务器的一些统计值</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        // 命令执行的次数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);</div><div class="line">        // 从网络读到的字节数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,</div><div class="line">                server.stat_net_input_bytes);</div><div class="line">        // 已经写到网络的字节数</div><div class="line">        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,</div><div class="line">                server.stat_net_output_bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 服务器的LRU时间表示位数为24位，因此最长表示2^24秒，大约1.5年，只要在1.5年内，该对象被访问，那么就不会出现对象的LRU时间比服务器的时钟还要年轻的现象</div><div class="line">    // LRU_CLOCK_RESOLUTION 可以改变LRU时间的精度</div><div class="line"></div><div class="line">    // 获取服务器的LRU时钟</div><div class="line">    server.lruclock = getLRUClock();</div><div class="line"></div><div class="line">    // 更新服务器的最大内存使用量峰值</div><div class="line">    if (zmalloc_used_memory() &gt; server.stat_peak_memory)</div><div class="line">        server.stat_peak_memory = zmalloc_used_memory();</div><div class="line"></div><div class="line">    // 更新常驻内存的大小</div><div class="line">    server.resident_set_size = zmalloc_get_rss();</div><div class="line"></div><div class="line">    // 安全的关闭服务器</div><div class="line">    if (server.shutdown_asap) &#123;</div><div class="line">        // 关闭服务器前的准备动作，成功则关闭服务器</div><div class="line">        if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);</div><div class="line">        // 失败则打印日志</div><div class="line">        serverLog(LL_WARNING,&quot;SIGTERM received but errors trying to shut down the server, check the logs for more information&quot;);</div><div class="line">        // 撤销关闭服务器标志</div><div class="line">        server.shutdown_asap = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 打印数据库的信息到日志中</div><div class="line">    run_with_period(5000) &#123;</div><div class="line">        // 遍历数据库</div><div class="line">        for (j = 0; j &lt; server.dbnum; j++) &#123;</div><div class="line">            long long size, used, vkeys;</div><div class="line"></div><div class="line">            // 获取当前数据库的键值对字典的槽位数，键值对字典已使用的数量，过期键字典已使用的数量</div><div class="line">            size = dictSlots(server.db[j].dict);</div><div class="line">            used = dictSize(server.db[j].dict);</div><div class="line">            vkeys = dictSize(server.db[j].expires);</div><div class="line">            // 打印到日志中</div><div class="line">            if (used || vkeys) &#123;</div><div class="line">                serverLog(LL_VERBOSE,&quot;DB %d: %lld keys (%lld volatile) in %lld slots HT.&quot;,j,used,vkeys,size);</div><div class="line">                /* dictPrintStats(server.dict); */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果服务器不在哨兵模式下，那么周期性打印一些连接client的信息到日志中</div><div class="line">    if (!server.sentinel_mode) &#123;</div><div class="line">        run_with_period(5000) &#123;</div><div class="line">            serverLog(LL_VERBOSE,</div><div class="line">                &quot;%lu clients connected (%lu slaves), %zu bytes in use&quot;,</div><div class="line">                listLength(server.clients)-listLength(server.slaves),</div><div class="line">                listLength(server.slaves),</div><div class="line">                zmalloc_used_memory());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 执行client的周期性任务</div><div class="line">    clientsCron();</div><div class="line"></div><div class="line">    // 执行数据库的周期性任务</div><div class="line">    databasesCron();</div><div class="line"></div><div class="line">    // 如果当前没有正在进行RDB和AOF持久化操作，且AOF重写操作被提上了日程，那么在后台执行AOF的重写操作</div><div class="line">    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</div><div class="line">        server.aof_rewrite_scheduled)</div><div class="line">    &#123;</div><div class="line">        rewriteAppendOnlyFileBackground();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果正在进行RDB或AOF重写等操作，那么等待接收子进程发来的信息</div><div class="line">    if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||</div><div class="line">        ldbPendingChildren())</div><div class="line">    &#123;</div><div class="line">        int statloc;</div><div class="line">        pid_t pid;</div><div class="line"></div><div class="line">        // 接收所有子进程发送的信号，非阻塞</div><div class="line">        if ((pid = wait3(&amp;statloc,WNOHANG,NULL)) != 0) &#123;</div><div class="line">            // 获取退出码</div><div class="line">            int exitcode = WEXITSTATUS(statloc);</div><div class="line">            int bysignal = 0;</div><div class="line"></div><div class="line">            // 判断子进程是否因为信号而终止，是的话，取得子进程因信号而中止的信号码</div><div class="line">            if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</div><div class="line"></div><div class="line">            // 子进程没有退出，还在进行RDB或AOF重写等操作</div><div class="line">            if (pid == -1) &#123;</div><div class="line">                // 打印日志</div><div class="line">                serverLog(LL_WARNING,&quot;wait3() returned an error: %s. &quot;</div><div class="line">                    &quot;rdb_child_pid = %d, aof_child_pid = %d&quot;,</div><div class="line">                    strerror(errno),</div><div class="line">                    (int) server.rdb_child_pid,</div><div class="line">                    (int) server.aof_child_pid);</div><div class="line">            // RDB持久化完成</div><div class="line">            &#125; else if (pid == server.rdb_child_pid) &#123;</div><div class="line">                // 将RDB文件写入磁盘或网络中</div><div class="line">                backgroundSaveDoneHandler(exitcode,bysignal);</div><div class="line">            // AOF持久化完成</div><div class="line">            &#125; else if (pid == server.aof_child_pid) &#123;</div><div class="line">                // 将重写缓冲区的命令追加AOF文件中，且进行同步操作</div><div class="line">                backgroundRewriteDoneHandler(exitcode,bysignal);</div><div class="line">            // 其他子进程，打印日志</div><div class="line">            &#125; else &#123;</div><div class="line">                if (!ldbRemoveChild(pid)) &#123;</div><div class="line">                    serverLog(LL_WARNING,</div><div class="line">                        &quot;Warning, detected child with unmatched pid: %ld&quot;,</div><div class="line">                        (long)pid);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 更新能否resize哈希的策略</div><div class="line">            updateDictResizePolicy();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    // 没有正在进行RDB或AOF重写等操作，那么检查是否需要执行</div><div class="line">    &#125; else &#123;</div><div class="line">        // 遍历save命令的参数数组</div><div class="line">         for (j = 0; j &lt; server.saveparamslen; j++) &#123;</div><div class="line">            struct saveparam *sp = server.saveparams+j;</div><div class="line"></div><div class="line">            // 数据库的键被修改的次数大于SAVE命令参数指定的修改次数，且已经过了SAVE命令参数指定的秒数</div><div class="line">            if (server.dirty &gt;= sp-&gt;changes &amp;&amp;</div><div class="line">                server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</div><div class="line">                (server.unixtime-server.lastbgsave_try &gt;</div><div class="line">                 CONFIG_BGSAVE_RETRY_DELAY ||</div><div class="line">                 server.lastbgsave_status == C_OK))</div><div class="line">            &#123;</div><div class="line">                serverLog(LL_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;,</div><div class="line">                    sp-&gt;changes, (int)sp-&gt;seconds);</div><div class="line">                // 进行 BGSAVE 操作</div><div class="line">                rdbSaveBackground(server.rdb_filename);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         // 是否触发AOF重写操作</div><div class="line">         if (server.rdb_child_pid == -1 &amp;&amp;</div><div class="line">             server.aof_child_pid == -1 &amp;&amp;</div><div class="line">             server.aof_rewrite_perc &amp;&amp;</div><div class="line">             server.aof_current_size &gt; server.aof_rewrite_min_size)</div><div class="line">         &#123;</div><div class="line">            // 上一次重写后的大小</div><div class="line">            long long base = server.aof_rewrite_base_size ?</div><div class="line">                            server.aof_rewrite_base_size : 1;</div><div class="line">            // AOF文件增长的百分比</div><div class="line">            long long growth = (server.aof_current_size*100/base) - 100;</div><div class="line">            // 大于设置的百分比100则进行AOF后台重写</div><div class="line">            if (growth &gt;= server.aof_rewrite_perc) &#123;</div><div class="line">                serverLog(LL_NOTICE,&quot;Starting automatic rewriting of AOF on %lld%% growth&quot;,growth);</div><div class="line">                rewriteAppendOnlyFileBackground();</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将AOF缓存冲洗到磁盘中</div><div class="line">    if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);</div><div class="line"></div><div class="line">    // 当AOF重写操作，同样将重写缓冲区的数据刷新到AOF文件中</div><div class="line">    run_with_period(1000) &#123;</div><div class="line">        if (server.aof_last_write_status == C_ERR)</div><div class="line">            flushAppendOnlyFile(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 释放被设置为异步释放的client</div><div class="line">    freeClientsInAsyncFreeQueue();</div><div class="line"></div><div class="line">    // 解除client的暂停状态</div><div class="line">    clientsArePaused(); /* Don&apos;t check return value, just use the side effect. */</div><div class="line"></div><div class="line">    // 周期性执行复制的任务</div><div class="line">    run_with_period(1000) replicationCron();</div><div class="line"></div><div class="line">    /* Run the Redis Cluster cron. */</div><div class="line">    // 周期性执行集群任务</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        if (server.cluster_enabled) clusterCron();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //周期性执行哨兵任务</div><div class="line">    run_with_period(100) &#123;</div><div class="line">        if (server.sentinel_mode) sentinelTimer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 清理过期的被缓存的sockets连接</div><div class="line">    run_with_period(1000) &#123;</div><div class="line">        migrateCloseTimedoutSockets();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果 BGSAVE 被提上过日程，那么进行BGSAVE操作，因为AOF重写操作在更新</div><div class="line">    // 注意：此代码必须在上面的replicationCron()调用之后，确保在重构此文件以保持此顺序时。 这是有用的，因为我们希望优先考虑RDB节省的复制</div><div class="line">    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</div><div class="line">        server.rdb_bgsave_scheduled &amp;&amp;</div><div class="line">        (server.unixtime-server.lastbgsave_try &gt; CONFIG_BGSAVE_RETRY_DELAY ||</div><div class="line">         server.lastbgsave_status == C_OK))</div><div class="line">    &#123;</div><div class="line">        // 更新执行BGSAVE，成功则清除rdb_bgsave_scheduled标志</div><div class="line">        if (rdbSaveBackground(server.rdb_filename) == C_OK)</div><div class="line">            server.rdb_bgsave_scheduled = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 周期loop计数器加1</div><div class="line">    server.cronloops++;</div><div class="line">    // 返回周期，默认为100ms</div><div class="line">    return 1000/server.hz;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也是大致总结列出部分：</p>
<ul>
<li>主动删除过期的键（也可以在读数据库时被动删除）</li>
<li>喂看门狗 watchdog</li>
<li>更新一些统计值</li>
<li>渐进式rehash</li>
<li>触发 BGSAVE / AOF 的重写操作，并处理子进程的中断</li>
<li>不同状态的client的超时</li>
<li>复制重连<br>等……<br>我们重点看两个函数，一个是关于客户端资源管理的clientsCron()，一个是关于数据库资源管理的databasesCron()。</li>
</ul>
<h3 id="3-1客户端资源管理"><a href="#3-1客户端资源管理" class="headerlink" title="3.1客户端资源管理"></a>3.1客户端资源管理</h3><p>服务器要定时检查client是否与服务器有交互，如果超过了设置的限制时间，则要释放client所占用的资源。具体的函数是clientsCronHandleTimeout()，它被clientsCron()函数所调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 检查超时，如果client中断超时返回非零值，函数获取当前时间作为参数因为他被一个循环中调用多次。所以调用gettimeofday()为每一次迭代都是昂贵的，而没有任何实际的效益</div><div class="line">// client被关闭则返回1，没有关闭返回0</div><div class="line">int clientsCronHandleTimeout(client *c, mstime_t now_ms) &#123;</div><div class="line">    // 当前时间，单位秒</div><div class="line">    time_t now = now_ms/1000;</div><div class="line"></div><div class="line">    // 当前时间 - client上一次和服务器交互的时间 如果大于 服务器中设置client超过的最大时间</div><div class="line">    // 不检查这四类client的超时时间：slaves从节点服务器、masters主节点服务器、BLPOP被阻塞的client、订阅状态的client</div><div class="line">    if (server.maxidletime &amp;&amp;</div><div class="line">        !(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp;    /* no timeout for slaves */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;   /* no timeout for masters */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_BLOCKED) &amp;&amp;  /* no timeout for BLPOP */</div><div class="line">        !(c-&gt;flags &amp; CLIENT_PUBSUB) &amp;&amp;   /* no timeout for Pub/Sub clients */</div><div class="line">        (now - c-&gt;lastinteraction &gt; server.maxidletime))</div><div class="line">    &#123;</div><div class="line">        serverLog(LL_VERBOSE,&quot;Closing idle client&quot;);</div><div class="line">        freeClient(c);</div><div class="line">        return 1;</div><div class="line">    // 如果client处于BLPOP被阻塞</div><div class="line">    &#125; else if (c-&gt;flags &amp; CLIENT_BLOCKED) &#123;</div><div class="line">        // 如果阻塞的client的超时时间已经到达</div><div class="line">        if (c-&gt;bpop.timeout != 0 &amp;&amp; c-&gt;bpop.timeout &lt; now_ms) &#123;</div><div class="line">            // 回复client一个空回复</div><div class="line">            replyToBlockedClientTimedOut(c);</div><div class="line">            // 接触client的阻塞状态</div><div class="line">            unblockClient(c);</div><div class="line">        // 如果服务器处于集群模式</div><div class="line">        &#125; else if (server.cluster_enabled) &#123;</div><div class="line">            // 重定向client的阻塞到其他的服务器</div><div class="line">            if (clusterRedirectBlockedClientIfNeeded(c))</div><div class="line">                // 解除阻塞</div><div class="line">                unblockClient(c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-数据库资源管理"><a href="#3-2-数据库资源管理" class="headerlink" title="3.2 数据库资源管理"></a>3.2 数据库资源管理</h3><p>服务器要定时检查数据库的输入缓冲区是否可以resize，以节省内存资源。而resize输入缓冲区的两个条件：</p>
<ul>
<li>输入缓冲区的大小大于32K以及超过缓冲区的峰值的2倍。</li>
<li>client超过时间大于2秒，且输入缓冲区的大小超过1k<br>实现的函数是clientsCronResizeQueryBuffer()，被databasesCron()函数所调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// resize客户端的输入缓冲区</div><div class="line">int clientsCronResizeQueryBuffer(client *c) &#123;</div><div class="line">    // 获取输入缓冲区的大小</div><div class="line">    size_t querybuf_size = sdsAllocSize(c-&gt;querybuf);</div><div class="line">    // 计算服务器对于client的空转时间，也就是client的超时时间</div><div class="line">    time_t idletime = server.unixtime - c-&gt;lastinteraction;</div><div class="line"></div><div class="line">    // resize输入缓冲区的两个条件：</div><div class="line">    //      1. 输入缓冲区的大小大于32K以及超过缓冲区的峰值的2倍</div><div class="line">    //      2. client超过时间大于2秒，且输入缓冲区的大小超过1k</div><div class="line">    if (((querybuf_size &gt; PROTO_MBULK_BIG_ARG) &amp;&amp;</div><div class="line">         (querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2) ||</div><div class="line">         (querybuf_size &gt; 1024 &amp;&amp; idletime &gt; 2))</div><div class="line">    &#123;</div><div class="line">        // 只有输入缓冲区的未使用大小超过1k，则会释放未使用的空间</div><div class="line">        if (sdsavail(c-&gt;querybuf) &gt; 1024) &#123;</div><div class="line">            c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 清空输入缓冲区的峰值</div><div class="line">    c-&gt;querybuf_peak = 0;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-maxmemory的策略"><a href="#4-maxmemory的策略" class="headerlink" title="4. maxmemory的策略"></a>4. maxmemory的策略</h2><p>Redis 服务器对内存使用会有一个server.maxmemory的限制，如果超过这个限制，就要通过删除一些键空间来释放一些内存，具体函数对应freeMemoryIfNeeded()。</p>
<p>释放内存时，可以指定不同的策略。策略保存在maxmemory_policy中，他可以指定以下的几个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define MAXMEMORY_VOLATILE_LRU 0</div><div class="line">#define MAXMEMORY_VOLATILE_TTL 1</div><div class="line">#define MAXMEMORY_VOLATILE_RANDOM 2</div><div class="line">#define MAXMEMORY_ALLKEYS_LRU 3</div><div class="line">#define MAXMEMORY_ALLKEYS_RANDOM 4</div><div class="line">#define MAXMEMORY_NO_EVICTION 5</div></pre></td></tr></table></figure></p>
<p>可以看出主要分为三种，</p>
<ul>
<li>LRU：优先删除最近最少使用的键。</li>
<li>TTL：优先删除生存时间最短的键。</li>
<li>RANDOM：随机删除。<br>而ALLKEYS和VOLATILE的不同之处就是要确定是从数据库的键值对字典还是过期键字典中删除。</li>
</ul>
<p>了解了以上这些，我们贴出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line">// 按需释放内存空间</div><div class="line">int freeMemoryIfNeeded(void) &#123;</div><div class="line">    size_t mem_used, mem_tofree, mem_freed;</div><div class="line">    int slaves = listLength(server.slaves);</div><div class="line">    mstime_t latency, eviction_latency;</div><div class="line"></div><div class="line">    // 计算出服务器总的内存使用量，但是有两部分要减去</div><div class="line">    /*</div><div class="line">        1、从节点的输出缓冲区</div><div class="line">        2、AOF缓冲区</div><div class="line">    */</div><div class="line">    mem_used = zmalloc_used_memory();</div><div class="line">    // 存在从节点</div><div class="line">    if (slaves) &#123;</div><div class="line">        listIter li;</div><div class="line">        listNode *ln;</div><div class="line"></div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        // 遍历从节点链表</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            client *slave = listNodeValue(ln);</div><div class="line">            // 获取当前从节点的输出缓冲区的大小，不包含静态的固定回复缓冲区，因为他总被分配</div><div class="line">            unsigned long obuf_bytes = getClientOutputBufferMemoryUsage(slave);</div><div class="line">            // 减去当前从节点的输出缓冲区的大小</div><div class="line">            if (obuf_bytes &gt; mem_used)</div><div class="line">                mem_used = 0;</div><div class="line">            else</div><div class="line">                mem_used -= obuf_bytes;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 如果开启了AOF操作</div><div class="line">    if (server.aof_state != AOF_OFF) &#123;</div><div class="line">        // 减去AOF缓冲区的大小</div><div class="line">        mem_used -= sdslen(server.aof_buf);</div><div class="line">        // 减去AOF重写缓冲区的大小</div><div class="line">        mem_used -= aofRewriteBufferSize();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有超过服务器设置的最大内存限制，则返回C_OK</div><div class="line">    if (mem_used &lt;= server.maxmemory) return C_OK;</div><div class="line">    // 如果内存回收策略为不回收，则返回C_ERR</div><div class="line">    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</div><div class="line">        return C_ERR; /* We need to free memory, but policy forbids. */</div><div class="line"></div><div class="line">    // 计算需要回收的大小</div><div class="line">    mem_tofree = mem_used - server.maxmemory;</div><div class="line">    // 已回收的大小</div><div class="line">    mem_freed = 0;</div><div class="line">    // 设置回收延迟检测开始的时间</div><div class="line">    latencyStartMonitor(latency);</div><div class="line">    // 循环回收，直到到达需要回收大小</div><div class="line">    while (mem_freed &lt; mem_tofree) &#123;</div><div class="line">        int j, k, keys_freed = 0;</div><div class="line"></div><div class="line">        // 遍历所有的数据库</div><div class="line">        for (j = 0; j &lt; server.dbnum; j++) &#123;</div><div class="line">            long bestval = 0; /* just to prevent warning */</div><div class="line">            sds bestkey = NULL;</div><div class="line">            dictEntry *de;</div><div class="line">            redisDb *db = server.db+j;</div><div class="line">            dict *dict;</div><div class="line">            // 如果回收策略有ALLKEYS_LRU或RANDOM，从键值对字典中选择回收</div><div class="line">            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM)</div><div class="line">            &#123;</div><div class="line">                // 则从键值对字典中选择回收的键。选择样品字典</div><div class="line">                dict = server.db[j].dict;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则从过期键字典中选择回收的键。选择样品字典</div><div class="line">                dict = server.db[j].expires;</div><div class="line">            &#125;</div><div class="line">            if (dictSize(dict) == 0) continue;  //跳过空字典</div><div class="line"></div><div class="line">            /* volatile-random and allkeys-random policy */</div><div class="line">            // 如果回收策略有 ALLKEYS_RANDOM 或 VOLATILE_RANDOM，则是随机挑选</div><div class="line">            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</div><div class="line">            &#123;</div><div class="line">                // 随机返回一个key</div><div class="line">                de = dictGetRandomKey(dict);</div><div class="line">                bestkey = dictGetKey(de);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* volatile-lru and allkeys-lru policy */</div><div class="line">            // 如果回收策略有 ALLKEYS_LRU 或 VOLATILE_LRU，则使用LRU策略</div><div class="line">            else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||</div><div class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_LRU)</div><div class="line">            &#123;</div><div class="line">                // 回收池</div><div class="line">                struct evictionPoolEntry *pool = db-&gt;eviction_pool;</div><div class="line"></div><div class="line">                while(bestkey == NULL) &#123;</div><div class="line">                    // evictionPoolPopulate()用于在每次我们想要过期一个键的时候，用几个节点填充evictionPool。 空闲时间小于当前key的之一的key被添加。 如果有free的节点，则始终添加key。 我们按升序插入key，所以空闲时间越短的键在左边，右边的空闲时间越长。</div><div class="line">                    // 从样品字典dict中随机选择样品</div><div class="line">                    evictionPoolPopulate(dict, db-&gt;dict, db-&gt;eviction_pool);</div><div class="line">                    // 从空转时间最长的开始遍历</div><div class="line">                    for (k = MAXMEMORY_EVICTION_POOL_SIZE-1; k &gt;= 0; k--) &#123;</div><div class="line">                        // 跳过空位置</div><div class="line">                        if (pool[k].key == NULL) continue;</div><div class="line">                        // 从样品字典dict中查找当前key</div><div class="line">                        de = dictFind(dict,pool[k].key);</div><div class="line"></div><div class="line">                        // 从收回池中删除</div><div class="line">                        sdsfree(pool[k].key);</div><div class="line">                        // 释放位置</div><div class="line">                        memmove(pool+k,pool+k+1,</div><div class="line">                            sizeof(pool[0])*(MAXMEMORY_EVICTION_POOL_SIZE-k-1));</div><div class="line">                        // 重置key和空转时间</div><div class="line">                        pool[MAXMEMORY_EVICTION_POOL_SIZE-1].key = NULL;</div><div class="line">                        pool[MAXMEMORY_EVICTION_POOL_SIZE-1].idle = 0;</div><div class="line"></div><div class="line">                        // 如果从样品字典中可以找到，则保存键</div><div class="line">                        if (de) &#123;</div><div class="line">                            bestkey = dictGetKey(de);</div><div class="line">                            break;</div><div class="line">                        // 没找到，则继续找下一个样品空间所保存的键</div><div class="line">                        &#125; else &#123;</div><div class="line">                            /* Ghost... */</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // 如果当前选出的所有的样品都没找到，则重新选择一批样品，知道找到一个可以释放的键</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* volatile-ttl */</div><div class="line">            // 如果回收策略有 VOLATILE_TTL，则选择生存时间最短的键</div><div class="line">            else if (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</div><div class="line">                // 抽样个数为maxmemory_samples个</div><div class="line">                for (k = 0; k &lt; server.maxmemory_samples; k++) &#123;</div><div class="line">                    sds thiskey;</div><div class="line">                    long thisval;</div><div class="line"></div><div class="line">                    // 返回一个键，获取他的生存时间</div><div class="line">                    de = dictGetRandomKey(dict);</div><div class="line">                    thiskey = dictGetKey(de);</div><div class="line">                    thisval = (long) dictGetVal(de);</div><div class="line"></div><div class="line">                    // 如果当前键的生存时间更短，则保存</div><div class="line">                    if (bestkey == NULL || thisval &lt; bestval) &#123;</div><div class="line">                        bestkey = thiskey;</div><div class="line">                        bestval = thisval;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Finally remove the selected key. */</div><div class="line">            // 删除所有被选择的键</div><div class="line">            if (bestkey) &#123;</div><div class="line">                long long delta;</div><div class="line"></div><div class="line">                robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</div><div class="line">                // 当一个键在主节点中过期时，主节点会发送del命令给从节点和AOF文件</div><div class="line">                propagateExpire(db,keyobj);</div><div class="line">                // 单独计算dbDelete()所释放的空间大小， 在AOF和复制链接中传播DEL的内存实际上大于我们释放的key的内存</div><div class="line">                // 但是无法解释，窦泽不会退出循环</div><div class="line">                // AOF和输出缓冲区的内存最终被释放，所以我们只关心键空间使用的内存</div><div class="line">                delta = (long long) zmalloc_used_memory();</div><div class="line">                // 设置删除key对象的开始时间</div><div class="line">                latencyStartMonitor(eviction_latency);</div><div class="line">                dbDelete(db,keyobj);</div><div class="line">                // 保存删除key对象时间</div><div class="line">                latencyEndMonitor(eviction_latency);</div><div class="line">                // 添加到延迟诊断字典中</div><div class="line">                latencyAddSampleIfNeeded(&quot;eviction-del&quot;,eviction_latency);</div><div class="line">                // 删除嵌套的延迟事件</div><div class="line">                latencyRemoveNestedEvent(latency,eviction_latency);</div><div class="line">                // 计算删除这个键的大小</div><div class="line">                delta -= (long long) zmalloc_used_memory();</div><div class="line">                // 更新内存释放量</div><div class="line">                mem_freed += delta;</div><div class="line">                // 服务器总的回收键的个数计数器加1</div><div class="line">                server.stat_evictedkeys++;</div><div class="line">                // 事件通知</div><div class="line">                notifyKeyspaceEvent(NOTIFY_EVICTED, &quot;evicted&quot;,</div><div class="line">                    keyobj, db-&gt;id);</div><div class="line">                // 释放键对象</div><div class="line">                decrRefCount(keyobj);</div><div class="line">                // 释放键的个数加1</div><div class="line">                keys_freed++;</div><div class="line"></div><div class="line">                // 如果有从节点，则刷新所有的输出缓冲区数据</div><div class="line">                if (slaves) flushSlavesOutputBuffers();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 如果所有数据库都没有释放键，返回C_ERR</div><div class="line">        if (!keys_freed) &#123;</div><div class="line">            latencyEndMonitor(latency);</div><div class="line">            latencyAddSampleIfNeeded(&quot;eviction-cycle&quot;,latency);</div><div class="line">            return C_ERR; /* nothing to free... */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 计算回收延迟的时间</div><div class="line">    latencyEndMonitor(latency);</div><div class="line">    latencyAddSampleIfNeeded(&quot;eviction-cycle&quot;,latency);</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-Redis服务器的main函数"><a href="#5-Redis服务器的main函数" class="headerlink" title="5. Redis服务器的main函数"></a>5. Redis服务器的main函数</h2><p>Redis 服务器的main()主要执行了一下操作：</p>
<ul>
<li>初始化服务器状态</li>
<li>载入服务器的配置</li>
<li>初始化服务器数据结构</li>
<li>载入持久化文件还原数据库状态</li>
<li>执行事件循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char **argv) &#123;</div><div class="line">    struct timeval tv;</div><div class="line">    int j;</div><div class="line"></div><div class="line">#ifdef INIT_SETPROCTITLE_REPLACEMENT</div><div class="line">    spt_init(argc, argv);</div><div class="line">#endif</div><div class="line">    // 本函数用来配置地域的信息，设置当前程序使用的本地化信息，LC_COLLATE 配置字符串比较</div><div class="line">    setlocale(LC_COLLATE,&quot;&quot;);</div><div class="line">    // 设置线程安全</div><div class="line">    zmalloc_enable_thread_safeness();</div><div class="line">    // 设置内存溢出的处理函数</div><div class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</div><div class="line">    // 初始化随机数发生器</div><div class="line">    srand(time(NULL)^getpid());</div><div class="line">    // 保存当前信息</div><div class="line">    gettimeofday(&amp;tv,NULL);</div><div class="line">    // 设置哈希函数的种子</div><div class="line">    dictSetHashFunctionSeed(tv.tv_sec^tv.tv_usec^getpid());</div><div class="line">    // 检查开启哨兵模式的两种方式</div><div class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</div><div class="line">    // 初始化服务器配置</div><div class="line">    initServerConfig();</div><div class="line"></div><div class="line">    // 设置可执行文件的绝对路径</div><div class="line">    server.executable = getAbsolutePath(argv[0]);</div><div class="line">    // 分配执行executable文件的参数列表的空间</div><div class="line">    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</div><div class="line">    server.exec_argv[argc] = NULL;</div><div class="line">    // 保存当前参数</div><div class="line">    for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</div><div class="line"></div><div class="line">    // 如果已开启哨兵模式</div><div class="line">    if (server.sentinel_mode) &#123;</div><div class="line">        // 初始化哨兵的配置</div><div class="line">        initSentinelConfig();</div><div class="line">        initSentinel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 检查是否执行&quot;redis-check-rdb&quot;检查程序</div><div class="line">    if (strstr(argv[0],&quot;redis-check-rdb&quot;) != NULL)</div><div class="line">        redis_check_rdb_main(argc,argv);    //该函数不会返回</div><div class="line"></div><div class="line">    // 解析参数</div><div class="line">    if (argc &gt;= 2) &#123;</div><div class="line">        j = 1; /* First option to parse in argv[] */</div><div class="line">        sds options = sdsempty();</div><div class="line">        char *configfile = NULL;</div><div class="line"></div><div class="line">        /* Handle special options --help and --version */</div><div class="line">        // 指定了打印版本信息，然后退出</div><div class="line">        if (strcmp(argv[1], &quot;-v&quot;) == 0 ||</div><div class="line">            strcmp(argv[1], &quot;--version&quot;) == 0) version();</div><div class="line">        // 执行帮助信息，然后退出</div><div class="line">        if (strcmp(argv[1], &quot;--help&quot;) == 0 ||</div><div class="line">            strcmp(argv[1], &quot;-h&quot;) == 0) usage();</div><div class="line">        // 执行内存测试程序</div><div class="line">        if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) &#123;</div><div class="line">            if (argc == 3) &#123;</div><div class="line">                memtest(atoi(argv[2]),50);</div><div class="line">                exit(0);</div><div class="line">            &#125; else &#123;</div><div class="line">                fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);</div><div class="line">                fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);</div><div class="line">                exit(1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* First argument is the config file name? */</div><div class="line">        // 如果第1个参数不是&apos;-&apos;，那么是配置文件</div><div class="line">        if (argv[j][0] != &apos;-&apos; || argv[j][1] != &apos;-&apos;) &#123;</div><div class="line">            configfile = argv[j];</div><div class="line">            // 设置配置文件的绝对路径</div><div class="line">            server.configfile = getAbsolutePath(configfile);</div><div class="line">            /* Replace the config file in server.exec_argv with</div><div class="line">             * its absoulte path. */</div><div class="line">            zfree(server.exec_argv[j]);</div><div class="line">            // 设置可执行的参数列表</div><div class="line">            server.exec_argv[j] = zstrdup(server.configfile);</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 解析指定的对象</div><div class="line">        while(j != argc) &#123;</div><div class="line">            // 如果是以&apos;-&apos;开头</div><div class="line">            if (argv[j][0] == &apos;-&apos; &amp;&amp; argv[j][1] == &apos;-&apos;) &#123;</div><div class="line">                /* Option name */</div><div class="line">                // 跳过&quot;--check-rdb&quot;</div><div class="line">                if (!strcmp(argv[j], &quot;--check-rdb&quot;)) &#123;</div><div class="line">                    /* Argument has no options, need to skip for parsing. */</div><div class="line">                    j++;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                // 每个选项之间用&apos;\n&apos;隔开</div><div class="line">                if (sdslen(options)) options = sdscat(options,&quot;\n&quot;);</div><div class="line">                // 将选项追加在sds中</div><div class="line">                options = sdscat(options,argv[j]+2);</div><div class="line">                // 选项和参数用 &quot; &quot;隔开</div><div class="line">                options = sdscat(options,&quot; &quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                /* Option argument */</div><div class="line">                // 追加选项参数</div><div class="line">                options = sdscatrepr(options,argv[j],strlen(argv[j]));</div><div class="line">                options = sdscat(options,&quot; &quot;);</div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        // 如果开启哨兵模式，哨兵模式配置文件不正确</div><div class="line">        if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == &apos;-&apos;) &#123;</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Sentinel config from STDIN not allowed.&quot;);</div><div class="line">            serverLog(LL_WARNING,</div><div class="line">                &quot;Sentinel needs config file on disk to save state.  Exiting...&quot;);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        // 重置save命令的参数</div><div class="line">        resetServerSaveParams();</div><div class="line">        // 载入配置文件</div><div class="line">        loadServerConfig(configfile,options);</div><div class="line">        sdsfree(options);</div><div class="line">    &#125; else &#123;</div><div class="line">        serverLog(LL_WARNING, &quot;Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf&quot;, argv[0], server.sentinel_mode ? &quot;sentinel&quot; : &quot;redis&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 是否被监视</div><div class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</div><div class="line">    // 是否以守护进程的方式运行</div><div class="line">    int background = server.daemonize &amp;&amp; !server.supervised;</div><div class="line">    if (background) daemonize();</div><div class="line"></div><div class="line">    // 初始化服务器</div><div class="line">    initServer();</div><div class="line">    // 创建保存pid的文件</div><div class="line">    if (background || server.pidfile) createPidFile();</div><div class="line">    // 为服务器进程设置标题</div><div class="line">    redisSetProcTitle(argv[0]);</div><div class="line">    // 打印Redis的logo</div><div class="line">    redisAsciiArt();</div><div class="line">    // 检查backlog队列</div><div class="line">    checkTcpBacklogSettings();</div><div class="line"></div><div class="line">    // 如果不是哨兵模式</div><div class="line">    if (!server.sentinel_mode) &#123;</div><div class="line">        /* Things not needed when running in Sentinel mode. */</div><div class="line">        serverLog(LL_WARNING,&quot;Server started, Redis version &quot; REDIS_VERSION);</div><div class="line">    #ifdef __linux__</div><div class="line">        // 打印内存警告</div><div class="line">        linuxMemoryWarnings();</div><div class="line">    #endif</div><div class="line">        // 从AOF文件或RDB文件载入数据</div><div class="line">        loadDataFromDisk();</div><div class="line">        // 如果开启了集群模式</div><div class="line">        if (server.cluster_enabled) &#123;</div><div class="line">            // 集群模式下验证载入的数据</div><div class="line">            if (verifyClusterConfigWithData() == C_ERR) &#123;</div><div class="line">                serverLog(LL_WARNING,</div><div class="line">                    &quot;You can&apos;t have keys in a DB different than DB 0 when in &quot;</div><div class="line">                    &quot;Cluster mode. Exiting.&quot;);</div><div class="line">                exit(1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 打印端口号</div><div class="line">        if (server.ipfd_count &gt; 0)</div><div class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections on port %d&quot;, server.port);</div><div class="line">        // 打印本地套接字fd</div><div class="line">        if (server.sofd &gt; 0)</div><div class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections at %s&quot;, server.unixsocket);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 开启哨兵模式，哨兵模式和集群模式只能开启一种</div><div class="line">        sentinelIsRunning();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Warning the user about suspicious maxmemory setting. */</div><div class="line">    // 最大内存限制是否配置正确</div><div class="line">    if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123;</div><div class="line">        serverLog(LL_WARNING,&quot;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&quot;, server.maxmemory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 进入事件循环之前执行beforeSleep()函数</div><div class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</div><div class="line">    // 运行事件循环，一直到服务器关闭</div><div class="line">    aeMain(server.el);</div><div class="line">    // 服务器关闭，删除事件循环</div><div class="line">    aeDeleteEventLoop(server.el);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（八）--- redis对象(redisObject)]]></title>
      <url>http://hlei.io/2018/02/10/redis-analysis-redisobject/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>redis中基于双端链表、简单动态字符串(sds)、字典、跳跃表、整数集合、压缩列表、快速列表等等数据结构实现了一个对象系统，并且实现了5种不同的对象，每种对象都使用了至少一种前面的数据结构，优化对象在不同场合下的使用效率。</p>
<h2 id="2-对象的系统的实现"><a href="#2-对象的系统的实现" class="headerlink" title="2. 对象的系统的实现"></a>2. 对象的系统的实现</h2><h3 id="2-1-对象的结构"><a href="#2-1-对象的结构" class="headerlink" title="2.1 对象的结构"></a>2.1 对象的结构</h3><p>对象结构robj功能：</p>
<ul>
<li>为5种不同的对象类型提供同一的表示形式。</li>
<li>为不同的对象适用于不同的场景，支持同一种对象类型采用多种的数据结构方式。</li>
<li>支持引用计数，实现对象共享机制。</li>
<li>记录对象的访问时间，便于删除对象。</li>
</ul>
<p>对象结构定义在redis 3.2版本的server.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#define LRU_BITS 24</div><div class="line">#define LRU_CLOCK_MAX ((1&lt;&lt;LRU_BITS)-1) /* Max value of obj-&gt;lru */</div><div class="line">#define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */</div><div class="line"></div><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，占4bits，共5种类型</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，占4bits，共10种类型</div><div class="line">    unsigned encoding:4;</div><div class="line"></div><div class="line">    //least recently used</div><div class="line">    //实用LRU算法计算相对server.lruclock的LRU时间</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line"></div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line"></div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div><div class="line"></div><div class="line">//type的占5种类型：</div><div class="line">/* Object types */</div><div class="line">#define OBJ_STRING 0    //字符串对象</div><div class="line">#define OBJ_LIST 1      //列表对象</div><div class="line">#define OBJ_SET 2       //集合对象</div><div class="line">#define OBJ_ZSET 3      //有序集合对象</div><div class="line">#define OBJ_HASH 4      //哈希对象</div><div class="line"></div><div class="line">/* Objects encoding. Some kind of objects like Strings and Hashes can be</div><div class="line"> * internally represented in multiple ways. The &apos;encoding&apos; field of the object</div><div class="line"> * is set to one of this fields for this object. */</div><div class="line">// encoding 的10种类型</div><div class="line">#define OBJ_ENCODING_RAW 0     /* Raw representation */     //原始表示方式，字符串对象是简单动态字符串</div><div class="line">#define OBJ_ENCODING_INT 1     /* Encoded as integer */         //long类型的整数</div><div class="line">#define OBJ_ENCODING_HT 2      /* Encoded as hash table */      //字典</div><div class="line">#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */          //不在使用</div><div class="line">#define OBJ_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */  //双端链表,不在使用</div><div class="line">#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */         //压缩列表</div><div class="line">#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */          //整数集合</div><div class="line">#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */      //跳跃表和字典</div><div class="line">#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */   //embstr编码的简单动态字符串</div><div class="line">#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */   //由压缩列表组成</div></pre></td></tr></table></figure></p>
<h3 id="2-2-字符串对象的底层实现类型"><a href="#2-2-字符串对象的底层实现类型" class="headerlink" title="2.2 字符串对象的底层实现类型"></a>2.2 字符串对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串实现的字符串对象</td>
</tr>
</tbody>
</table>
<h3 id="2-3-列表对象的底层实现类型"><a href="#2-3-列表对象的底层实现类型" class="headerlink" title="2.3 列表对象的底层实现类型"></a>2.3 列表对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>快速列表实现的列表对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的列表对象</td>
</tr>
</tbody>
</table>
<h3 id="2-4-集合对象的底层实现类型"><a href="#2-4-集合对象的底层实现类型" class="headerlink" title="2.4 集合对象的底层实现类型"></a>2.4 集合对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典实现的集合对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合实现的集合对象</td>
</tr>
</tbody>
</table>
<h3 id="2-5-哈希对象的底层实现类型"><a href="#2-5-哈希对象的底层实现类型" class="headerlink" title="2.5 哈希对象的底层实现类型"></a>2.5 哈希对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的哈希对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典实现的哈希对象</td>
</tr>
</tbody>
</table>
<h3 id="2-6-有序集合对象的底层实现类型"><a href="#2-6-有序集合对象的底层实现类型" class="headerlink" title="2.6 有序集合对象的底层实现类型"></a>2.6 有序集合对象的底层实现类型</h3><table>
<thead>
<tr>
<th>编码—encoding</th>
<th>对象—ptr</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳跃表和字典实现的有序集合对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的有序集合对象</td>
</tr>
</tbody>
</table>
<h2 id="3-对象系统的重要操作"><a href="#3-对象系统的重要操作" class="headerlink" title="3. 对象系统的重要操作"></a>3. 对象系统的重要操作</h2><h3 id="3-1创建一个字符串对象"><a href="#3-1创建一个字符串对象" class="headerlink" title="3.1创建一个字符串对象"></a>3.1创建一个字符串对象</h3><ul>
<li><p>编码为OBJ_ENCODING_RAW</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">robj *createObject(int type, void *ptr) &#123;   //创建一个对象</div><div class="line">    robj *o = zmalloc(sizeof(*o));          //分配空间</div><div class="line">    o-&gt;type = type;                         //设置对象类型</div><div class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;         //设置编码方式为OBJ_ENCODING_RAW</div><div class="line">    o-&gt;ptr = ptr;                           //设置</div><div class="line">    o-&gt;refcount = 1;                        //引用计数为1</div><div class="line"></div><div class="line">    /* Set the LRU to the current lruclock (minutes resolution). */</div><div class="line">    o-&gt;lru = LRU_CLOCK();                   //计算设置当前LRU时间</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编码为OBJ_ENCODING_EMBSTR</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is</div><div class="line"> * an object where the sds string is actually an unmodifiable string</div><div class="line"> * allocated in the same chunk as the object itself. */</div><div class="line">//创建一个embstr编码的字符串对象</div><div class="line">robj *createEmbeddedStringObject(const char *ptr, size_t len) &#123;</div><div class="line">    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);   //分配空间</div><div class="line">    struct sdshdr8 *sh = (void*)(o+1);  //o+1刚好就是struct sdshdr8的地址</div><div class="line"></div><div class="line">    o-&gt;type = OBJ_STRING;               //类型为字符串对象</div><div class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;  //设置编码类型OBJ_ENCODING_EMBSTR</div><div class="line">    o-&gt;ptr = sh+1;                      //指向分配的sds对象，分配的len+1的空间首地址</div><div class="line">    o-&gt;refcount = 1;                    //设置引用计数</div><div class="line">    o-&gt;lru = LRU_CLOCK();               //计算设置当前LRU时间</div><div class="line"></div><div class="line">    sh-&gt;len = len;                      //设置字符串长度</div><div class="line">    sh-&gt;alloc = len;                    //设置最大容量</div><div class="line">    sh-&gt;flags = SDS_TYPE_8;             //设置sds的类型</div><div class="line">    if (ptr) &#123;                          //如果传了字符串参数</div><div class="line">        memcpy(sh-&gt;buf,ptr,len);        //将传进来的ptr保存到对象中</div><div class="line">        sh-&gt;buf[len] = &apos;\0&apos;;            //结束符标志</div><div class="line">    &#125; else &#123;</div><div class="line">        memset(sh-&gt;buf,0,len+1);        //否则将对象的空间初始化为0</div><div class="line">    &#125;</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>两种字符串对象编码方式的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* Create a string object with EMBSTR encoding if it is smaller than</div><div class="line"> * REIDS_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is</div><div class="line"> * used.</div><div class="line"> *</div><div class="line"> * The current limit of 39 is chosen so that the biggest string object</div><div class="line"> * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */</div><div class="line"></div><div class="line">//sdshdr8的大小为3个字节，加上1个结束符共4个字节</div><div class="line">//redisObject的大小为16个字节</div><div class="line">//redis使用jemalloc内存分配器，且jemalloc会分配8，16，32，64等字节的内存</div><div class="line">//一个embstr固定的大小为16+3+1 = 20个字节，因此一个最大的embstr字符串为64-20 = 44字节</div><div class="line">#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</div><div class="line"></div><div class="line">// 创建字符串对象，根据长度使用不同的编码类型</div><div class="line">// createRawStringObject和createEmbeddedStringObject的区别是：</div><div class="line">// createRawStringObject是当字符串长度大于44字节时，robj结构和sdshdr结构在内存上是分开的</div><div class="line">// createEmbeddedStringObject是当字符串长度小于等于44字节时，robj结构和sdshdr结构在内存上是连续的</div><div class="line">robj *createStringObject(const char *ptr, size_t len) &#123;</div><div class="line">    if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</div><div class="line">        return createEmbeddedStringObject(ptr,len);</div><div class="line">    else</div><div class="line">        return createRawStringObject(ptr,len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-字符串对象编码的优化"><a href="#3-2-字符串对象编码的优化" class="headerlink" title="3.2 字符串对象编码的优化"></a>3.2 字符串对象编码的优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">/* Try to encode a string object in order to save space */</div><div class="line">//尝试优化字符串对象的编码方式以节约空间</div><div class="line">robj *tryObjectEncoding(robj *o) &#123;</div><div class="line">    long value;</div><div class="line">    sds s = o-&gt;ptr;</div><div class="line">    size_t len;</div><div class="line"></div><div class="line">    /* Make sure this is a string object, the only type we encode</div><div class="line">     * in this function. Other types use encoded memory efficient</div><div class="line">     * representations but are handled by the commands implementing</div><div class="line">     * the type. */</div><div class="line">    serverAssertWithInfo(NULL,o,o-&gt;type == OBJ_STRING);</div><div class="line"></div><div class="line">    /* We try some specialized encoding only for objects that are</div><div class="line">     * RAW or EMBSTR encoded, in other words objects that are still</div><div class="line">     * in represented by an actually array of chars. */</div><div class="line">    //如果字符串对象的编码类型为RAW或EMBSTR时，才对其重新编码</div><div class="line">    if (!sdsEncodedObject(o)) return o;</div><div class="line"></div><div class="line">    /* It&apos;s not safe to encode shared objects: shared objects can be shared</div><div class="line">     * everywhere in the &quot;object space&quot; of Redis and may end in places where</div><div class="line">     * they are not handled. We handle them only as values in the keyspace. */</div><div class="line">    //如果refcount大于1，则说明对象的ptr指向的值是共享的，不对共享对象进行编码</div><div class="line">     if (o-&gt;refcount &gt; 1) return o;</div><div class="line"></div><div class="line">    /* Check if we can represent this string as a long integer.</div><div class="line">     * Note that we are sure that a string larger than 20 chars is not</div><div class="line">     * representable as a 32 nor 64 bit integer. */</div><div class="line">    len = sdslen(s);            //获得字符串s的长度</div><div class="line"></div><div class="line">    //如果len小于等于20，表示符合long long可以表示的范围，且可以转换为long类型的字符串进行编码</div><div class="line">    if (len &lt;= 20 &amp;&amp; string2l(s,len,&amp;value)) &#123;</div><div class="line">        /* This object is encodable as a long. Try to use a shared object.</div><div class="line">         * Note that we avoid using shared integers when maxmemory is used</div><div class="line">         * because every object needs to have a private LRU field for the LRU</div><div class="line">         * algorithm to work well. */</div><div class="line">        if ((server.maxmemory == 0 ||</div><div class="line">             (server.maxmemory_policy != MAXMEMORY_VOLATILE_LRU &amp;&amp;</div><div class="line">              server.maxmemory_policy != MAXMEMORY_ALLKEYS_LRU)) &amp;&amp;</div><div class="line">            value &gt;= 0 &amp;&amp;</div><div class="line">            value &lt; OBJ_SHARED_INTEGERS)    //如果value处于共享整数的范围内</div><div class="line">        &#123;</div><div class="line">            decrRefCount(o);                //原对象的引用计数减1，释放对象</div><div class="line">            incrRefCount(shared.integers[value]); //增加共享对象的引用计数</div><div class="line">            return shared.integers[value];      //返回一个编码为整数的字符串对象</div><div class="line">        &#125; else &#123;        //如果不处于共享整数的范围</div><div class="line">            if (o-&gt;encoding == OBJ_ENCODING_RAW) sdsfree(o-&gt;ptr);   //释放编码为OBJ_ENCODING_RAW的对象</div><div class="line">            o-&gt;encoding = OBJ_ENCODING_INT;     //转换为OBJ_ENCODING_INT编码</div><div class="line">            o-&gt;ptr = (void*) value;             //指针ptr指向value对象</div><div class="line">            return o;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If the string is small and is still RAW encoded,</div><div class="line">     * try the EMBSTR encoding which is more efficient.</div><div class="line">     * In this representation the object and the SDS string are allocated</div><div class="line">     * in the same chunk of memory to save space and cache misses. */</div><div class="line">    //如果len小于44，44是最大的编码为EMBSTR类型的字符串对象长度</div><div class="line">    if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123;</div><div class="line">        robj *emb;</div><div class="line"></div><div class="line">        if (o-&gt;encoding == OBJ_ENCODING_EMBSTR) return o;   //将RAW对象转换为OBJ_ENCODING_EMBSTR编码类型</div><div class="line">        emb = createEmbeddedStringObject(s,sdslen(s)); //创建一个编码类型为OBJ_ENCODING_EMBSTR的字符串对象</div><div class="line">        decrRefCount(o);    //释放之前的对象</div><div class="line">        return emb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* We can&apos;t encode the object...</div><div class="line">     *</div><div class="line">     * Do the last try, and at least optimize the SDS string inside</div><div class="line">     * the string object to require little space, in case there</div><div class="line">     * is more than 10% of free space at the end of the SDS string.</div><div class="line">     *</div><div class="line">     * We do that only for relatively large strings as this branch</div><div class="line">     * is only entered if the length of the string is greater than</div><div class="line">     * OBJ_ENCODING_EMBSTR_SIZE_LIMIT. */</div><div class="line">    //无法进行编码，但是如果s的未使用的空间大于使用空间的10分之1</div><div class="line">    if (o-&gt;encoding == OBJ_ENCODING_RAW &amp;&amp;</div><div class="line">        sdsavail(s) &gt; len/10)</div><div class="line">    &#123;</div><div class="line">        o-&gt;ptr = sdsRemoveFreeSpace(o-&gt;ptr);    //释放所有的未使用空间</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Return the original object. */</div><div class="line">    return o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-引用计数管理对象"><a href="#3-3-引用计数管理对象" class="headerlink" title="3.3 引用计数管理对象"></a>3.3 引用计数管理对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//引用计数加1</div><div class="line">void incrRefCount(robj *o) &#123;</div><div class="line">    o-&gt;refcount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//引用计数减1</div><div class="line">void decrRefCount(robj *o) &#123;</div><div class="line">    if (o-&gt;refcount &lt;= 0) serverPanic(&quot;decrRefCount against refcount &lt;= 0&quot;);</div><div class="line"></div><div class="line">    //当引用对象等于1时，在操作引用计数减1，直接释放对象的ptr和对象空间</div><div class="line">    if (o-&gt;refcount == 1) &#123;</div><div class="line">        switch(o-&gt;type) &#123;</div><div class="line">        case OBJ_STRING: freeStringObject(o); break;</div><div class="line">        case OBJ_LIST: freeListObject(o); break;</div><div class="line">        case OBJ_SET: freeSetObject(o); break;</div><div class="line">        case OBJ_ZSET: freeZsetObject(o); break;</div><div class="line">        case OBJ_HASH: freeHashObject(o); break;</div><div class="line">        default: serverPanic(&quot;Unknown object type&quot;); break;</div><div class="line">        &#125;</div><div class="line">        zfree(o);</div><div class="line">    &#125; else &#123;</div><div class="line">        o-&gt;refcount--;  //否则减1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-对象的复制，创建的对象非共享"><a href="#3-4-对象的复制，创建的对象非共享" class="headerlink" title="3.4 对象的复制，创建的对象非共享"></a>3.4 对象的复制，创建的对象非共享</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//返回 复制的o对象的副本的地址，且创建的对象非共享</div><div class="line">robj *dupStringObject(robj *o) &#123;</div><div class="line">    robj *d;</div><div class="line"></div><div class="line">    serverAssert(o-&gt;type == OBJ_STRING);    //一定是OBJ_STRING类型</div><div class="line"></div><div class="line">    switch(o-&gt;encoding) &#123;                   //根据不同的编码类型</div><div class="line">    case OBJ_ENCODING_RAW:</div><div class="line">        return createRawStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));        //创建的对象非共享</div><div class="line">    case OBJ_ENCODING_EMBSTR:</div><div class="line">        return createEmbeddedStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));   //创建的对象非共享</div><div class="line">    case OBJ_ENCODING_INT:                  //整数编码类型</div><div class="line">        d = createObject(OBJ_STRING, NULL); //即使是共享整数范围内的整数，创建的对象也是非共享的</div><div class="line">        d-&gt;encoding = OBJ_ENCODING_INT;</div><div class="line">        d-&gt;ptr = o-&gt;ptr;</div><div class="line">        return d;</div><div class="line">    default:</div><div class="line">        serverPanic(&quot;Wrong encoding.&quot;);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-5-对象的解码操作"><a href="#3-5-对象的解码操作" class="headerlink" title="3.5 对象的解码操作"></a>3.5 对象的解码操作</h3><p>将保存的整数值解码成字符串对象返回回来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/* Get a decoded version of an encoded object (returned as a new object).</div><div class="line"> * If the object is already raw-encoded just increment the ref count. */</div><div class="line">//将对象是整型的解码为字符串并返回，如果是字符串编码则直接返回输入对象，只需增加引用计数</div><div class="line">robj *getDecodedObject(robj *o) &#123;</div><div class="line">    robj *dec;</div><div class="line"></div><div class="line">    if (sdsEncodedObject(o)) &#123;  //如果是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR类型的对象</div><div class="line">        incrRefCount(o);        //增加引用计数，返回一个共享的对象</div><div class="line">        return o;</div><div class="line">    &#125;</div><div class="line">    if (o-&gt;type == OBJ_STRING &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT) &#123; //如果是整数对象</div><div class="line">        char buf[32];</div><div class="line"></div><div class="line">        ll2string(buf,32,(long)o-&gt;ptr); //将整数转换为字符串</div><div class="line">        dec = createStringObject(buf,strlen(buf));  //创建一个字符串对象</div><div class="line">        return dec;</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown encoding type&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（十九）--- Redis 事件处理实现]]></title>
      <url>http://hlei.io/2018/02/10/redis-analysis-eventhanding/</url>
      <content type="html"><![CDATA[<h2 id="1-Redis事件介绍"><a href="#1-Redis事件介绍" class="headerlink" title="1. Redis事件介绍"></a>1. Redis事件介绍</h2><p>Redis服务器是一个事件驱动程序。下面先来简单介绍什么是事件驱动。</p>
<p>所谓事件驱动，就是当你输入一条命令并且按下回车，然后消息被组装成Redis协议的格式发送给Redis服务器，这就会产生一个事件，Redis服务器会接收该命令，处理该命令和发送回复，而当你没有与服务器进行交互时，那么服务器就会处于阻塞等待状态，会让出CPU从而进入睡眠状态，当事件触发时，就会被操作系统唤醒。事件驱动使CPU更高效的利用。</p>
<p>事件驱动是一种概括和抽象，也可以称为I/O多路复用（I/O multiplexing），它的实现方式各个系统都不同，一会会说到Redis的方式。</p>
<p>在redis服务器中，处理了两类事件：</p>
<ul>
<li>文件事件（file event）：Redis服务器通过套接字于客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。</li>
<li>时间事件（time event）：Redis服务器的一些操作需要在给定的事件点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h2 id="2-事件的抽象"><a href="#2-事件的抽象" class="headerlink" title="2. 事件的抽象"></a>2. 事件的抽象</h2><p>Redis将这两个事件分别抽象成一个数据结构来管理。</p>
<h3 id="2-1-文件事件结构"><a href="#2-1-文件事件结构" class="headerlink" title="2.1 文件事件结构"></a>2.1 文件事件结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* File event structure */</div><div class="line">typedef struct aeFileEvent &#123;</div><div class="line">    // 文件时间类型：AE_NONE，AE_READABLE，AE_WRITABLE</div><div class="line">    int mask; /* one of AE_(READABLE|WRITABLE) */</div><div class="line">    // 可读处理函数</div><div class="line">    aeFileProc *rfileProc;</div><div class="line">    // 可写处理函数</div><div class="line">    aeFileProc *wfileProc;</div><div class="line">    // 客户端传入的数据</div><div class="line">    void *clientData;</div><div class="line">&#125; aeFileEvent;  //文件事件</div></pre></td></tr></table></figure>
<p>其中rfileProc和wfileProc成员分别为两个函数指针，他们的原型为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask)</div></pre></td></tr></table></figure></p>
<p>这个函数是回调函数，如果当前文件事件所指定的事件类型发生时，则会调用对应的回调函数处理该事件。函数指针与回调函数详解</p>
<p>当事件就绪时，我们需要知道文件事件的文件描述符还有事件类型才能锁定该事件，因此定义了aeFiredEvent结构统一管理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* A fired event */</div><div class="line">typedef struct aeFiredEvent &#123;</div><div class="line">    // 就绪事件的文件描述符</div><div class="line">    int fd;</div><div class="line">    // 就绪事件类型：AE_NONE，AE_READABLE，AE_WRITABLE</div><div class="line">    int mask;</div><div class="line">&#125; aeFiredEvent; //就绪事件</div></pre></td></tr></table></figure></p>
<h3 id="2-2-时间事件结构"><a href="#2-2-时间事件结构" class="headerlink" title="2.2 时间事件结构"></a>2.2 时间事件结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* Time event structure */</div><div class="line">typedef struct aeTimeEvent &#123;</div><div class="line">    // 时间事件的id</div><div class="line">    long long id; /* time event identifier. */</div><div class="line">    // 时间事件到达的时间的秒数</div><div class="line">    long when_sec; /* seconds */</div><div class="line">    // 时间事件到达的时间的毫秒数</div><div class="line">    long when_ms; /* milliseconds */</div><div class="line">    // 时间事件处理函数</div><div class="line">    aeTimeProc *timeProc;</div><div class="line">    // 时间事件终结函数</div><div class="line">    aeEventFinalizerProc *finalizerProc;</div><div class="line">    // 客户端传入的数据</div><div class="line">    void *clientData;</div><div class="line">    // 指向下一个时间事件</div><div class="line">    struct aeTimeEvent *next;</div><div class="line">&#125; aeTimeEvent;  //时间事件</div></pre></td></tr></table></figure>
<p>从这个结构中可以看出，时间事件表是一个链表，因为它有一个next指针域，指向下一个时间事件。</p>
<p>和文件事件一样，当时间事件所指定的事件发生时，也会调用对应的回调函数，结构成员timeProc和finalizerProc都是回调函数，函数原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);</div><div class="line">typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);</div></pre></td></tr></table></figure></p>
<p>虽然对文件事件和时间事件都做了抽象，Redis仍然需要对事件做整体抽象，于是定义了aeEventLoop结构。</p>
<h3 id="2-3-事件状态结构"><a href="#2-3-事件状态结构" class="headerlink" title="2.3 事件状态结构"></a>2.3 事件状态结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* State of an event based program */</div><div class="line">typedef struct aeEventLoop &#123;</div><div class="line">    // 当前已注册的最大的文件描述符</div><div class="line">    int maxfd;   /* highest file descriptor currently registered */</div><div class="line">    // 文件描述符监听集合的大小</div><div class="line">    int setsize; /* max number of file descriptors tracked */</div><div class="line">    // 下一个时间事件的ID</div><div class="line">    long long timeEventNextId;</div><div class="line">    // 最后一次执行事件的时间</div><div class="line">    time_t lastTime;     /* Used to detect system clock skew */</div><div class="line">    // 注册的文件事件表</div><div class="line">    aeFileEvent *events; /* Registered events */</div><div class="line">    // 已就绪的文件事件表</div><div class="line">    aeFiredEvent *fired; /* Fired events */</div><div class="line">    // 时间事件的头节点指针</div><div class="line">    aeTimeEvent *timeEventHead;</div><div class="line">    // 事件处理开关</div><div class="line">    int stop;</div><div class="line">    // 多路复用库的事件状态数据</div><div class="line">    void *apidata; /* This is used for polling API specific data */</div><div class="line">    // 执行处理事件之前的函数</div><div class="line">    aeBeforeSleepProc *beforesleep;</div><div class="line">&#125; aeEventLoop;  //事件轮询的状态结构</div></pre></td></tr></table></figure>
<p>aeEventLoop结构保存了一个void *类型的万能指针apidata，是用来保存轮询事件的状态的，也就是保存底层调用的多路复用库的事件状态，关于Redis的多路复用库的选择，Redis包装了常见的select epoll evport kqueue，他们在编译阶段，根据不同的系统选择性能最高的一个多路复用库作为Redis的多路复用程序的实现，而且所有库实现的接口名称都是相同的，因此Redis多路复用程序底层实现是可以互换的。具体选择库的源码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// IO复用的选择，性能依次下降，Linux支持 &quot;ae_epoll.c&quot; 和 &quot;ae_select.c&quot;</div><div class="line">#ifdef HAVE_EVPORT</div><div class="line">#include &quot;ae_evport.c&quot;</div><div class="line">#else</div><div class="line">    #ifdef HAVE_EPOLL</div><div class="line">    #include &quot;ae_epoll.c&quot;</div><div class="line">    #else</div><div class="line">        #ifdef HAVE_KQUEUE</div><div class="line">        #include &quot;ae_kqueue.c&quot;</div><div class="line">        #else</div><div class="line">        #include &quot;ae_select.c&quot;</div><div class="line">        #endif</div><div class="line">    #endif</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>也可以通过Redis客户端的命令来查看当前选择的多路复用库，INFO server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; INFO server</div><div class="line"># Server</div><div class="line">……</div><div class="line">multiplexing_api:epoll</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>那么，既然知道了多路复用库的选择，那么我们来查看一下apidata保存的epoll模型的事件状态结构：ae_epoll.c文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct aeApiState &#123;</div><div class="line">    // epoll事件的文件描述符</div><div class="line">    int epfd;</div><div class="line">    // 事件表</div><div class="line">    struct epoll_event *events;</div><div class="line">&#125; aeApiState;   //事件的状态</div></pre></td></tr></table></figure></p>
<p>epoll模型的struct epoll_event的结构中定义这自己的事件类型，例如EPOLLIN POLLOUT等等，但是Redis的文件事件结构aeFileEvent中也在mask中定义了自己的事件类型，例如：AE_READABLE AE_WRITABLE等，于是，就需要实现一个中间层将两者的事件类型相联系起来，这也就是之前提到的ae_epoll.c文件中实现的相同的API，我们列出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 创建一个epoll实例，保存到eventLoop中</div><div class="line">static int aeApiCreate(aeEventLoop *eventLoop)</div><div class="line">// 调整事件表的大小</div><div class="line">static int aeApiResize(aeEventLoop *eventLoop, int setsize)  </div><div class="line">// 释放epoll实例和事件表空间</div><div class="line">static void aeApiFree(aeEventLoop *eventLoop)</div><div class="line">// 在epfd标识的事件表上注册fd的事件</div><div class="line">static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask)</div><div class="line">// 在epfd标识的事件表上注删除fd的事件</div><div class="line">static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask)</div><div class="line">// 等待所监听文件描述符上有事件发生</div><div class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp)</div><div class="line">// 返回正在使用的IO多路复用库的名字</div><div class="line">static char *aeApiName(void)</div></pre></td></tr></table></figure></p>
<p>这些API都是调用相应的底层多路复用库来将Redis事件状态结构aeEventLoop所关联，就是将epoll的底层函数封装起来，Redis实现事件时，只需调用这些接口即可。我们查看两个重要的函数的源码，看看是如何实现的</p>
<ul>
<li><p>向Redis事件状态结构aeEventLoop的事件表event注册一个事件，对应的是epoll_ctl函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 在epfd标识的事件表上注册fd的事件</div><div class="line">static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) &#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    struct epoll_event ee = &#123;0&#125;; /* avoid valgrind warning */</div><div class="line">    /* If the fd was already monitored for some event, we need a MOD</div><div class="line">     * operation. Otherwise we need an ADD operation. */</div><div class="line">    // EPOLL_CTL_ADD，向epfd注册fd的上的event</div><div class="line">    // EPOLL_CTL_MOD，修改fd已注册的event</div><div class="line">    // #define AE_NONE 0           //未设置</div><div class="line">    // #define AE_READABLE 1       //事件可读</div><div class="line">    // #define AE_WRITABLE 2       //事件可写</div><div class="line">    // 判断fd事件的操作，如果没有设置事件，则进行关联mask类型事件，否则进行修改</div><div class="line">    int op = eventLoop-&gt;events[fd].mask == AE_NONE ?</div><div class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</div><div class="line"></div><div class="line">    // struct epoll_event &#123;</div><div class="line">    //      uint32_t     events;      /* Epoll events */</div><div class="line">    //      epoll_data_t data;        /* User data variable */</div><div class="line">    // &#125;;</div><div class="line">    ee.events = 0;</div><div class="line">    // 如果是修改事件，合并之前的事件类型</div><div class="line">    mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */</div><div class="line">    // 根据mask映射epoll的事件类型</div><div class="line">    if (mask &amp; AE_READABLE) ee.events |= EPOLLIN;   //读事件</div><div class="line">    if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;  //写事件</div><div class="line">    ee.data.fd = fd;    //设置事件所从属的目标文件描述符</div><div class="line">    // 将ee事件注册到epoll中</div><div class="line">    if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>等待所监听文件描述符上有事件发生，对应着底层epoll_wait函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 等待所监听文件描述符上有事件发生</div><div class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    int retval, numevents = 0;</div><div class="line"></div><div class="line">    // 监听事件表上是否有事件发生</div><div class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</div><div class="line">            tvp ? (tvp-&gt;tv_sec*1000 + tvp-&gt;tv_usec/1000) : -1);</div><div class="line">    // 至少有一个就绪的事件</div><div class="line">    if (retval &gt; 0) &#123;</div><div class="line">        int j;</div><div class="line"></div><div class="line">        numevents = retval;</div><div class="line">        // 遍历就绪的事件表，将其加入到eventLoop的就绪事件表中</div><div class="line">        for (j = 0; j &lt; numevents; j++) &#123;</div><div class="line">            int mask = 0;</div><div class="line">            struct epoll_event *e = state-&gt;events+j;</div><div class="line"></div><div class="line">            // 根据就绪的事件类型，设置mask</div><div class="line">            if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</div><div class="line">            if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</div><div class="line">            // 添加到就绪事件表中</div><div class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</div><div class="line">            eventLoop-&gt;fired[j].mask = mask;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 返回就绪的事件个数</div><div class="line">    return numevents;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-事件的源码实现"><a href="#3-事件的源码实现" class="headerlink" title="3. 事件的源码实现"></a>3. 事件的源码实现</h2><p>Redis事件的源码全部定义在ae.c文件中，我们从事件的主函数aeMain说起，一步一步深入剖析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 事件轮询的主函数</div><div class="line">void aeMain(aeEventLoop *eventLoop) &#123;</div><div class="line">    eventLoop-&gt;stop = 0;</div><div class="line">    // 一直处理事件</div><div class="line">    while (!eventLoop-&gt;stop) &#123;</div><div class="line">        // 执行处理事件之前的函数</div><div class="line">        if (eventLoop-&gt;beforesleep != NULL)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line">        //处理到时的时间事件和就绪的文件事件</div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个事件的主函数aeMain很清楚的可以看到，如果服务器一直处理事件，那么就是一个死循环，而一个最典型的事件驱动，就是一个死循环。调用处理事件的函数aeProcessEvents，他们参数是一个事件状态结构aeEventLoop和AE_ALL_EVENTS，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">// 处理到时的时间事件和就绪的文件事件</div><div class="line">// 函数返回执行的事件个数</div><div class="line">int aeProcessEvents(aeEventLoop *eventLoop, int flags)</div><div class="line">&#123;</div><div class="line">    int processed = 0, numevents;</div><div class="line"></div><div class="line">    /* Nothing to do? return ASAP */</div><div class="line">    // 如果什么事件都没有设置则直接返回</div><div class="line">    if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0;</div><div class="line"></div><div class="line">    /* Note that we want call select() even if there are no</div><div class="line">     * file events to process as long as we want to process time</div><div class="line">     * events, in order to sleep until the next time event is ready</div><div class="line">     * to fire. */</div><div class="line">    // 请注意，既然我们要处理时间事件，即使没有要处理的文件事件，我们仍要调用select（），以便在下一次事件准备启动之前进行休眠</div><div class="line"></div><div class="line">    // 当前还没有要处理的文件事件，或者设置了时间时间但是没有设置不阻塞标识</div><div class="line">    if (eventLoop-&gt;maxfd != -1 ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        int j;</div><div class="line">        aeTimeEvent *shortest = NULL;</div><div class="line">        struct timeval tv, *tvp;</div><div class="line"></div><div class="line">        // 如果设置了时间事件而没有设置不阻塞标识</div><div class="line">        if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            // 获取最近到时的时间事件</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        // 获取到了最早到时的时间事件</div><div class="line">        if (shortest) &#123;</div><div class="line">            long now_sec, now_ms;</div><div class="line">            // 获取当前时间</div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line"></div><div class="line">            /* How many milliseconds we need to wait for the next</div><div class="line">             * time event to fire? */</div><div class="line">            // 等待该时间事件到时所需要的时长</div><div class="line">            long long ms =</div><div class="line">                (shortest-&gt;when_sec - now_sec)*1000 +</div><div class="line">                shortest-&gt;when_ms - now_ms;</div><div class="line"></div><div class="line">            // 如果没到时</div><div class="line">            if (ms &gt; 0) &#123;</div><div class="line">                // 保存时长到tvp中</div><div class="line">                tvp-&gt;tv_sec = ms/1000;</div><div class="line">                tvp-&gt;tv_usec = (ms % 1000)*1000;</div><div class="line">            // 如果已经到时，则将tvp的时间设置为0</div><div class="line">            &#125; else &#123;</div><div class="line">                tvp-&gt;tv_sec = 0;</div><div class="line">                tvp-&gt;tv_usec = 0;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        // 没有获取到了最早到时的时间事件，时间事件链表为空</div><div class="line">        &#125; else &#123;</div><div class="line">            /* If we have to check for events but need to return</div><div class="line">             * ASAP because of AE_DONT_WAIT we need to set the timeout</div><div class="line">             * to zero */</div><div class="line">            // 如果设置了不阻塞标识</div><div class="line">            if (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                // 将tvp的时间设置为0，就不会阻塞</div><div class="line">                tv.tv_sec = tv.tv_usec = 0;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 阻塞到第一个时间事件的到来</div><div class="line">                /* Otherwise we can block */</div><div class="line">                tvp = NULL; /* wait forever */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 等待所监听文件描述符上有事件发生</div><div class="line">        // 如果tvp为NULL，则阻塞在此，否则等待tvp设置阻塞的时间，就会有时间事件到时</div><div class="line">        // 返回了就绪文件事件的个数</div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        // 遍历就绪文件事件表</div><div class="line">        for (j = 0; j &lt; numevents; j++) &#123;</div><div class="line">            // 获取就绪文件事件的地址</div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line">            // 获取就绪文件事件的类型，文件描述符</div><div class="line">            int mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            int fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            int rfired = 0;</div><div class="line"></div><div class="line">        /* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</div><div class="line">             * event removed an element that fired and we still didn&apos;t</div><div class="line">             * processed, so we check if the event is still valid. */</div><div class="line">            // 如果是文件可读事件发生</div><div class="line">            if (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                // 设置读事件标识 且 调用读事件方法处理读事件</div><div class="line">                rfired = 1;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            // 如果是文件可写事件发生</div><div class="line">            if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line">                // 读写事件的执行发法不同，则执行写事件，避免重复执行相同的方法</div><div class="line">                if (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            processed++;    //执行的事件次数加1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /* Check time events */</div><div class="line">    // 执行时间事件</div><div class="line">    if (flags &amp; AE_TIME_EVENTS)</div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    return processed; /* return the number of processed file/time events */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>刚才提到该函数的一个参数是AE_ALL_EVENTS，他的定义在ae.h中，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define AE_FILE_EVENTS 1                                //文件事件</div><div class="line">#define AE_TIME_EVENTS 2                                //时间事件</div><div class="line">#define AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)   //文件和时间事件</div><div class="line">#define AE_DONT_WAIT 4                                  //不阻塞等待标识</div></pre></td></tr></table></figure></p>
<p>很明显，flags是AE_FILE_EVENTS和AE_TIME_EVENTS或的结果，他们的含义如下：</p>
<ul>
<li>如果flags = 0，函数什么都不做，直接返回</li>
<li>如果flags设置了 AE_ALL_EVENTS ，则执行所有类型的事件</li>
<li>如果flags设置了 AE_FILE_EVENTS ，则执行文件事件</li>
<li>如果flags设置了 AE_TIME_EVENTS ，则执行时间事件</li>
<li>如果flags设置了 AE_DONT_WAIT ，那么函数处理完事件后直接返回，不阻塞等待<br>Redis服务器在没有被事件触发时，就会阻塞等待，因为没有设置AE_DONT_WAIT标识。但是他不会一直的死等待，等待文件事件的到来，因为他还要处理时间时间，因此，在调用aeApiPoll进行监听之前，先从时间事件表中获取一个最近到达的时间时间，根据要等待的时间构建一个struct timeval tv, *tvp结构的变量，这个变量保存着服务器阻塞等待文件事件的最长时间，一旦时间到达而没有触发文件事件，aeApiPoll函数就会停止阻塞，进而调用processTimeEvents处理时间事件，因为Redis服务器设定一个对自身资源和状态进行检查的周期性检查的时间事件，而该函数就是timeProc所指向的回调函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果在阻塞等待的最长时间之间，触发了文件事件，就会先执行文件事件，后执行时间事件，因此处理时间事件通常比预设的会晚一点。</p>
<p>而执行文件事件rfileProc和wfileProc也是调用了回调函数，Redis将文件事件的处理分为了好几种，用于处理不同的网络通信需求，下面列出回调函数的原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask)</div><div class="line">void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask)</div></pre></td></tr></table></figure></p>
<ul>
<li>acceptTcpHandler：用于accept client的connect。</li>
<li>acceptUnixHandler：用于acceptclient的本地connect。</li>
<li>sendReplyToClient：用于向client发送命令回复。</li>
<li>readQueryFromClient：用于读入client发送的请求。<br>接下来，我们查看获取最快达到的时间事件的函数aeSearchNearestTimer实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 寻找第一个快到时的时间事件</div><div class="line">// 这个操作是有用的知道有多少时间可以选择该事件设置为不用推迟任何事件的睡眠中。</div><div class="line">// 如果事件链表没有时间将返回NULL。</div><div class="line">static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)</div><div class="line">&#123;</div><div class="line">    // 时间事件头节点地址</div><div class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</div><div class="line">    aeTimeEvent *nearest = NULL;</div><div class="line"></div><div class="line">    // 遍历所有的时间事件</div><div class="line">    while(te) &#123;</div><div class="line">        // 寻找第一个快到时的时间事件，保存到nearest中</div><div class="line">        if (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</div><div class="line">                (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</div><div class="line">                 te-&gt;when_ms &lt; nearest-&gt;when_ms))</div><div class="line">            nearest = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    return nearest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数没什么，就是遍历链表，找到最小值。我们重点看执行时间事件的函数processTimeEvents实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">/* Process time events */</div><div class="line">// 执行时间事件</div><div class="line">static int processTimeEvents(aeEventLoop *eventLoop) &#123;</div><div class="line">    int processed = 0;</div><div class="line">    aeTimeEvent *te, *prev;</div><div class="line">    long long maxId;</div><div class="line">    time_t now = time(NULL);</div><div class="line"></div><div class="line">    // 这里尝试发现时间混乱的情况，上一次处理事件的时间比当前时间还要大</div><div class="line">    // 重置最近一次处理事件的时间</div><div class="line">    if (now &lt; eventLoop-&gt;lastTime) &#123;</div><div class="line">        te = eventLoop-&gt;timeEventHead;</div><div class="line">        while(te) &#123;</div><div class="line">            te-&gt;when_sec = 0;</div><div class="line">            te = te-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 设置上一次时间事件处理的时间为当前时间</div><div class="line">    eventLoop-&gt;lastTime = now;</div><div class="line"></div><div class="line">    prev = NULL;</div><div class="line">    te = eventLoop-&gt;timeEventHead;</div><div class="line">    maxId = eventLoop-&gt;timeEventNextId-1;   //当前时间事件表中的最大ID</div><div class="line">    // 遍历时间事件链表</div><div class="line">    while(te) &#123;</div><div class="line">        long now_sec, now_ms;</div><div class="line">        long long id;</div><div class="line"></div><div class="line">        /* Remove events scheduled for deletion. */</div><div class="line">        // 如果时间事件已被删除了</div><div class="line">        if (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</div><div class="line">            aeTimeEvent *next = te-&gt;next;</div><div class="line">            // 从事件链表中删除事件的节点</div><div class="line">            if (prev == NULL)</div><div class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</div><div class="line">            else</div><div class="line">                prev-&gt;next = te-&gt;next;</div><div class="line">            // 调用时间事件终结方法清楚该事件</div><div class="line">            if (te-&gt;finalizerProc)</div><div class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</div><div class="line">            zfree(te);</div><div class="line">            te = next;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 确保我们不处理在此迭代中由时间事件创建的时间事件。 请注意，此检查目前无效：我们总是在头节点添加新的计时器，但是如果我们更改实施细节，则该检查可能会再次有用：我们将其保留在未来的防御</div><div class="line">        if (te-&gt;id &gt; maxId) &#123;</div><div class="line">            te = te-&gt;next;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        // 获取当前时间</div><div class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">        // 找到已经到时的时间事件</div><div class="line">        if (now_sec &gt; te-&gt;when_sec ||</div><div class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</div><div class="line">        &#123;</div><div class="line">            int retval;</div><div class="line"></div><div class="line">            id = te-&gt;id;</div><div class="line">            // 调用时间事件处理方法</div><div class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</div><div class="line">            // 时间事件次数加1</div><div class="line">            processed++;</div><div class="line">            // 如果不是定时事件，则继续设置它的到时时间</div><div class="line">            if (retval != AE_NOMORE) &#123;</div><div class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</div><div class="line">            // 如果是定时时间，则retval为-1，则将其时间事件删除，惰性删除</div><div class="line">            &#125; else &#123;</div><div class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 更新前驱节点指针和后继节点指针</div><div class="line">        prev = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    return processed;   //返回执行事件的次数</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果时间事件不存在，则就调用finalizerProc指向的回调函数，删除当前的时间事件。如果存在，就调用timeProc指向的回调函数处理时间事件。Redis的时间事件分为两类</p>
<ul>
<li>定时事件：让一段程序在指定的时间后执行一次。</li>
<li>周期性事件：让一段程序每隔指定的时间后执行一次。<br>如果当前的时间事件是周期性，那么就会在将时间周期添加到周期事件的到时时间中。如果是定时事件，则将该时间事件删除。</li>
</ul>
<p>至此，Redis事件的实现就剖析完毕，但是事件的其他API，例如：创建事件，删除事件，调整事件表的大小等等都没有列出。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（六）--- 压缩列表(ziplist)]]></title>
      <url>http://hlei.io/2018/02/08/redis-analysis-ziplist/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>压缩列表(ziplist)是哈希键的底层实现之一。它是经过特殊编码的双向链表，和整数集合(intset)一样，是为了提高内存的存储效率而设计的。当保存的对象是小整数值，或者是长度较短的字符串，那么redis就会使用压缩列表来作为哈希键的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HMSET hash name mike age 28 sex male</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; HGETALL hash</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;mike&quot;</div><div class="line">3) &quot;age&quot;</div><div class="line">4) &quot;28&quot;</div><div class="line">5) &quot;sex&quot;</div><div class="line">6) &quot;male&quot;</div><div class="line">127.0.0.1:6379&gt; OBJECT ENCODING hash    //编码格式为ziplist</div><div class="line">&quot;ziplist&quot;</div></pre></td></tr></table></figure></p>
<p>注：redis 3.2以后，quicklist作为列表键的实现底层实现之一，代替了压缩列表。</p>
<p>通过命令来查看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; RPUSH list 1 2</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">127.0.0.1:6379&gt; OBJECT ENCODING list    //是quicklist而非ziplist</div><div class="line">&quot;quicklist&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-压缩列表的结构"><a href="#2-压缩列表的结构" class="headerlink" title="2. 压缩列表的结构"></a>2. 压缩列表的结构</h2><p>压缩列表是一系列特殊编码的连续内存块组成的顺序序列数据结构，可以包含任意多个节点(entry)，每一个节点可以保存一个字节数组或者一个整数值。</p>
<p>空间中的结构组成如下图所示：<br>[url01]</p>
<p>这里写图片描述</p>
<ul>
<li>zlbytes：占4个字节，记录整个压缩列表占用的内存字节数。</li>
<li>zltail_offset：占4个字节，记录压缩列表尾节点entryN距离压缩列表的起始地址的字节数。</li>
<li>zllength：占2个字节，记录了压缩列表的节点数量。</li>
<li>entry[1-N]：长度不定，保存数据。</li>
<li><p>zlend：占1个字节，保存一个常数255(0xFF)，标记压缩列表的末端。<br>redis没有提供一个结构体来保存压缩列表的信息，而是提供了一组宏来定位每个成员的地址，定义在ziplist.c文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">由于压缩列表对数据的信息访问都是以字节为单位的，所以参数zl的类型是char *类型的，因此对zl指针进行一系列的强制类型转换，以便对不用长度成员的访问。</div><div class="line">/* Utility macros */</div><div class="line">//  ziplist的成员宏定义</div><div class="line">//  (*((uint32_t*)(zl))) 先对char *类型的zl进行强制类型转换成uint32_t *类型，</div><div class="line">//  然后在用*运算符进行取内容运算，此时zl能访问的内存大小为4个字节。</div><div class="line"></div><div class="line">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</div><div class="line">//将zl定位到前4个字节的bytes成员，记录这整个压缩列表的内存字节数</div><div class="line"></div><div class="line">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</div><div class="line">//将zl定位到4字节到8字节的tail_offset成员，记录着压缩列表尾节点距离列表的起始地址的偏移字节量</div><div class="line"></div><div class="line">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</div><div class="line">//将zl定位到8字节到10字节的length成员，记录着压缩列表的节点数量</div><div class="line"></div><div class="line">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</div><div class="line">//压缩列表表头（以上三个属性）的大小10个字节</div><div class="line"></div><div class="line">#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</div><div class="line">//返回压缩列表首节点的地址</div><div class="line"></div><div class="line">#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</div><div class="line">//返回压缩列表尾节点的地址</div><div class="line"></div><div class="line">#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</div><div class="line">//返回end成员的地址，一个字节。</div></pre></td></tr></table></figure>
</li>
<li><p>intrev32ifbe()是封装的宏，用来根据主机的字节序按需要进行字节大小端的转换。</p>
</li>
</ul>
<h2 id="3-创建一个空的压缩列表"><a href="#3-创建一个空的压缩列表" class="headerlink" title="3. 创建一个空的压缩列表"></a>3. 创建一个空的压缩列表</h2><p>空的压缩列表就是没有节点的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* Create a new empty ziplist. */</div><div class="line">unsigned char *ziplistNew(void) &#123;   //创建并返回一个新的压缩列表</div><div class="line">    //ZIPLIST_HEADER_SIZE是压缩列表的表头大小，1字节是末端的end大小</div><div class="line">    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;</div><div class="line"></div><div class="line">    unsigned char *zl = zmalloc(bytes); //为表头和表尾end成员分配空间</div><div class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);    //将bytes成员初始化为bytes=11</div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);    //空列表的tail_offset成员为表头大小为10</div><div class="line">    ZIPLIST_LENGTH(zl) = 0;     //节点数量为0</div><div class="line">    zl[bytes-1] = ZIP_END;      //将表尾end成员设置成默认的255</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如下图所示：<br>[url02]</p>
<h2 id="4-压缩列表节点结构"><a href="#4-压缩列表节点结构" class="headerlink" title="4. 压缩列表节点结构"></a>4. 压缩列表节点结构</h2><p>redis对于压缩列表节点定义了一个zlentry的结构，用来管理节点的所有信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct zlentry &#123;</div><div class="line">    //prevrawlen 前驱节点的长度</div><div class="line">    //prevrawlensize 编码前驱节点的长度prevrawlen所需要的字节大小</div><div class="line">    unsigned int prevrawlensize, prevrawlen;</div><div class="line"></div><div class="line">    //len 当前节点值长度</div><div class="line">    //lensize 编码当前节点长度len所需的字节数</div><div class="line">    unsigned int lensize, len;</div><div class="line"></div><div class="line">    //当前节点header的大小 = lensize + prevrawlensize</div><div class="line">    unsigned int headersize;</div><div class="line"></div><div class="line">    //当前节点的编码格式</div><div class="line">    unsigned char encoding;</div><div class="line"></div><div class="line">    //指向当前节点的指针，以char *类型保存</div><div class="line">    unsigned char *p;</div><div class="line">&#125; zlentry;                  //压缩列表节点信息的结构</div></pre></td></tr></table></figure></p>
<p>虽然定义了这个结构体，但是根本就没有使用zlentry结构来作为压缩列表中用来存储数据节点中的结构，但是。因为，这个结构存小整数或短字符串实在是太浪费空间了。这个结构总共在32位机占用了28个字节(32位机)，在64位机占用了32个字节。这不符合压缩列表的设计目的：提高内存的利用率。因此，在redis中，并没有定义结构体来进行操作，也是定义了一些宏，压缩列表的节点真正的结构如下图所示：<br>[url03]</p>
<ul>
<li>prev_entry_len：记录前驱节点的长度。</li>
<li>encoding：记录当前节点的value成员的数据类型以及长度。</li>
<li>value：根据encoding来保存字节数组或整数。<br>接下来就分别讨论这三个成员：</li>
</ul>
<p>接下来就分别讨论这三个成员：</p>
<h3 id="4-1-prev-entry-len成员"><a href="#4-1-prev-entry-len成员" class="headerlink" title="4.1 prev_entry_len成员"></a>4.1 prev_entry_len成员</h3><p>prev_entry_len成员实际上就是zlentry结构中prevrawlensize,和prevrawlen这两个成员的压缩版。</p>
<p>prevrawlen：记录着上一个节点的长度。<br>prevrawlensize：记录编码prevrawlen值的所需的字节个数。<br>而这两个成员都是int类型，因此将两者压缩为一个成员prev_entry_len，而且分别对不同长度的前驱节点使用不同的字节数来表示。</p>
<p>当前驱节点的长度小于254字节，那么prev_entry_len使用1字节表示。<br>当前驱节点的长度大于等于255字节，那么prev_entry_len使用5个字节表示。并且用5个字节中的最高8位(最高1个字节)用 0xFE 标示prev_entry_len占用了5个字节，后四个字节才是真正保存前驱节点的长度值。<br>因为，对于访问的指针都是char 类型，它能访问的范围1个字节，如果这个字节的大小等于0xFE，那么就会继续访问四个字节来获取前驱节点的长度，如果该字节的大小小于0xFE，那么该字节就是要获取的前驱节点的长度。因此这样就使prev_entry_len同时具有了prevrawlen和prevrawlensize的功能，而且更加节约内存。*</p>
<p>redis中的代码这样描述，定义在ziplist.c中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#define ZIP_BIGLEN 254 </div><div class="line"></div><div class="line">//对前驱节点的长度len进行编码，并写入p中，如果p为空，则仅仅返回编码len所需要的字节数</div><div class="line">static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) &#123;</div><div class="line">    if (p == NULL) &#123;</div><div class="line">        return (len &lt; ZIP_BIGLEN) ? 1 : sizeof(len)+1;  //如果前驱节点的长度len字节小于254则返回1个字节，否则返回5个</div><div class="line">    &#125; else &#123;</div><div class="line">        if (len &lt; ZIP_BIGLEN) &#123; //如果前驱节点的长度len字节小于254</div><div class="line">            p[0] = len;         //将len保存在p[0]中</div><div class="line">            return 1;           //返回所需的编码数1字节</div><div class="line">        &#125; else &#123;                //前驱节点的长度len大于等于255字节</div><div class="line">            p[0] = ZIP_BIGLEN;  //添加5字节的标示，0xFE</div><div class="line">            memcpy(p+1,&amp;len,sizeof(len));   //从p+1的起始地址开始拷贝len，拷贝四个字节</div><div class="line">            memrev32ifbe(p+1);</div><div class="line">            return 1+sizeof(len);   //返回所需的编码数5字节</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-2-encoding成员"><a href="#4-2-encoding成员" class="headerlink" title="4.2 encoding成员"></a>4.2 encoding成员</h3><p>和prev_entry_len一样，encoding成员同样可以看做成zlentry结构中lensize和len的压缩版。</p>
<p>len：当前节点值长度。<br>lensize： 编码当前节点长度len所需的字节数。<br>同样的lensize和len都是占4个字节的，因此将两者压缩为一个成员encoding，只要encoding能够同时具有lensize和len成员的功能，而且对当前节点保存的是字节数组还是整数分别编码。</p>
<p>redis对字节数组和整数编码提供了一组宏定义，定义在ziplist.c中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Different encoding/length possibilities */</div><div class="line">#define ZIP_STR_MASK 0xc0               //1100 0000     字节数组的掩码</div><div class="line">#define ZIP_STR_06B (0 &lt;&lt; 6)            //0000 0000</div><div class="line">#define ZIP_STR_14B (1 &lt;&lt; 6)            //0100 0000</div><div class="line">#define ZIP_STR_32B (2 &lt;&lt; 6)            //1000 0000</div><div class="line"></div><div class="line">#define ZIP_INT_MASK 0x30               //0011 0000     整数的掩码</div><div class="line">#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)       //1100 0000</div><div class="line">#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)       //1101 0000</div><div class="line">#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)       //1110 0000</div><div class="line">#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)       //1111 0000</div><div class="line">#define ZIP_INT_8B 0xfe                 //1111 1110</div><div class="line"></div><div class="line">//掩码个功能就是区分一个encoding是字节数组编码还是整数编码</div><div class="line">//如果这个宏返回 1 就代表该enc是字节数组，如果是 0 就代表是整数的编码</div><div class="line">#define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（五）--- 整数集合(intset)]]></title>
      <url>http://hlei.io/2018/02/08/redis-analysis-intset/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>整数集合（intset）是集合键底层实现之一。集合键另一实现是值为空的散列表（hash table），虽然使用散列表对集合的加入删除元素，判断元素是否存在等等操作时间复杂度为O(1)，但是当存储的元素是整型且元素数目较少时，如果使用散列表存储，就会比较浪费内存，因此整数集合（intset）类型因为节约内存就存在。</p>
<p>散列表的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SADD set1 1 2 3</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; SADD set1 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SMEMBERS set1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">127.0.0.1:6379&gt; SISMEMBER set1 2</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SREM set1 1</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SMEMBERS set1</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-整数集合结构的实现"><a href="#2-整数集合结构的实现" class="headerlink" title="2. 整数集合结构的实现"></a>2. 整数集合结构的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis根目录下的intset.h文件</div><div class="line"></div><div class="line">typedef struct intset &#123;</div><div class="line">    uint32_t encoding;  //编码格式，有如下三种格式，初始值默认为INTSET_ENC_INT16</div><div class="line">    uint32_t length;    //集合元素数量</div><div class="line">    int8_t contents[];  //保存元素的数组，元素类型并不一定是ini8_t类型，柔性数组不占intset结构体大小，并且数组中的元素从小到大排列。</div><div class="line">&#125; intset;               //整数集合结构</div><div class="line"></div><div class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))   //16位，2个字节，表示范围-32,768~32,767</div><div class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))   //32位，4个字节，表示范围-2,147,483,648~2,147,483,647</div><div class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))   //64位，8个字节，表示范围-9,223,372,036,854,775</div></pre></td></tr></table></figure>
<h2 id="3-升级"><a href="#3-升级" class="headerlink" title="3. 升级"></a>3. 升级</h2><p>intset整数集合之所以有三种表示编码格式的宏定义，是因为根据存储的元素数值大小，能够选取一个最”合适”的类型存储，”合适”可以理解为：既能够表示元素的大小，又可以节省空间。</p>
<p>因此，当新添加的元素，例如：65535，超过当前集合编码格式所能表示的范围，就要进行升级操作。</p>
<p>我们使用刚才命令中的集合，它在结构如下图：<br>[url01]</p>
<h3 id="3-1获得新元素的编码格式"><a href="#3-1获得新元素的编码格式" class="headerlink" title="3.1获得新元素的编码格式"></a>3.1获得新元素的编码格式</h3><p>当前新元素要插入到集合中时，首先就要判获得新元素的编码格式，所以调用_intsetValueEncoding()来返回一个”适合”该元素的编码格式。65535的最”适合”的编码格式是INTSET_ENC_INT32。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;    //返回合适v的编码方式</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)             //如果超出32位所能表示数值的范围则返回INTSET_ENC_INT64</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)        //如果超出16位所能表示数值的范围则返回INTSET_ENC_INT32</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;                    //否则返回用16位表示的INTSET_ENC_INT16</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-调整内存空间"><a href="#3-2-调整内存空间" class="headerlink" title="3.2 调整内存空间"></a>3.2 调整内存空间</h3><p>当得到新元素的编码格式后，就要将集合中所有元素的编码格式都要变成升级后的编码格式，因此，需要调整集合数组contents的内存空间大小，调用intsetResize()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Resize the intset */</div><div class="line">static intset *intsetResize(intset *is, uint32_t len) &#123; //调整集合的内存空间大小</div><div class="line">    uint32_t size = len*intrev32ifbe(is-&gt;encoding);     //计算数组的大小</div><div class="line">    is = zrealloc(is,sizeof(intset)+size);  </div><div class="line">    //分配空间，如果新空间的大小比原来的空间大，那么数组的元素会被保留</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>intrev32ifbe()是一个宏定义，定义和实现在redis根目录下的endianconv.h和endianconv.c中根据主机字节序用来做整数大小端的转换。<br>已经获知65535的编码格式，因此调整内存空间的大小等于编码格式的大小乘以集合元素的个数。如果图：<br>[url02]<br>注意：encoding成员已经发生变化，但是length并没有更新。</li>
</ul>
<h3 id="3-3-根据编码格式设置对应的值"><a href="#3-3-根据编码格式设置对应的值" class="headerlink" title="3.3 根据编码格式设置对应的值"></a>3.3 根据编码格式设置对应的值</h3><p>调整好内存空间后就根据编码格式来设置集合元素的值和最后将新元素添加到集合中，都调用_intsetSet()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Set the value at pos, using the configured encoding. */</div><div class="line">//根据集合is设置的编码方式，设置下标为pos的值为value</div><div class="line">static void _intsetSet(intset *is, int pos, int64_t value) &#123;    </div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获取集合设置的编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;             //如果是64位</div><div class="line">        ((int64_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev64ifbe(((int64_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;      //如果是32位</div><div class="line">        ((int32_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev32ifbe(((int32_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else &#123;</div><div class="line">        ((int16_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev16ifbe(((int16_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>memrev16ifbe()是一个宏定义，定义和实现在redis根目录下的endianconv.h和endianconv.c中根据主机字节序用来做内存大小端的转换。</li>
</ul>
<p>将集合中原来的元素和新插入的元素以”合适”的编码格式INTSET_ENC_INT32写到数组中，顺序过程如下图：<br>[url03]</p>
<p>最后要更新length。</p>
<h3 id="3-4-升级实现源码"><a href="#3-4-升级实现源码" class="headerlink" title="3.4 升级实现源码"></a>3.4 升级实现源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123; //根据value的编码方式，对整数集合is的编码格式升级</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);    //当前集合的编码方式</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);   //得到value合适的编码方式</div><div class="line">    int length = intrev32ifbe(is-&gt;length);          //集合元素数量</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;                //如果value小于0，则要将value添加到数组最前端，因此为移动1个编码长度</div><div class="line">    //集合的编码格式要升级，也就是内存增大</div><div class="line">    //因为 value 的编码比集合原有的其他元素的编码都要大，所以value如果是负数，就是最小值，如果是正数则是最大值</div><div class="line">    //索引value要么放在数组集合的最前端，要么最后端，根据prepend判断</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);    //更新集合is的编码方式</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //根据新的编码方式重新设置内存空间大小</div><div class="line"></div><div class="line">    /* Upgrade back-to-front so we don&apos;t overwrite values.</div><div class="line">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</div><div class="line">     * space at either the beginning or the end of the intset. */</div><div class="line">    //_intsetGetEncoded()得到下标为length的值</div><div class="line">    //_intsetSet设置下标为prepend+length的值为_intsetGetEncoded返回的值</div><div class="line">    //但是，编码格式已经发生改变，数组元素没变但是内存大小改变</div><div class="line">    while(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)    //value是负数，要放在最前端</div><div class="line">        _intsetSet(is,0,value); //设置下标为0的值为value</div><div class="line">    else</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);  //value为正数，设置最末尾+1的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //数组元素加1</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-5-升级的特点"><a href="#3-5-升级的特点" class="headerlink" title="3.5 升级的特点"></a>3.5 升级的特点</h3><ul>
<li>提升灵活性：因为C语言是静态类型的语言，通常在在数组中只是用一种类型保存数据，例如，要么只用int16_t类型，要么只用int32_t类型。通过自动升级底层数组来适应不同类型的新元素，不必担心类型的错误。</li>
<li>节约内存：整数集合既可以让集合保存三种不同类型的值，又可以确保升级操作只在有需要的时候进行，这样就节省了内存。</li>
<li>不支持降级：一旦对数组进行升级，编码就会一直保存升级后的状态。</li>
</ul>
<h2 id="4-整数集合的其他操作"><a href="#4-整数集合的其他操作" class="headerlink" title="4.整数集合的其他操作"></a>4.整数集合的其他操作</h2><p>源代码注释下载：redis源码注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div></pre></td><td class="code"><pre><div class="line">intset *intsetNew(void);    //创建一个空集合</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success);//将value添加到is集合中，如果成功success被设置为1否则为0</div><div class="line">intset *intsetRemove(intset *is, int64_t value, int *success);//从集合中删除value，删除成功success设置为1，失败为0</div><div class="line">uint8_t intsetFind(intset *is, int64_t value);//返回1表示value是集合中的元素，否则返回0</div><div class="line">int64_t intsetRandom(intset *is);//随机返回一个元素</div><div class="line">uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);//获得下标为pos的值并保存在value中</div><div class="line">uint32_t intsetLen(intset *is);//返回集合的元素个数</div><div class="line">size_t intsetBlobLen(intset *is);//返回集合所占用的字节总量</div><div class="line"></div><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;    //返回合适v的编码方式</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)         //如果超出32位所能表示数值的范围则返回INTSET_ENC_INT64</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)    //如果超出16位所能表示数值的范围则返回INTSET_ENC_INT32</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;                //返回用16位表示的INTSET_ENC_INT16</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return the value at pos, given an encoding. */</div><div class="line">static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) &#123;    //根据编码方式enc，返回在集合is中下标为pos的元素</div><div class="line">    int64_t v64;</div><div class="line">    int32_t v32;</div><div class="line">    int16_t v16;</div><div class="line"></div><div class="line">    if (enc == INTSET_ENC_INT64) &#123;  //64位编码</div><div class="line">        memcpy(&amp;v64,((int64_t*)is-&gt;contents)+pos,sizeof(v64));  //从下标pos开始的内存空间拷贝64bit的数据到v64</div><div class="line">        memrev64ifbe(&amp;v64); //如果是大端序，就会转换成小端序</div><div class="line">        return v64;</div><div class="line">    &#125; else if (enc == INTSET_ENC_INT32) &#123;//32位编码</div><div class="line">        memcpy(&amp;v32,((int32_t*)is-&gt;contents)+pos,sizeof(v32));//从下标pos开始的内存空间拷贝32bit的数据到v32</div><div class="line">        memrev32ifbe(&amp;v32); //32位大小端转换</div><div class="line">        return v32;</div><div class="line">    &#125; else &#123;//16位编码</div><div class="line">        memcpy(&amp;v16,((int16_t*)is-&gt;contents)+pos,sizeof(v16));//从下标pos开始的内存空间拷贝16bit的数据到v16</div><div class="line">        memrev16ifbe(&amp;v16); //16位大小端转换</div><div class="line">        return v16;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return the value at pos, using the configured encoding. */</div><div class="line">static int64_t _intsetGet(intset *is, int pos) &#123;    //根据集合is设置的编码方式，返回下标为pos的值</div><div class="line">    return _intsetGetEncoded(is,pos,intrev32ifbe(is-&gt;encoding));</div><div class="line">    //intrev32ifbe()函数返回参数的编码格式并且根据需求转换大小端</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Set the value at pos, using the configured encoding. */</div><div class="line">static void _intsetSet(intset *is, int pos, int64_t value) &#123;    //根据集合is设置的编码方式，设置下标为pos的值为value</div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获取集合设置的编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;             //如果是64位</div><div class="line">        ((int64_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev64ifbe(((int64_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;      //如果是32位</div><div class="line">        ((int32_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev32ifbe(((int32_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125; else &#123;</div><div class="line">        ((int16_t*)is-&gt;contents)[pos] = value;      //设置下标pos的值为value</div><div class="line">        memrev16ifbe(((int16_t*)is-&gt;contents)+pos); //如果需要转换大小端</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Create an empty intset. */</div><div class="line">intset *intsetNew(void) &#123;           //创建一个空集合</div><div class="line">    intset *is = zmalloc(sizeof(intset));   //分配空间</div><div class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);  //设置编码方式</div><div class="line">    is-&gt;length = 0; //集合为空</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Resize the intset */</div><div class="line">static intset *intsetResize(intset *is, uint32_t len) &#123; //调整集合的内存空间大小</div><div class="line">    uint32_t size = len*intrev32ifbe(is-&gt;encoding); //计算数组的大小</div><div class="line">    is = zrealloc(is,sizeof(intset)+size);  //分配空间，如果新空间的大小比原来的空间大，那么数组的元素会被保留</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and</div><div class="line"> * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when</div><div class="line"> * the value is not present in the intset and sets &quot;pos&quot; to the position</div><div class="line"> * where &quot;value&quot; can be inserted. */</div><div class="line">//找到is集合中值为value的下标，返回1，并保存在pos中，没有找到返回0，并将pos设置为value可以插入到数组的位置</div><div class="line">static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) &#123;</div><div class="line">    int min = 0, max = intrev32ifbe(is-&gt;length)-1, mid = -1;</div><div class="line">    int64_t cur = -1;</div><div class="line"></div><div class="line">    /* The value can never be found when the set is empty */</div><div class="line">    if (intrev32ifbe(is-&gt;length) == 0) &#123;    //如果为空集合</div><div class="line">        if (pos) *pos = 0;                  //pos设置为0</div><div class="line">        return 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Check for the case where we know we cannot find the value,</div><div class="line">         * but do know the insert position. */</div><div class="line">        if (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)-1)) &#123;    //因为数组是有序的，如果value大于数组最大值</div><div class="line">            if (pos) *pos = intrev32ifbe(is-&gt;length);       //可以将pos设置为数组末尾</div><div class="line">            return 0;</div><div class="line">        &#125; else if (value &lt; _intsetGet(is,0)) &#123;  //如果小于数组的最小值</div><div class="line">            if (pos) *pos = 0;          //pos可以是下标为0的位置</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while(max &gt;= min) &#123; //有序集合中进行二分查找</div><div class="line">        mid = ((unsigned int)min + (unsigned int)max) &gt;&gt; 1; //(min+max)/2，找到中间数的下标</div><div class="line">        cur = _intsetGet(is,mid);   //等到下标为mid的值cur</div><div class="line">        if (value &gt; cur) &#123;  //value大于当前值cur</div><div class="line">            min = mid+1;    //后一半找</div><div class="line">        &#125; else if (value &lt; cur) &#123;   //value小于当前值cur</div><div class="line">            max = mid-1;    //前一半找</div><div class="line">        &#125; else &#123;</div><div class="line">            break;  //找到退出循环</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (value == cur) &#123; //确认找到</div><div class="line">        if (pos) *pos = mid;    //设置pos为找到的位置，返回1</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (pos) *pos = min;    //此时min和max相等，所以pos可以设置为min或max，返回0</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123; //根据value的编码方式，对整数集合is的编码格式升级</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);    //当前集合的编码方式</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);   //得到value合适的编码方式</div><div class="line">    int length = intrev32ifbe(is-&gt;length);          //集合元素数量</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;                //如果value小于0，则要将value添加到数组最前端，因此为移动1个编码长度</div><div class="line">    //集合的编码格式要升级，也就是内存增大</div><div class="line">    //因为 value 的编码比集合原有的其他元素的编码都要大，所以value如果是负数，就是最小值，如果是正数则是最大值</div><div class="line">    //索引value要么放在数组集合的最前端，要么最后端，根据prepend判断</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);    //更新集合is的编码方式</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //根据新的编码方式重新设置内存空间大小</div><div class="line"></div><div class="line">    /* Upgrade back-to-front so we don&apos;t overwrite values.</div><div class="line">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</div><div class="line">     * space at either the beginning or the end of the intset. */</div><div class="line">    //_intsetGetEncoded()得到下标为length的值</div><div class="line">    //_intsetSet设置下标为prepend+length的值为_intsetGetEncoded返回的值</div><div class="line">    //但是，编码格式已经发生改变，数组元素没变但是内存大小改变</div><div class="line">    while(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)    //value是负数，要放在最前端</div><div class="line">        _intsetSet(is,0,value); //设置下标为0的值为value</div><div class="line">    else</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);  //value为正数，设置最末尾+1的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //数组元素加1</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) &#123;    //向前或向后移动指定下标范围内的数组元素</div><div class="line">    void *src, *dst;</div><div class="line">    uint32_t bytes = intrev32ifbe(is-&gt;length)-from; //获得要移动的元素的个数</div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding); //获得集合is的默认编码方式</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;         //判断不同的编码格式</div><div class="line">        src = (int64_t*)is-&gt;contents+from;      //获得要被移动范围的起始地址</div><div class="line">        dst = (int64_t*)is-&gt;contents+to;        //获得要被移动到的目的地址</div><div class="line">        bytes *= sizeof(int64_t);               //计算要移动多少个字节</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;</div><div class="line">        src = (int32_t*)is-&gt;contents+from;</div><div class="line">        dst = (int32_t*)is-&gt;contents+to;</div><div class="line">        bytes *= sizeof(int32_t);</div><div class="line">    &#125; else &#123;</div><div class="line">        src = (int16_t*)is-&gt;contents+from;</div><div class="line">        dst = (int16_t*)is-&gt;contents+to;</div><div class="line">        bytes *= sizeof(int16_t);</div><div class="line">    &#125;</div><div class="line">    memmove(dst,src,bytes); //从src开始移动bytes个字节到dst</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Insert an integer in the intset */</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123;//将value添加到is集合中，如果成功success被设置为1否则为0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 1;  //设置success默认为1</div><div class="line"></div><div class="line">    /* Upgrade encoding if necessary. If we need to upgrade, we know that</div><div class="line">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</div><div class="line">     * because it lies outside the range of existing values. */</div><div class="line">    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;  //如果value的编码类型大于集合的编码类型</div><div class="line">        /* This always succeeds, so we don&apos;t need to curry *success. */</div><div class="line">        return intsetUpgradeAndAdd(is,value);   //升级集合，并且将value加入集合，一定成功</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Abort if the value is already present in the set.</div><div class="line">         * This call will populate &quot;pos&quot; with the right position to insert</div><div class="line">         * the value when it cannot be found. */</div><div class="line">        if (intsetSearch(is,value,&amp;pos)) &#123;  //查找value，若果value已经存在，intsetSearch返回1,如果不存在，pos保存value可以插入的位置</div><div class="line">            if (success) *success = 0;  //value存在，success设置为0</div><div class="line">            return is;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //value在集合中不存在，且pos保存可以插入的位置</div><div class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);   //调整集合大小</div><div class="line">        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1);   //如果pos不是在数组末尾则要移动调整集合</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _intsetSet(is,pos,value);   //设置pos下标的值为value</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);  //集合节点数量加1</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Delete integer from intset */</div><div class="line">intset *intsetRemove(intset *is, int64_t value, int *success) &#123; //从集合中删除value，删除成功success设置为1，失败为0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 0;  //设置success默认为0</div><div class="line"></div><div class="line">    //如果value的编码格式小于集合的编码格式且value在集合中已存在，pos保存着下标</div><div class="line">    if (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">        uint32_t len = intrev32ifbe(is-&gt;length);    //备份当前集合元素数量</div><div class="line"></div><div class="line">        /* We know we can delete */</div><div class="line">        if (success) *success = 1;  //删除成功，设置success为1</div><div class="line"></div><div class="line">        /* Overwrite value with tail and update length */</div><div class="line">        if (pos &lt; (len-1)) intsetMoveTail(is,pos+1,pos);    //如果不是最后一个元素，则移动元素覆盖掉被删除的元素</div><div class="line">        is = intsetResize(is,len-1);    //缩小大小</div><div class="line">        is-&gt;length = intrev32ifbe(len-1);   //更新集合元素个数</div><div class="line">    &#125;</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Determine whether a value belongs to this set */</div><div class="line">uint8_t intsetFind(intset *is, int64_t value) &#123;     //返回1表示value是集合中的元素，否则返回0</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);   //获得value适合的编码类型</div><div class="line">    return valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL);</div><div class="line">    //如果value的编码格式小于集合的编码格式且value在集合中已存在，返回1，其中任何一个不成立返回0</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return random member */</div><div class="line">int64_t intsetRandom(intset *is) &#123;  //随机返回一个元素</div><div class="line">    return _intsetGet(is,rand()%intrev32ifbe(is-&gt;length));  //随机生成一个下标，返回该下标的值</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Sets the value to the value at the given position. When this position is</div><div class="line"> * out of range the function returns 0, when in range it returns 1. */</div><div class="line">uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) &#123;   //获得下标为pos的值并保存在value中</div><div class="line">    if (pos &lt; intrev32ifbe(is-&gt;length)) &#123;   //如果pos小于数组长度</div><div class="line">        *value = _intsetGet(is,pos);        //返回pos下标的值，保存在value中</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return intset length */</div><div class="line">uint32_t intsetLen(intset *is) &#123;    //返回集合的元素个数</div><div class="line">    return intrev32ifbe(is-&gt;length);    //返回length成员</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return intset blob size in bytes. */</div><div class="line">size_t intsetBlobLen(intset *is) &#123;  //返回集合所占用的字节总量</div><div class="line">    return sizeof(intset)+intrev32ifbe(is-&gt;length)*intrev32ifbe(is-&gt;encoding);  //编码格式×元素个数+集合大小</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（六）--- 压缩列表(ziplist)]]></title>
      <url>http://hlei.io/2018/02/05/redis-analysis-skiplist/</url>
      <content type="html"><![CDATA[<h2 id="1-跳跃表（skiplist）介绍"><a href="#1-跳跃表（skiplist）介绍" class="headerlink" title="1. 跳跃表（skiplist）介绍"></a>1. 跳跃表（skiplist）介绍</h2><p>定义：跳跃表是一个有序链表，其中每个节点包含不定数量的链接，节点中的第i个链接构成的单向链表跳过含有少于i个链接的节点。</p>
<ul>
<li>跳跃表支持平均O(logN)，最坏O(N)</li>
<li>复杂度的节点查找，大部分情况下，跳跃表的效率可以和平衡树相媲美。</li>
<li>跳跃表在redis中当数据较多时作为有序集合键的实现方式之一。</li>
</ul>
<p>接下来，还是举个有序集合键的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; ZADD score 95.5 Mike 98 Li 96 Wang  //socre是一个有序集合键</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; ZRANGE score 0 -1 WITHSCORES//所有分数按从小到大排列，每一个成员都保存了一个分数</div><div class="line">1) &quot;Mike&quot;</div><div class="line">2) &quot;95.5&quot;</div><div class="line">3) &quot;Wang&quot;</div><div class="line">4) &quot;96&quot; </div><div class="line">5) &quot;Li&quot;</div><div class="line">6) &quot;98&quot;</div><div class="line">127.0.0.1:6379&gt; ZSCORE score Mike       //查询Mike的分值</div><div class="line">&quot;95.5&quot;</div></pre></td></tr></table></figure></p>
<h2 id="2-跳跃表的实现"><a href="#2-跳跃表的实现" class="headerlink" title="2. 跳跃表的实现"></a>2. 跳跃表的实现</h2><p>redis 3.0版本将跳跃表定义在redis.h文件中，而3.2版本定义在server.h文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">跳跃表节点 zskiplistNode</div><div class="line">typedef struct zskiplistNode &#123;</div><div class="line">    robj *obj;                          //保存成员对象的地址</div><div class="line">    double score;                       //分值</div><div class="line">    struct zskiplistNode *backward;     //后退指针</div><div class="line">    struct zskiplistLevel &#123;</div><div class="line">        struct zskiplistNode *forward;  //前进指针</div><div class="line">        unsigned int span;              //跨度</div><div class="line">    &#125; level[];                          //层级，柔型数组</div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">跳跃表表头 zskiplist（记录跳跃表信息）</div><div class="line">typedef struct zskiplist &#123;</div><div class="line">    struct zskiplistNode *header, *tail;//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</div><div class="line">    unsigned long length;       //跳跃表的长度或跳跃表节点数量计数器，除去第一个节点</div><div class="line">    int level;                  //跳跃表中节点的最大层数，除了第一个节点</div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h2 id="3-幂次定律"><a href="#3-幂次定律" class="headerlink" title="3. 幂次定律"></a>3. 幂次定律</h2><p>在redis中，返回一个随机层数值，随机算法所使用的幂次定律。</p>
<ul>
<li>含义是：如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律。</li>
<li>表现是：少数几个事件的发生频率占了整个发生频率的大部分， 而其余的大多数事件只占整个发生频率的一个小部分。</li>
</ul>
<p>在文件t_set.c中，zslRandomLevel函数的定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int zslRandomLevel(void) &#123;          //返回一个随机层数值</div><div class="line">    int level = 1;</div><div class="line">    //(random()&amp;0xFFFF)只保留低两个字节的位值，其他高位全部清零，所以该值范围为0到0xFFFF</div><div class="line">    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))  //ZSKIPLIST_P（0.25）所以level+1的概率为0.25</div><div class="line">        level += 1;         //返回一个1到ZSKIPLIST_MAXLEVEL（32）之间的值</div><div class="line">    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^32 elements */</div><div class="line">#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */</div></pre></td></tr></table></figure></p>
<p>算法性能分析：</p>
<p>层数至少为1，所以层数恰好等于1（不执行while循环体）的概率为 1−p.</p>
<ul>
<li>层数恰好等于2的概率为 p(1−p)（执行1次while循环体）。</li>
<li>层数恰好等于3的概率为 p^2(1−p)（执行2次while循环体）。</li>
<li>层数恰好等于4的概率为 p^3(1−p)（执行3次while循环体）。</li>
<li>层数恰好等于k的概率为 p^k−1(1−p)（执行k-1次while循环体）。（k &lt;= ZSKIPLIST_MAXLEVEL）<br>因此，一个节点的平均层数，或平均指针数为：</li>
</ul>
<p>​ 1×(1−p)+2p(1−p)+3p^2(1−p)+…+kp^(k−1)(1−p)<br>​ =1/(1−p)</p>
<p>因此，<br>当 p = 1/2 时，每个节点的平均指针为2；<br>当 p = 1/4 时，每个节点的平均指针为1.33；<br>而redis的概率 ZSKIPLIST_P 取值就为0.25，所以跳跃表的指针开销为1.33</p>
<h2 id="4-跳跃表与哈希表和平衡树的比较"><a href="#4-跳跃表与哈希表和平衡树的比较" class="headerlink" title="4. 跳跃表与哈希表和平衡树的比较"></a>4. 跳跃表与哈希表和平衡树的比较</h2><p>跳跃表和平衡树的元素都是有序排列，而哈希表不是有序的。因此在哈希表上的查找只能是单个key的查找，不适合做范围查找。</p>
<ul>
<li>跳跃表和平衡树做范围查找时，跳跃表算法简单，实现方便，而平衡树逻辑复杂。</li>
<li>查找单个key，跳跃表和平衡树的平均时间复杂度都为O(logN)，而哈希表的时间复杂度为O(1)。</li>
<li>跳跃表平均每个节点包含1.33个指针，而平衡树每个节点包含2个指针，更加节约内存。</li>
</ul>
<p>因此，在redis中实现有序集合的办法是：跳跃表+哈希表</p>
<ul>
<li>跳跃表元素有序，而且可以范围查找，且比平衡树简单。</li>
<li>哈希表查找单个key时间复杂度性能高。</li>
</ul>
<h2 id="5-跳跃表基本操作"><a href="#5-跳跃表基本操作" class="headerlink" title="5 跳跃表基本操作"></a>5 跳跃表基本操作</h2><p>redis关于跳跃表的API都定义在t_zset.c文件中。</p>
<h3 id="5-1-创建跳跃表-zslCreate"><a href="#5-1-创建跳跃表-zslCreate" class="headerlink" title="5.1 创建跳跃表 zslCreate()"></a>5.1 创建跳跃表 zslCreate()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">zskiplist *zslCreate(void) &#123;        //创建返回一个跳跃表 表头zskiplist</div><div class="line">    int j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    zsl = zmalloc(sizeof(*zsl));       //分配空间</div><div class="line">    zsl-&gt;level = 1;                     //设置默认层数</div><div class="line">    zsl-&gt;length = 0;                    //设置跳跃表长度</div><div class="line">    //创建一个层数为32，分数为0，没有obj的跳跃表头节点</div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</div><div class="line"></div><div class="line">    //跳跃表头节点初始化</div><div class="line">    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = NULL;   //将跳跃表头节点的所有前进指针forward设置为NULL</div><div class="line">        zsl-&gt;header-&gt;level[j].span = 0;         //将跳跃表头节点的所有跨度span设置为0</div><div class="line">    &#125;</div><div class="line">    zsl-&gt;header-&gt;backward = NULL;           //跳跃表头节点的后退指针backward置为NULL</div><div class="line"></div><div class="line">    zsl-&gt;tail = NULL;                       //表头指向跳跃表尾节点的指针置为NULL</div><div class="line">    return zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-2-插入节点-zslInsert"><a href="#5-2-插入节点-zslInsert" class="headerlink" title="5.2 插入节点 zslInsert()"></a>5.2 插入节点 zslInsert()</h3><p>//创建一个节点，分数为score，对象为obj，插入到zsl表头管理的跳跃表中，并返回新节点的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    int i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line"></div><div class="line">    x = zsl-&gt;header;            //获取跳跃表头结点地址，从头节点开始一层一层遍历</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;       //遍历头节点的每个level，从下标最大层减1到0</div><div class="line">        /* store rank that is crossed to reach the insert position */</div><div class="line">        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];  //更新rank[i]为i+1所跨越的节点数，但是最外一层为0</div><div class="line"></div><div class="line">        //这个while循环是查找的过程，沿着x指针遍历跳跃表，满足以下条件则要继续在当层往前走</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;       //当前层的前进指针不为空且</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||  //当前的要插入的score大于当前层的score或</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp; //当前score等于要插入的score且</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; 0))) &#123;//当前层的对象与要插入的obj不等</div><div class="line"></div><div class="line">            rank[i] += x-&gt;level[i].span;   //记录该层一共跨越了多少节点 加上 上一层遍历所跨越的节点数</div><div class="line">            x = x-&gt;level[i].forward;       //指向下一个节点</div><div class="line">        &#125;</div><div class="line">        //while循环跳出时，用update[i]记录第i层所遍历到的最后一个节点，遍历到i=0时，就要在该节点后要插入节点</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* we assume the key is not already inside, since we allow duplicated</div><div class="line">     * scores, and the re-insertion of score and redis object should never</div><div class="line">     * happen since the caller of zslInsert() should test in the hash table</div><div class="line">     * if the element is already inside or not.</div><div class="line">     * zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</div><div class="line">     * 所以这里不需要进一步进行检查，可以直接创建新元素。</div><div class="line">     */</div><div class="line"></div><div class="line">    level = zslRandomLevel();       //获得一个随机的层数</div><div class="line">    if (level &gt; zsl-&gt;level) &#123;       //如果大于当前所有节点最大的层数时</div><div class="line">        for (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = 0;            //将大于等于原来zsl-&gt;level层以上的rank[]设置为0</div><div class="line">            update[i] = zsl-&gt;header;    //将大于等于原来zsl-&gt;level层以上update[i]指向头结点</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length; //update[i]已经指向头结点，将第i层的跨度设置为length</div><div class="line">                                                    //length代表跳跃表的节点数量</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;     //更新表中的最大成数值</div><div class="line">    &#125;</div><div class="line">    x = zslCreateNode(level,score,obj);     //创建一个节点</div><div class="line">    for (i = 0; i &lt; level; i++) &#123;       //遍历每一层</div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;  //设置新节点的前进指针为查找时（while循环）每一层最后一个节点的的前进指针</div><div class="line">        update[i]-&gt;level[i].forward = x;//再把查找时每层的最后一个节点的前进指针设置为新创建的节点地址</div><div class="line"></div><div class="line">        /* update span covered by update[i] as x is inserted here */</div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);  //更新插入节点的跨度值</div><div class="line">        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;               //更新插入节点前一个节点的跨度值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* increment span for untouched levels */</div><div class="line">    for (i = level; i &lt; zsl-&gt;level; i++) &#123;  //如果插入节点的level小于原来的zsl-&gt;level才会执行</div><div class="line">        update[i]-&gt;level[i].span++;             //因为高度没有达到这些层，所以只需将查找时每层最后一个节点的值的跨度加1</div><div class="line">    &#125;</div><div class="line">    //设置插入节点的后退指针，就是查找时最下层的最后一个节点，该节点的地址记录在update[0]中</div><div class="line">    //如果插入在第二个节点，也就是头结点后的位置就将后退指针设置为NULL</div><div class="line">    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</div><div class="line"></div><div class="line">    if (x-&gt;level[0].forward)    //如果x节点不是最尾部的节点</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x;  //就将x节点后面的节点的后退节点设置成为x地址</div><div class="line">    else</div><div class="line">        zsl-&gt;tail = x;  //否则更新表头的tail指针，指向最尾部的节点x</div><div class="line">    zsl-&gt;length++;      //跳跃表节点计数器加1</div><div class="line">    return x;           //返回x地址</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-3-删除节点"><a href="#4-3-删除节点" class="headerlink" title="4.3 删除节点"></a>4.3 删除节点</h3><p>//被zslDelete, zslDeleteByScore and zslDeleteByRank使用的内部函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123;  //删除节点</div><div class="line">    int i;</div><div class="line"></div><div class="line">    //设置前进指针和跨度</div><div class="line">    for (i = 0; i &lt; zsl-&gt;level; i++) &#123;              //遍历下标为0到跳跃表最大层数-1的层</div><div class="line">        if (update[i]-&gt;level[i].forward == x) &#123;     //如果找到该节点</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;   //将前一个节点的跨度减1</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">            //前一个节点的前进指针指向被删除的节点的后一个节点，跳过该节点</div><div class="line">        &#125; else &#123;</div><div class="line">            update[i]-&gt;level[i].span -= 1;  //在第i层没找到，只将该层的最后一个节点的跨度减1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //设置后退指针</div><div class="line">    if (x-&gt;level[0].forward) &#123;      //如果被删除的前进节点不为空，后面还有节点</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;    //就将后面节点的后退指针指向被删除节点x的回退指针</div><div class="line">    &#125; else &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;       //否则直接将被删除的x节点的后退节点设置为表头的tail指针</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //更新跳跃表最大层数</div><div class="line">    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    zsl-&gt;length--;  //节点计数器减1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-4-获取节点排名"><a href="#4-4-获取节点排名" class="headerlink" title="4.4 获取节点排名"></a>4.4 获取节点排名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) &#123;   //查找score和o对象在跳跃表中的排位</div><div class="line">    zskiplistNode *x;</div><div class="line">    unsigned long rank = 0;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;        //遍历头结点的每一层</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||          //只要分值还小于给定的score或者</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;     //分值相等但是对象小于给定对象o</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= 0))) &#123;</div><div class="line">            rank += x-&gt;level[i].span;   //更新排位值</div><div class="line">            x = x-&gt;level[i].forward;    //指向下一个节点</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</div><div class="line">        //确保在第i层找到分值相同，且对象相同时才会返回排位值</div><div class="line">        if (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            return rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;   //没找到</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-5-区间操作"><a href="#4-5-区间操作" class="headerlink" title="4.5 区间操作"></a>4.5 区间操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) &#123; //返回第一个分数在range范围内的节点</div><div class="line">    zskiplistNode *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    /* If everything is out of range, return early. */</div><div class="line">    if (!zslIsInRange(zsl,range)) return NULL;  //如果不在范围内，则返回NULL，确保至少有一个节点符号range</div><div class="line"></div><div class="line">    //判断下限</div><div class="line">    x = zsl-&gt;header;//遍历跳跃表</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;//遍历每一层</div><div class="line">        /* Go forward while *OUT* of range. */</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;           //如果该层有下一个节点且</div><div class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))//当前节点的score还小于(小于等于)range的min</div><div class="line">                x = x-&gt;level[i].forward;        //继续指向下一个节点</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* This is an inner range, so the next node cannot be NULL. */</div><div class="line">    x = x-&gt;level[0].forward;    //找到目标节点</div><div class="line">    redisAssert(x != NULL);     //保证能找到</div><div class="line"></div><div class="line">    /* Check if score &lt;= max. */</div><div class="line">    //判断上限</div><div class="line">    if (!zslValueLteMax(x-&gt;score,range)) return NULL;   //该节点的分值如果比max还要大，就返回NULL</div><div class="line">    return x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) &#123;//返回最后一个分数在range范围内的节点</div><div class="line">    zskiplistNode *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    /* If everything is out of range, return early. */</div><div class="line">    if (!zslIsInRange(zsl,range)) return NULL;  //如果不在范围内，则返回NULL，确保至少有一个节点符号range</div><div class="line"></div><div class="line">    //判断上限</div><div class="line">    x = zsl-&gt;header;//遍历跳跃表</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;   //遍历每一层</div><div class="line">        /* Go forward while *IN* range. */</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;   //如果该层有下一个节点且</div><div class="line">            zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))//当前节点的score小于(小于等于)max</div><div class="line">                x = x-&gt;level[i].forward;    //继续指向下一个节点</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* This is an inner range, so this node cannot be NULL. */</div><div class="line">    redisAssert(x != NULL);//保证能找到</div><div class="line"></div><div class="line">    /* Check if score &gt;= min. */</div><div class="line">    //判断下限</div><div class="line">    if (!zslValueGteMin(x-&gt;score,range)) return NULL;   //如果找到的节点的分值比range的min还要小</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（三）---字典结构]]></title>
      <url>http://hlei.io/2018/02/04/redis-analysis-dict/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>字典又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。例如：redis中的所有key到value的映射，就是通过字典结构维护，还有hash类型的键值。</p>
<p>通过redis中的命令感受一下哈希键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HSET user name Mike </div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HSET user passwd 123456</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HSET user sex male</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; HLEN user       //user就是一个包含3个键值对的哈希键</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; HGETALL user</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;Mike&quot;</div><div class="line">3) &quot;passwd&quot;</div><div class="line">4) &quot;123456&quot;</div><div class="line">5) &quot;sex&quot;</div><div class="line">6) &quot;male&quot;</div></pre></td></tr></table></figure></p>
<p>user键在底层实现就是一个字典，字典包含3个键值对。</p>
<h2 id="2-字典的实现"><a href="#2-字典的实现" class="headerlink" title="2. 字典的实现"></a>2. 字典的实现</h2><p>redis的字典是由哈希表实现的，一个哈希表有多个节点，每个节点保存一个键值对。</p>
<h3 id="2-1-哈希表"><a href="#2-1-哈希表" class="headerlink" title="2.1 哈希表"></a>2.1 哈希表</h3><p>redis中哈希表定义在dict.h/dictht中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht &#123; //哈希表</div><div class="line">    dictEntry **table;      //存放一个数组的地址，数组存放着哈希表节点dictEntry的地址。</div><div class="line">    unsigned long size;     //哈希表table的大小，初始化大小为4</div><div class="line">    unsigned long sizemask; //用于将哈希值映射到table的位置索引。它的值总是等于(size-1)。</div><div class="line">    unsigned long used;     //记录哈希表已有的节点（键值对）数量。</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure></p>
<h3 id="2-2-哈希表节点"><a href="#2-2-哈希表节点" class="headerlink" title="2.2 哈希表节点"></a>2.2 哈希表节点</h3><p>哈希表的table指向的数组存放这dictEntry类型的地址。也定义在dict.h/dictEntryt中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ypedef struct dictEntry &#123;</div><div class="line">    void *key;                  //key</div><div class="line">    union &#123;</div><div class="line">        void *val;</div><div class="line">        uint64_t u64;</div><div class="line">        int64_t s64;</div><div class="line">        double d;</div><div class="line">    &#125; v;                        //value</div><div class="line">    struct dictEntry *next;     //指向下一个hash节点，用来解决hash键冲突（collision）</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure></p>
<p>下图展现的就是通过链接法（chaining）来解决冲突的方法。<br>[url01]</p>
<h3 id="2-3-字典"><a href="#2-3-字典" class="headerlink" title="2.3 字典"></a>2.3 字典</h3><p>字典结构定义在dict.h/dict中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct dict &#123;</div><div class="line">    dictType *type;     //指向dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据。</div><div class="line">    void *privdata;     //私有数据，保存着dictType结构中函数的参数。</div><div class="line">    dictht ht[2];       //两张哈希表。</div><div class="line">    long rehashidx;     //rehash的标记，rehashidx==-1，表示没在进行rehash</div><div class="line">    int iterators;      //正在迭代的迭代器数量</div><div class="line">&#125; dict;</div></pre></td></tr></table></figure></p>
<p>dictType类型保存着 操作字典不同类型key和value的方法 的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictType &#123;</div><div class="line">    unsigned int (*hashFunction)(const void *key);      //计算hash值的函数</div><div class="line">    void *(*keyDup)(void *privdata, const void *key);   //复制key的函数</div><div class="line">    void *(*valDup)(void *privdata, const void *obj);   //复制value的函数</div><div class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);  //比较key的函数</div><div class="line">    void (*keyDestructor)(void *privdata, void *key);   //销毁key的析构函数</div><div class="line">    void (*valDestructor)(void *privdata, void *obj);   //销毁val的析构函数</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure></p>
<p>下图展现的就是刚才命令user哈希键所展现的内部结构：<br>[url02]</p>
<h2 id="3-哈希算法"><a href="#3-哈希算法" class="headerlink" title="3. 哈希算法"></a>3. 哈希算法</h2><p>Thomas Wang认为好的hash函数具有两个好的特点：</p>
<ul>
<li>hash函数是可逆的。</li>
<li>具有雪崩效应，意思是，输入值1bit位的变化会造成输出值1/2的bit位发生变化</li>
</ul>
<h3 id="3-1-计算int整型哈希值的哈希函数"><a href="#3-1-计算int整型哈希值的哈希函数" class="headerlink" title="3.1 计算int整型哈希值的哈希函数"></a>3.1 计算int整型哈希值的哈希函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">unsigned int dictIntHashFunction(unsigned int key)      //用于计算int整型哈希值的哈希函数</div><div class="line">&#123;</div><div class="line">    key += ~(key &lt;&lt; 15);</div><div class="line">    key ^=  (key &gt;&gt; 10);</div><div class="line">    key +=  (key &lt;&lt; 3);</div><div class="line">    key ^=  (key &gt;&gt; 6);</div><div class="line">    key += ~(key &lt;&lt; 11);</div><div class="line">    key ^=  (key &gt;&gt; 16);</div><div class="line">    return key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-MurmurHash2哈希算法"><a href="#3-2-MurmurHash2哈希算法" class="headerlink" title="3.2 MurmurHash2哈希算法"></a>3.2 MurmurHash2哈希算法</h3><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis用MurmurHash2算法来计算哈希值，能产生32-bit或64-bit哈希值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">unsigned int dictGenHashFunction(const void *key, int len) &#123;  //用于计算字符串的哈希值的哈希函数</div><div class="line">    /* &apos;m&apos; and &apos;r&apos; are mixing constants generated offline.</div><div class="line">     They&apos;re not really &apos;magic&apos;, they just happen to work well.  */</div><div class="line">    //m和r这两个值用于计算哈希值，只是因为效果好。</div><div class="line">    uint32_t seed = dict_hash_function_seed;</div><div class="line">    const uint32_t m = 0x5bd1e995;</div><div class="line">    const int r = 24;</div><div class="line"></div><div class="line">    /* Initialize the hash to a &apos;random&apos; value */</div><div class="line">    uint32_t h = seed ^ len;    //初始化</div><div class="line"></div><div class="line">    /* Mix 4 bytes at a time into the hash */</div><div class="line">    const unsigned char *data = (const unsigned char *)key;</div><div class="line"></div><div class="line">    //将字符串key每四个一组看成uint32_t类型，进行运算的到h</div><div class="line">    while(len &gt;= 4) &#123;</div><div class="line">        uint32_t k = *(uint32_t*)data;</div><div class="line"></div><div class="line">        k *= m;</div><div class="line">        k ^= k &gt;&gt; r;</div><div class="line">        k *= m;</div><div class="line"></div><div class="line">        h *= m;</div><div class="line">        h ^= k;</div><div class="line"></div><div class="line">        data += 4;</div><div class="line">        len -= 4;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Handle the last few bytes of the input array  */</div><div class="line">    switch(len) &#123;</div><div class="line">    case 3: h ^= data[2] &lt;&lt; 16;</div><div class="line">    case 2: h ^= data[1] &lt;&lt; 8;</div><div class="line">    case 1: h ^= data[0]; h *= m;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    /* Do a few final mixes of the hash to ensure the last few</div><div class="line">     * bytes are well-incorporated. */</div><div class="line">    h ^= h &gt;&gt; 13;</div><div class="line">    h *= m;</div><div class="line">    h ^= h &gt;&gt; 15;</div><div class="line"></div><div class="line">    return (unsigned int)h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-djb哈希算法"><a href="#3-3-djb哈希算法" class="headerlink" title="3.3 djb哈希算法"></a>3.3 djb哈希算法</h3><p>djb哈希算法，算法的思想是利用字符串中的ascii码值与一个随机seed，通过len次变换，得到最后的hash值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) &#123;   //用于计算字符串的哈希值的哈希函数</div><div class="line">    unsigned int hash = (unsigned int)dict_hash_function_seed;</div><div class="line"></div><div class="line">    while (len--)</div><div class="line">        hash = ((hash &lt;&lt; 5) + hash) + (tolower(*buf++)); /* hash * 33 + c */</div><div class="line">    return hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-rehash"><a href="#4-rehash" class="headerlink" title="4. rehash"></a>4. rehash</h2><p>当哈希表的大小不能满足需求，就可能会有两个或者以上数量的键被分配到了哈希表数组上的同一个索引上，于是就发生冲突（collision），在Redis中解决冲突的办法是链接法（separate chaining）。但是需要尽可能避免冲突，希望哈希表的负载因子（load factor），维持在一个合理的范围之内，就需要对哈希表进行扩展或收缩。</p>
<p>Redis对哈希表的rehash操作步骤如下：</p>
<ul>
<li>扩展或收缩 <ul>
<li>扩展：ht[1]的大小为第一个大于等于ht[0].used * 2的 2n 。</li>
<li>收缩：ht[1]的大小为第一个大于等于ht[0].used的 2n 。</li>
</ul>
</li>
<li>将所有的ht[0]上的节点rehash到ht[1]上。</li>
<li>释放ht[0]，将ht[1]设置为第0号表，并创建新的ht[1]。</li>
</ul>
<p>源码：</p>
<ul>
<li><p>扩展操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static int _dictExpandIfNeeded(dict *d) //扩展d字典，并初始化</div><div class="line">&#123;</div><div class="line">    /* Incremental rehashing already in progress. Return. */</div><div class="line">    if (dictIsRehashing(d)) return DICT_OK;     //正在进行rehash，直接返回</div><div class="line"></div><div class="line">    /* If the hash table is empty expand it to the initial size. */</div><div class="line">    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE); //如果字典（的 0 号哈希表）为空，那么创建并返回初始化大小的 0 号哈希表</div><div class="line"></div><div class="line">    /* If we reached the 1:1 ratio, and we are allowed to resize the hash</div><div class="line">     * table (global setting) or we should avoid it but the ratio between</div><div class="line">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</div><div class="line">     * the number of buckets. */</div><div class="line">    //1. 字典已使用节点数和字典大小之间的比率接近 1：1</div><div class="line">    //2. 能够扩展的标志为真</div><div class="line">    //3. 已使用节点数和字典大小之间的比率超过 dict_force_resize_ratio</div><div class="line">    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp; (dict_can_resize ||    </div><div class="line">         d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))    </div><div class="line">    &#123;</div><div class="line">        return dictExpand(d, d-&gt;ht[0].used*2);  //扩展为节点个数的2倍</div><div class="line">    &#125;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>收缩操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int dictResize(dict *d)     //缩小字典d</div><div class="line">&#123;</div><div class="line">    int minimal;</div><div class="line"></div><div class="line">    //如果dict_can_resize被设置成0，表示不能进行rehash，或正在进行rehash，返回出错标志DICT_ERR</div><div class="line">    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;</div><div class="line"></div><div class="line">    minimal = d-&gt;ht[0].used;            //获得已经有的节点数量作为最小限度minimal</div><div class="line">    if (minimal &lt; DICT_HT_INITIAL_SIZE)//但是minimal不能小于最低值DICT_HT_INITIAL_SIZE（4）</div><div class="line">        minimal = DICT_HT_INITIAL_SIZE;</div><div class="line">    return dictExpand(d, minimal);      //用minimal调整字典d的大小</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>扩展和收缩操作都调用了dictExpand()函数，该函数通过计算传入的第二个大小参数进行计算，算出一个最接近2n的realsize，然后进行扩展或收缩，dictExpand()函数源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">int dictExpand(dict *d, unsigned long size)     //根据size调整或创建字典d的哈希表</div><div class="line">&#123;</div><div class="line">    dictht n; /* the new hash table */</div><div class="line">    unsigned long realsize = _dictNextPower(size);  //获得一个最接近2^n的realsize</div><div class="line"></div><div class="line">    /* the size is invalid if it is smaller than the number of</div><div class="line">     * elements already inside the hash table */</div><div class="line">    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size) //正在rehash或size不够大返回出错标志</div><div class="line">        return DICT_ERR;</div><div class="line"></div><div class="line">    /* Rehashing to the same table size is not useful. */</div><div class="line">    if (realsize == d-&gt;ht[0].size) return DICT_ERR; //如果新的realsize和原本的size一样则返回出错标志</div><div class="line">    /* Allocate the new hash table and initialize all pointers to NULL */</div><div class="line">    //初始化新的哈希表的成员</div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize-1;</div><div class="line">    n.table = zcalloc(realsize*sizeof(dictEntry*));</div><div class="line">    n.used = 0;</div><div class="line"></div><div class="line">    /* Is this the first initialization? If so it&apos;s not really a rehashing</div><div class="line">     * we just set the first hash table so that it can accept keys. */</div><div class="line">    if (d-&gt;ht[0].table == NULL) &#123;   //如果ht[0]哈希表为空，则将新的哈希表n设置为ht[0]</div><div class="line">        d-&gt;ht[0] = n;</div><div class="line">        return DICT_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Prepare a second hash table for incremental rehashing */</div><div class="line">    d-&gt;ht[1] = n;           //如果ht[0]非空，则需要rehash</div><div class="line">    d-&gt;rehashidx = 0;       //设置rehash标志位为0，开始渐进式rehash（incremental rehashing）</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>收缩或者扩展哈希表需要将ht[0]表中的所有键全部rehash到ht[1]中，但是rehash操作不是一次性、集中式完成的，而是分多次，渐进式，断续进行的，这样才不会对服务器性能造成影响。因此下面介绍渐进式rehash。</p>
<h2 id="5-渐进式rehash（incremental-rehashing）"><a href="#5-渐进式rehash（incremental-rehashing）" class="headerlink" title="5. 渐进式rehash（incremental rehashing）"></a>5. 渐进式rehash（incremental rehashing）</h2><p>渐进式rehash的关键：</p>
<ol>
<li>字典结构dict中的一个成员rehashidx，当rehashidx为-1时表示不进行rehash，当rehashidx值为0时，表示开始进行rehash。</li>
<li>在rehash期间，每次对字典的添加、删除、查找、或更新操作时，都会判断是否正在进行rehash操作，如果是，则顺带进行单步rehash，并将rehashidx+1。</li>
<li>当rehash时进行完成时，将rehashidx置为-1，表示完成rehash。</li>
</ol>
<p>源码在此：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">static void _dictRehashStep(dict *d) &#123;      //单步rehash</div><div class="line">    if (d-&gt;iterators == 0) dictRehash(d,1); //当迭代器数量不为0，才能进行1步rehash</div><div class="line">&#125;</div><div class="line"></div><div class="line">int dictRehash(dict *d, int n) &#123;       //n步进行rehash</div><div class="line">    int empty_visits = n*10; /* Max number of empty buckets to visit. */</div><div class="line">    if (!dictIsRehashing(d)) return 0;  //只有rehashidx不等于-1时，才表示正在进行rehash，否则返回0</div><div class="line"></div><div class="line">    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;  //分n步，而且ht[0]上还有没有移动的节点</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        /* Note that rehashidx can&apos;t overflow as we are sure there are more</div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        //确保rehashidx没有越界，因为rehashidx是从-1开始，0表示已经移动1个节点，它总是小于hash表的size的</div><div class="line">        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</div><div class="line"></div><div class="line">        //第一个循环用来更新 rehashidx 的值，因为有些桶为空，所以 rehashidx并非每次都比原来前进一个位置，而是有可能前进几个位置，但最多不超过 10。</div><div class="line">        //将rehashidx移动到ht[0]有节点的下标，也就是table[d-&gt;rehashidx]非空</div><div class="line">        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            if (--empty_visits == 0) return 1;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[0].table[d-&gt;rehashidx];     //ht[0]下标为rehashidx有节点，得到该节点的地址</div><div class="line">        /* Move all the keys in this bucket from the old to the new hash HT */</div><div class="line">        //第二个循环用来将ht[0]表中每次找到的非空桶中的链表（或者就是单个节点）拷贝到ht[1]中</div><div class="line">        while(de) &#123;</div><div class="line">            unsigned int h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;  //备份下一个节点的地址</div><div class="line">            /* Get the index in the new hash table */</div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;    //获得计算哈希值并得到哈希表中的下标h</div><div class="line"></div><div class="line">            //将该节点插入到下标为h的位置</div><div class="line">            de-&gt;next = d-&gt;ht[1].table[h];</div><div class="line">            d-&gt;ht[1].table[h] = de;</div><div class="line"></div><div class="line">            //更新两个表节点数目计数器</div><div class="line">            d-&gt;ht[0].used--;</div><div class="line">            d-&gt;ht[1].used++;</div><div class="line"></div><div class="line">            //将de指向以一个处理的节点</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;    //迁移过后将该下标的指针置为空</div><div class="line">        d-&gt;rehashidx++;                         //更新rehashidx</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if we already rehashed the whole table... */</div><div class="line">    if (d-&gt;ht[0].used == 0) &#123;           //ht[0]上已经没有节点了，说明已经迁移完成</div><div class="line">        zfree(d-&gt;ht[0].table);          //释放hash表内存</div><div class="line">        d-&gt;ht[0] = d-&gt;ht[1];            //将迁移过的1号哈希表设置为0号哈希表</div><div class="line">        _dictReset(&amp;d-&gt;ht[1]);          //重置ht[1]哈希表</div><div class="line">        d-&gt;rehashidx = -1;              //rehash标志关闭</div><div class="line">        return 0;                       //表示前已完成</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* More to rehash... */</div><div class="line">    return 1;           //表示还有节点等待迁移</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6. 迭代器"></a>6. 迭代器</h2><p>redis在字典结构也定义了迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictIterator &#123;</div><div class="line">    dict *d;                    //被迭代的字典</div><div class="line">    long index;                 //迭代器当前所指向的哈希表索引位置</div><div class="line">    int table, safe;            //table表示正迭代的哈希表号码，ht[0]或ht[1]。safe表示这个迭代器是否安全。</div><div class="line">    dictEntry *entry, *nextEntry;   //entry指向当前迭代的哈希表节点，nextEntry则指向当前节点的下一个节点。</div><div class="line">    /* unsafe iterator fingerprint for misuse detection. */</div><div class="line">    long long fingerprint;      //避免不安全迭代器的指纹标记</div><div class="line">&#125; dictIterator;</div></pre></td></tr></table></figure></p>
<p>迭代器分为安全迭代器和不安全迭代器：</p>
<p>非安全迭代器只能进行Get等读的操作, 而安全迭代器则可以进行iterator支持的任何操作。<br>由于dict结构中保存了safe iterators的数量，如果数量不为0， 是不能进行下一步的rehash的; 因此安全迭代器的存在保证了遍历数据的准确性。<br>在非安全迭代器的迭代过程中, 会通过fingerprint方法来校验iterator在初始化与释放时字典的hash值是否一致; 如果不一致说明迭代过程中发生了非法操作.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（二）---简单动态字符串]]></title>
      <url>http://hlei.io/2018/02/04/redis-analysis-sds/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>Redis兼容传统的C语言字符串类型，但没有直接使用C语言的传统的字符串（以’\0’结尾的字符数组）表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的对象。简单动态字符串在Redis数据库中应用很广泛，例如：键值对在底层就是由SDS实现的。</p>
<p>在redis种，有一种数据类型叫string类型，而string类型简单的说就是SDS实现的（简单理解），先通过几个命令来感受一下string类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET str1 Redis  //设置key:value = str1:Redis</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GET str1        //获取str1的value</div><div class="line">&quot;Redis&quot;</div><div class="line">127.0.0.1:6379&gt; TYPE str1       //获取key的存储类型 string类型</div><div class="line">string</div><div class="line">127.0.0.1:6379&gt; STRLEN str1     //str1的长度为5字节</div><div class="line">(integer) 5</div></pre></td></tr></table></figure></p>
<h2 id="2-SDS的定义"><a href="#2-SDS的定义" class="headerlink" title="2.SDS的定义"></a>2.SDS的定义</h2><p>SDS定义在redis源码根目录下的sds.h/sdshdr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef char *sds;  </div><div class="line">//sds兼容传统C风格字符串，所以起了个别名叫sds，并且可以存放sdshdr结构buf成员的地址</div></pre></td></tr></table></figure></p>
<p>SDS也有一个表头（header）用来存放sds的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct sdshdr &#123;</div><div class="line">    int len;        //buf中已占用空间的长度</div><div class="line">    int free;       //buf中剩余可用空间的长度</div><div class="line">    char buf[];     //初始化sds分配的数据空间，而且是柔性数组（Flexible array member）</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>根据这个结构体，我们用图大概表示一下str1，如下图：<br><img src="/2018/02/04/redis-analysis-s2s/redis-sds01.jpg" alt="sdshdr"></p>
<p>这里写图片描述</p>
<ul>
<li>len为5，表示这个sds长度为5字节。</li>
<li>free为2，表示这个sds还有2个字节未使用的空间。</li>
<li>buf是一个char[]的数组，分配了（len+1+free）个字节的长度，前len个字节保存着’R’、’e’、’d’、’i’、’s’这5个字符，接下来的1个字节保存着’\0’，剩下的free个字节未使用</li>
</ul>
<h2 id="3-SDS的优点"><a href="#3-SDS的优点" class="headerlink" title="3. SDS的优点"></a>3. SDS的优点</h2><p>SDS本质上就是char *，因为有了表头sdshdr结构的存在，所以SDS比传统C字符串在某些方面更加优秀，并且能够兼容传统C字符串。</p>
<h2 id="3-1-兼容C的部分函数"><a href="#3-1-兼容C的部分函数" class="headerlink" title="3.1 兼容C的部分函数"></a>3.1 兼容C的部分函数</h2><p>因为SDS兼容传统的C字符串，采用以’\0’作为结尾，所以SDS就能够使用一部分</p>
<h2 id="3-2-二进制安全（Binary-Safe）"><a href="#3-2-二进制安全（Binary-Safe）" class="headerlink" title="3.2 二进制安全（Binary Safe）"></a>3.2 二进制安全（Binary Safe）</h2><p>因为传统C字符串符合ASCII编码，这种编码的操作的特点就是：遇零则止 。即，当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片，视频等二进制文件，操作文件时就被截断了。</p>
<p>而SDS表头的buf被定义为字节数组，因为判断是否到达字符串结尾的依据则是表头的len成员，这意味着它可以存放任何二进制的数据和文本数据，包括’\0’，如下图：<br><img src="/2018/02/04/redis-analysis-s2s/redis-sds02.jpg" alt="buf"></p>
<h2 id="3-3-获得字符串长度的操作复杂度为O-1"><a href="#3-3-获得字符串长度的操作复杂度为O-1" class="headerlink" title="3.3 获得字符串长度的操作复杂度为O(1)"></a>3.3 获得字符串长度的操作复杂度为O(1)</h2><p>传统的C字符串获得长度时的做法：遍历字符串的长度，遇零则止，复杂度为O(n)。</p>
<p>而SDS表头的len成员就保存着字符串长度，所以获得字符串长度的操作复杂度为O(1)。</p>
<h2 id="3-4-杜绝缓冲区溢出"><a href="#3-4-杜绝缓冲区溢出" class="headerlink" title="3.4 杜绝缓冲区溢出"></a>3.4 杜绝缓冲区溢出</h2><p>因为SDS表头的free成员记录着buf字符数组中未使用空间的字节数，所以，在进行APPEND命令向字符串后追加字符串时，如果不够用会先进行内存扩展，在进行追加。</p>
<p>总之，正是因为表头的存在，使得redis的字符串有这么多优点</p>
<h2 id="4-SDS源码剖析"><a href="#4-SDS源码剖析" class="headerlink" title="4. SDS源码剖析"></a>4. SDS源码剖析</h2><h3 id="4-1-SDS内存分配策略—空间预分配"><a href="#4-1-SDS内存分配策略—空间预分配" class="headerlink" title="4.1 SDS内存分配策略—空间预分配"></a>4.1 SDS内存分配策略—空间预分配</h3><p>空间预分配策略用于优化SDS的字符串增长操作。</p>
<p>如果对SDS进行修改后，SDS表头的len成员小于1MB，那么就会分配和len长度相同的未使用空间。free和len成员大小相等。<br>如果对SDS进行修改后，SDS的长度大于等于1MB，那么就会分配1MB的未使用空间。<br>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">sds sdsMakeRoomFor(sds s, size_t addlen) &#123;      //对 sds 中 buf 的长度进行扩展</div><div class="line">    struct sdshdr *sh, *newsh;</div><div class="line">    size_t free = sdsavail(s);  //获得s的未使用空间长度</div><div class="line">    size_t len, newlen;</div><div class="line"></div><div class="line">    //free的长度够用不用扩展直接返回</div><div class="line">    if (free &gt;= addlen) return s;  </div><div class="line"></div><div class="line">    //free长度不够用，需要扩展</div><div class="line">    len = sdslen(s);    //获得s字符串的长度</div><div class="line">    sh = (void*) (s-(sizeof(struct sdshdr)));       //获取表头地址</div><div class="line">    newlen = (len+addlen);  //扩展后的新长度</div><div class="line"></div><div class="line">    //空间预分配     </div><div class="line">    //#define SDS_MAX_PREALLOC (1024*1024)  </div><div class="line">    //预先分配内存的最大长度为 1MB</div><div class="line">    if (newlen &lt; SDS_MAX_PREALLOC)  //新长度小于“最大预分配长度”，就直接将扩展的新长度乘2</div><div class="line">        newlen *= 2;</div><div class="line">    else</div><div class="line">        newlen += SDS_MAX_PREALLOC; //新长度大于“最大预分配长度”，就在加上一个“最大预分配长度”</div><div class="line">    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);   //获得新的扩展空间的地址</div><div class="line">    if (newsh == NULL) return NULL;</div><div class="line"></div><div class="line">    newsh-&gt;free = newlen - len; //更新新空间的未使用的空间free</div><div class="line">    return newsh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-2-SDS内存释放策略—惰性空间释放"><a href="#4-2-SDS内存释放策略—惰性空间释放" class="headerlink" title="4.2 SDS内存释放策略—惰性空间释放"></a>4.2 SDS内存释放策略—惰性空间释放</h3><p>惰性空间释放用于优化SDS的字符串缩短操作。</p>
<ul>
<li>当要缩短SDS保存的字符串时，程序并不立即使用内存充分配来回收缩短后多出来的字节，而是使用表头的free成员将这些字节记录起来，并等待将来使用。<br>源代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void sdsclear(sds s) &#123;  //重置sds的buf空间，懒惰释放</div><div class="line">    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));</div><div class="line">    sh-&gt;free += sh-&gt;len;    //表头free成员+已使用空间的长度len = 新的free</div><div class="line">    sh-&gt;len = 0;            //已使用空间变为0</div><div class="line">    sh-&gt;buf[0] = &apos;\0&apos;;         //字符串置空</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-3-Redis源码注释"><a href="#4-3-Redis源码注释" class="headerlink" title="4.3 Redis源码注释"></a>4.3 Redis源码注释</h3><ol>
<li><p>在sds.h文件中，有两个static inline的函数，分别是sdslen和sdsavail函数，你可以把它认为是一个static的函数，加上了inline的属性。而inline关键字仅仅是建议编译器做内联展开处理，而不是强制。</p>
</li>
<li><p>在sds.c中，几乎所有的函数所传的参数都是sds类型，而非表头sdshdr的地址，但是使用了通过sds指针运算从而求得表头的地址的技巧，因为sds是指向sdshdr结构buf成员的。通过sds.h/sdslen函数，来分析：</p>
</li>
</ol>
<p>这里的关键就是sds类型是指向sdshdr结构buf成员。</p>
<ul>
<li>struct sdshdr结构共有三个变量，其中sds指向的buf成员是一个柔性数组，它仅仅起到占位符的作用，并不占用该结构体的大小，因此sizeof(sizeof(struct sdshdr))大小为8字节。</li>
<li>由于一个SDS类型的内存是通过动态内存分配的，所以它的内存在堆区，堆由下往上增长，因此sds指针减区sizeof(struct sdshdr)的大小就得到了表头的地址，然后就可以通过”-&gt;”访问表头的成员。如下图：<br><img src="/2018/02/04/redis-analysis-s2s/redis-sds03.jpg" alt="sds&amp;sdshdr"><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static inline size_t sdslen(const sds s) &#123;      //计算buf中字符串的长度</div><div class="line"></div><div class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); //s指针地址减去结构体大小就是结构体的地址</div><div class="line"></div><div class="line">   return sh-&gt;len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过这种技巧，将表头结构隐藏起来，只对外公开sds类型。</p>
<ul>
<li>sds.h文件注释<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#ifndef __SDS_H</div><div class="line">#define __SDS_H</div><div class="line"></div><div class="line">#define SDS_MAX_PREALLOC (1024*1024)    //预先分配内存的最大长度为1MB</div><div class="line"></div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line"></div><div class="line">typedef char *sds;  //sds兼容传统C风格字符串，所以起了个别名叫sds，并且可以存放sdshdr结构buf成员的地址</div><div class="line"></div><div class="line">struct sdshdr &#123;</div><div class="line">    unsigned int len;   //buf中已占用空间的长度</div><div class="line">    unsigned int free;  //buf中剩余可用空间的长度</div><div class="line">    char buf[];         //初始化sds分配的数据空间，而且是柔性数组（Flexible array member）</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static inline size_t sdslen(const sds s) &#123;      //计算buf中字符串的长度</div><div class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));</div><div class="line">    return sh-&gt;len;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline size_t sdsavail(const sds s) &#123;    //计算buf中的未使用空间的长度</div><div class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));</div><div class="line">    return sh-&gt;free;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sds sdsnewlen(const void *init, size_t initlen);    //创建一个长度为initlen的字符串,并保存init字符串中的值</div><div class="line">sds sdsnew(const char *init);       //创建一个默认长度的字符串</div><div class="line">sds sdsempty(void);     //建立一个只有表头，字符串为空&quot;\0&quot;的sds</div><div class="line">size_t sdslen(const sds s); //计算buf中字符串的长度</div><div class="line">sds sdsdup(const sds s);    //拷贝一份s的副本</div><div class="line">void sdsfree(sds s);     //释放s字符串和表头</div><div class="line">size_t sdsavail(const sds s);   //计算buf中的未使用空间的长度</div><div class="line">sds sdsgrowzero(sds s, size_t len); //将sds扩展制定长度并赋值为0</div><div class="line">sds sdscatlen(sds s, const void *t, size_t len);    //将字符串t追加到s表头的buf末尾，追加len个字节</div><div class="line">sds sdscat(sds s, const char *t);       //将t字符串拼接到s的末尾</div><div class="line">sds sdscatsds(sds s, const sds t);      //将sds追加到s末尾</div><div class="line">sds sdscpylen(sds s, const char *t, size_t len);    //将字符串t覆盖到s表头的buf中，拷贝len个字节</div><div class="line">sds sdscpy(sds s, const char *t);       //将字符串覆盖到s表头的buf中</div><div class="line"></div><div class="line">sds sdscatvprintf(sds s, const char *fmt, va_list ap);  //打印函数，被 sdscatprintf 所调用</div><div class="line">#ifdef __GNUC__</div><div class="line">sds sdscatprintf(sds s, const char *fmt, ...)   //打印任意数量个字符串，并将这些字符串追加到给定 sds 的末尾</div><div class="line">    __attribute__((format(printf, 2, 3)));</div><div class="line">#else</div><div class="line">sds sdscatprintf(sds s, const char *fmt, ...);  //打印任意数量个字符串，并将这些字符串追加到给定 sds 的末尾</div><div class="line">#endif</div><div class="line"></div><div class="line">sds sdscatfmt(sds s, char const *fmt, ...); //格式化打印多个字符串，并将这些字符串追加到给定 sds 的末尾</div><div class="line">sds sdstrim(sds s, const char *cset);   //去除sds中包含有 cset字符串出现字符 的字符</div><div class="line">void sdsrange(sds s, int start, int end);   //根据start和end区间截取字符串</div><div class="line">void sdsupdatelen(sds s);           //更新字符串s的长度</div><div class="line">void sdsclear(sds s);               //将字符串重置保存空间，懒惰释放</div><div class="line">int sdscmp(const sds s1, const sds s2);     //比较两个sds的大小，相等返回0</div><div class="line">sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);  //使用长度为seplen的sep分隔符对长度为len的s进行分割，返回一个sds数组的地址，*count被设置为数组元素数量</div><div class="line">void sdsfreesplitres(sds *tokens, int count); //释放tokens中的count个sds元素</div><div class="line">void sdstolower(sds s);     //将sds字符串所有字符转换为小写</div><div class="line">void sdstoupper(sds s);     //将sds字符串所有字符转换为大写</div><div class="line">sds sdsfromlonglong(long long value);       //根据long long value创建一个SDS</div><div class="line">sds sdscatrepr(sds s, const char *p, size_t len);   //将长度为len的字符串p以带引号&quot;&quot;的格式追加到s末尾</div><div class="line">sds *sdssplitargs(const char *line, int *argc); //参数拆分,主要用于 config.c 中对配置文件进行分析。</div><div class="line">sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);    //将s中所有在 from 中的字符串，替换成 to 中的字符串</div><div class="line">sds sdsjoin(char **argv, int argc, char *sep);  //以分隔符连接字符串子数组构成新的字符串</div><div class="line"></div><div class="line">/* Low level functions exposed to the user API */</div><div class="line">sds sdsMakeRoomFor(sds s, size_t addlen);   //对 sds 中 buf 的长度进行扩展</div><div class="line">void sdsIncrLen(sds s, int incr);       //根据incr的正负，移动字符串末尾的&apos;\0&apos;标志</div><div class="line">sds sdsRemoveFreeSpace(sds s);      //回收sds中的未使用空间</div><div class="line">size_t sdsAllocSize(sds s);      //获得sds所有分配的空间</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[谈谈Java并发（二）]]></title>
      <url>http://hlei.io/2018/01/03/java-concurrent02/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/shamo89/p/6684960.html" target="_blank" rel="external">http://www.cnblogs.com/shamo89/p/6684960.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class Concurrent &#123;</div><div class="line"></div><div class="line">    public final static int THREAD_POOL_SIZE = 5;</div><div class="line"></div><div class="line">    public static Map&lt;String, Integer&gt; crunchifyHashTableObject = null;</div><div class="line">    public static Map&lt;String, Integer&gt; crunchifySynchronizedMapObject = null;</div><div class="line">    public static Map&lt;String, Integer&gt; crunchifyConcurrentHashMapObject = null;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line"></div><div class="line">        // Test with Hashtable Object</div><div class="line">        crunchifyHashTableObject = new Hashtable&lt;String, Integer&gt;();</div><div class="line">        crunchifyPerformTest(crunchifyHashTableObject);</div><div class="line"></div><div class="line">        // Test with synchronizedMap Object</div><div class="line">        crunchifySynchronizedMapObject = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;());</div><div class="line">        crunchifyPerformTest(crunchifySynchronizedMapObject);</div><div class="line"></div><div class="line">        // Test with ConcurrentHashMap Object</div><div class="line">        crunchifyConcurrentHashMapObject = new ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line">        crunchifyPerformTest(crunchifyConcurrentHashMapObject);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void crunchifyPerformTest(final Map&lt;String, Integer&gt; crunchifyThreads) throws InterruptedException &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;Test started for: &quot; + crunchifyThreads.getClass());</div><div class="line">        long averageTime = 0;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line"></div><div class="line">            long startTime = System.nanoTime();</div><div class="line">            ExecutorService crunchifyExServer = Executors.newFixedThreadPool(THREAD_POOL_SIZE);</div><div class="line"></div><div class="line">            for (int j = 0; j &lt; THREAD_POOL_SIZE; j++) &#123;</div><div class="line">                crunchifyExServer.execute(new Runnable() &#123;</div><div class="line">                    @SuppressWarnings(&quot;unused&quot;)</div><div class="line">                    public void run() &#123;</div><div class="line"></div><div class="line">                        for (int i = 0; i &lt; 500000; i++) &#123;</div><div class="line">                            Integer crunchifyRandomNumber = (int) Math.ceil(Math.random() * 550000);</div><div class="line"></div><div class="line">                            // Retrieve value. We are not using it anywhere</div><div class="line">                            Integer crunchifyValue = crunchifyThreads.get(String.valueOf(crunchifyRandomNumber));</div><div class="line"></div><div class="line">                            // Put value</div><div class="line">                            crunchifyThreads.put(String.valueOf(crunchifyRandomNumber), crunchifyRandomNumber);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Make sure executor stops</div><div class="line">            crunchifyExServer.shutdown();</div><div class="line"></div><div class="line">            // Blocks until all tasks have completed execution after a shutdown request</div><div class="line">            crunchifyExServer.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);</div><div class="line"></div><div class="line">            long entTime = System.nanoTime();</div><div class="line">            long totalTime = (entTime - startTime) / 1000000L;</div><div class="line">            averageTime += totalTime;</div><div class="line">            System.out.println(&quot;2500K entried added/retrieved in &quot; + totalTime + &quot; ms&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;For &quot; + crunchifyThreads.getClass() + &quot; the average time is &quot; + averageTime / 5 + &quot; ms\n&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Test started for: class java.util.Hashtable</div><div class="line">2500K entried added/retrieved in 2585 ms</div><div class="line">2500K entried added/retrieved in 1645 ms</div><div class="line">2500K entried added/retrieved in 1612 ms</div><div class="line">2500K entried added/retrieved in 1615 ms</div><div class="line">2500K entried added/retrieved in 1611 ms</div><div class="line">For class java.util.Hashtable the average time is 1813 ms</div><div class="line"></div><div class="line">Test started for: class java.util.Collections$SynchronizedMap</div><div class="line">2500K entried added/retrieved in 2186 ms</div><div class="line">2500K entried added/retrieved in 1730 ms</div><div class="line">2500K entried added/retrieved in 1735 ms</div><div class="line">2500K entried added/retrieved in 1693 ms</div><div class="line">2500K entried added/retrieved in 1435 ms</div><div class="line">For class java.util.Collections$SynchronizedMap the average time is 1755 ms</div><div class="line"></div><div class="line">Test started for: class java.util.concurrent.ConcurrentHashMap</div><div class="line">2500K entried added/retrieved in 941 ms</div><div class="line">2500K entried added/retrieved in 2475 ms</div><div class="line">2500K entried added/retrieved in 768 ms</div><div class="line">2500K entried added/retrieved in 641 ms</div><div class="line">2500K entried added/retrieved in 770 ms</div><div class="line">For class java.util.concurrent.ConcurrentHashMap the average time is 1119 ms</div></pre></td></tr></table></figure></p>
<p>性能表现：ConcurrentHashMap &gt; SynchronizedMap &gt; Hashtable</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[谈谈Java并发（一）]]></title>
      <url>http://hlei.io/2017/12/15/java-concurrent01/</url>
      <content type="html"><![CDATA[<p>SimpleDateFormat是一个常用的类日期格式化类，这个类不是线程安全的，在多线程环境下调用 format() 和 parse() 方法应该使用同步代码来避免问题。也借由这个问题，进一步来探讨下如何在多线程并发执行的程序中写出安全、高效的代码。</p>
<p>##发现问题<br>例如我们要把时间格式化后再使用，很容易我们可以写出这样一个DateUtil，每次处理一个请求的时候，就需要创建一个SimpleDateFormat实例对象，然后再丢弃这个对象。大量的对象就这样被创建出来，占用大量的内存和jvm空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DateUtil &#123;</div><div class="line">    </div><div class="line">    public static  String formatDate(Date date)throws ParseException&#123;</div><div class="line">         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        return sdf.format(date);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Date parse(String strDate) throws ParseException&#123;</div><div class="line">         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        return sdf.parse(strDate);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你也许会说，OK，那我就创建一个静态的simpleDateFormat实例，然后放到一个DateUtil类（如下）<br>中，在使用时直接使用这个实例进行操作，这样问题就解决了。改进后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.peidasoft.dateformat;</div><div class="line"></div><div class="line">import java.text.ParseException;</div><div class="line">import java.text.SimpleDateFormat;</div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class DateUtil &#123;</div><div class="line">    private static final  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">    </div><div class="line">    public static  String formatDate(Date date)throws ParseException&#123;</div><div class="line">        return sdf.format(date);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Date parse(String strDate) throws ParseException&#123;</div><div class="line"></div><div class="line">        return sdf.parse(strDate);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，这个方法的确很不错，在大部分的时间里面都会工作得很好。但当你在生产环境中使用一段时间之后，你就会发现这么一个事实：它不是线程安全的。在正常的测试情况之下，都没有问题，但一旦在生产环境中一定负载情况下时，这个问题就出来了。他会出现各种不同的情况，比如转化的时间不正确，比如报错，比如线程被挂死等等。我们看下面的测试用例，那事实说话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class DateUtilTest &#123;</div><div class="line">    </div><div class="line">    public static class TestSimpleDateFormatThreadSafe extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while(true) &#123;</div><div class="line">                try &#123;</div><div class="line">                    this.join(2000);</div><div class="line">                &#125; catch (InterruptedException e1) &#123;</div><div class="line">                    e1.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(this.getName()+&quot;:&quot;+DateUtil.parse(&quot;2013-05-24 06:02:20&quot;));</div><div class="line">                &#125; catch (ParseException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        for(int i = 0; i &lt; 3; i++)&#123;</div><div class="line">            new TestSimpleDateFormatThreadSafe().start();</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>执行输出如下：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;Thread-1&quot; java.lang.NumberFormatException: multiple points</div><div class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1082)</div><div class="line">    at java.lang.Double.parseDouble(Double.java:510)</div><div class="line">    at java.text.DigitList.getDouble(DigitList.java:151)</div><div class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1302)</div><div class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1589)</div><div class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1311)</div><div class="line">    at java.text.DateFormat.parse(DateFormat.java:335)</div><div class="line">    at com.peidasoft.orm.dateformat.DateNoStaticUtil.parse(DateNoStaticUtil.java:17)</div><div class="line">    at com.peidasoft.orm.dateformat.DateUtilTest$TestSimpleDateFormatThreadSafe.run(DateUtilTest.java:20)</div><div class="line">Exception in thread &quot;Thread-0&quot; java.lang.NumberFormatException: multiple points</div><div class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1082)</div><div class="line">    at java.lang.Double.parseDouble(Double.java:510)</div><div class="line">    at java.text.DigitList.getDouble(DigitList.java:151)</div><div class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1302)</div><div class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1589)</div><div class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1311)</div><div class="line">    at java.text.DateFormat.parse(DateFormat.java:335)</div><div class="line">    at com.peidasoft.orm.dateformat.DateNoStaticUtil.parse(DateNoStaticUtil.java:17)</div><div class="line">    at com.peidasoft.orm.dateformat.DateUtilTest$TestSimpleDateFormatThreadSafe.run(DateUtilTest.java:20)</div><div class="line">Thread-2:Mon May 24 06:02:20 CST 2021</div><div class="line">Thread-2:Fri May 24 06:02:20 CST 2013</div><div class="line">Thread-2:Fri May 24 06:02:20 CST 2013</div><div class="line">Thread-2:Fri May 24 06:02:20 CST 2013</div></pre></td></tr></table></figure>
<p>##分析问题<br>SimpleDateFormat继承了DateFormat,在DateFormat中定义了一个protected属性的 Calendar类的对象：calendar。只是因为Calendar累的概念复杂，牵扯到时区与本地化等等，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。</p>
<p>##解决问题</p>
<ol>
<li>需要的时候创建新实例：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DateUtil &#123;</div><div class="line">    </div><div class="line">    public static  String formatDate(Date date)throws ParseException&#123;</div><div class="line">         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        return sdf.format(date);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Date parse(String strDate) throws ParseException&#123;</div><div class="line">         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        return sdf.parse(strDate);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：在需要用到SimpleDateFormat 的地方新建一个实例，不管什么时候，将有线程安全问题的对象由共享变为局部私有都能避免多线程问题，不过也加重了创建对象的负担。在一般情况下，这样其实对性能影响比不是很明显的。</p>
<ol>
<li>使用同步：同步SimpleDateFormat对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class DateSyncUtil &#123;</div><div class="line"></div><div class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">      </div><div class="line">    public static String formatDate(Date date)throws ParseException&#123;</div><div class="line">        synchronized(sdf)&#123;</div><div class="line">            return sdf.format(date);</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Date parse(String strDate) throws ParseException&#123;</div><div class="line">        synchronized(sdf)&#123;</div><div class="line">            return sdf.parse(strDate);</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：当线程较多时，当一个线程调用该方法时，其他想要调用此方法的线程就要block，多线程并发量大的时候会对性能有一定的影响。</p>
<ol>
<li><p>使用ThreadLocal：　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ConcurrentDateUtil &#123;</div><div class="line"></div><div class="line">    private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        protected DateFormat initialValue() &#123;</div><div class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public static Date parse(String dateStr) throws ParseException &#123;</div><div class="line">        return threadLocal.get().parse(dateStr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String format(Date date) &#123;</div><div class="line">        return threadLocal.get().format(date);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalDateUtil &#123;</div><div class="line">    private static final String date_format = &quot;yyyy-MM-dd HH:mm:ss&quot;;</div><div class="line">    private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;(); </div><div class="line"> </div><div class="line">    public static DateFormat getDateFormat()   </div><div class="line">    &#123;  </div><div class="line">        DateFormat df = threadLocal.get();  </div><div class="line">        if(df==null)&#123;  </div><div class="line">            df = new SimpleDateFormat(date_format);  </div><div class="line">            threadLocal.set(df);  </div><div class="line">        &#125;  </div><div class="line">        return df;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static String formatDate(Date date) throws ParseException &#123;</div><div class="line">        return getDateFormat().format(date);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Date parse(String strDate) throws ParseException &#123;</div><div class="line">        return getDateFormat().parse(strDate);</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：使用ThreadLocal, 也是将共享变量变为独享，线程独享肯定能比方法独享在并发环境中能减少不少创建对象的开销。如果对性能要求比较高的情况下，一般推荐使用这种方法。</p>
<p>4.抛弃JDK，使用其他类库中的时间格式化类：<br>a. 使用Apache commons 里的FastDateFormat，宣称是既快又线程安全的SimpleDateFormat, 可惜它只能对日期进行format, 不能对日期串进行解析。<br>b. 使用Joda-Time类库来处理时间相关问题</p>
<p>##总结<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">由SimpleDateFormat的线程安全问题，我们在遇到多线程并发问题是可以得到如下的解决方案：</div><div class="line">1. 函数内单独创建对象</div><div class="line">2. 采用同步代码</div><div class="line">3. 用threadlocal变量</div><div class="line">4. 采用线程安全的第三方库</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[比较read/write & fread/fwrite]]></title>
      <url>http://hlei.io/2017/12/07/linux-file-io/</url>
      <content type="html"><![CDATA[<p>UNIX环境下的C对二进制流文件的读写有两套：</p>
<ol>
<li>fopen,fread,fwrite,fprintf</li>
<li>open, read, write</li>
</ol>
<p>##区别</p>
<ol>
<li>fopen 系列是标准的C库函数；open系列是 POSIX 定义的，是UNIX系统里的system call。<br>也就是说，fopen系列更具有可移植性；而open系列只能用在 POSIX 的操作系统上。</li>
<li>使用fopen 系列函数时要定义一个指代文件的对象，被称为“文件句柄”（file handler），是一个结构体；而open系列使用的是一个被称为“文件描述符” （file descriptor）的int型整数。</li>
<li>fopen 系列是级别较高的I/O，读写时使用缓冲；而open系列相对低层，更接近操作系统，读写时没有缓冲。由于能更多地与操作系统打交道，open系列可以访问更改一些fopen系列无法访问的信息，如查看文件的读写权限。这些额外的功能通常因系统而异。</li>
<li>使用fopen系列函数需要”#include <sdtio.h>“；使用open系列函数需要”#include <fcntl.h>“ ，链接时要之用libc（-lc）</fcntl.h></sdtio.h></li>
</ol>
<p>##在开源项目中的运用<br>redis中写日志使用的是第一套,下面是redis的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">void serverLogRaw(int level, const char *msg) &#123;</div><div class="line">    const int syslogLevelMap[] = &#123; LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING &#125;;</div><div class="line">    const char *c = &quot;.-*#&quot;;</div><div class="line">    FILE *fp;</div><div class="line">    char buf[64];</div><div class="line">    int rawmode = (level &amp; LL_RAW);</div><div class="line">    int log_to_stdout = server.logfile[0] == &apos;\0&apos;;</div><div class="line"></div><div class="line">    level &amp;= 0xff; /* clear flags */</div><div class="line">    if (level &lt; server.verbosity) return;</div><div class="line"></div><div class="line">    fp = log_to_stdout ? stdout : fopen(server.logfile,&quot;a&quot;);</div><div class="line">    if (!fp) return;</div><div class="line"></div><div class="line">    if (rawmode) &#123;</div><div class="line">        fprintf(fp,&quot;%s&quot;,msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        int off;</div><div class="line">        struct timeval tv;</div><div class="line">        int role_char;</div><div class="line">        pid_t pid = getpid();</div><div class="line"></div><div class="line">        gettimeofday(&amp;tv,NULL);</div><div class="line">        off = strftime(buf,sizeof(buf),&quot;%d %b %H:%M:%S.&quot;,localtime(&amp;tv.tv_sec));</div><div class="line">        snprintf(buf+off,sizeof(buf)-off,&quot;%03d&quot;,(int)tv.tv_usec/1000);</div><div class="line">        if (server.sentinel_mode) &#123;</div><div class="line">            role_char = &apos;X&apos;; /* Sentinel. */</div><div class="line">        &#125; else if (pid != server.pid) &#123;</div><div class="line">            role_char = &apos;C&apos;; /* RDB / AOF writing child. */</div><div class="line">        &#125; else &#123;</div><div class="line">            role_char = (server.masterhost ? &apos;S&apos;:&apos;M&apos;); /* Slave or Master. */</div><div class="line">        &#125;</div><div class="line">        fprintf(fp,&quot;%d:%c %s %c %s\n&quot;,</div><div class="line">            (int)getpid(),role_char, buf,c[level],msg);</div><div class="line">    &#125;</div><div class="line">    fflush(fp);</div><div class="line"></div><div class="line">    if (!log_to_stdout) fclose(fp);</div><div class="line">    if (server.syslog_enabled) syslog(syslogLevelMap[level], &quot;%s&quot;, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>google开源的日志系统glog写文件操作也采用第一套io函数，在函数LogFileObject::Write</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP状态机分析（二）CLOSE_WAIT&TIME_WAIT]]></title>
      <url>http://hlei.io/2017/11/29/network-tcp-machine-state/</url>
      <content type="html"><![CDATA[<h2 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h2><p>在被动关闭连接(对方关闭)情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。</p>
<p>解决方法:<br>基本的思想就是要检测出对方已经关闭的socket，然后关闭它。</p>
<ol>
<li>代码需要判断socket，一旦read返回0，断开连接，read返回负，检查一下errno，如果不是AGAIN，也断开连接。(注:在UNP 7.5节的图7.6中，可以看到使用select能够检测出对方发送了FIN，再根据这条规则就可以处理CLOSE_WAIT的连接)</li>
<li>给每一个socket设置一个时间戳last_update，每接收或者是发送成功数据，就用当前时间更新这个时间戳。定期检查所有的时间戳，如果时间戳与当前时间差值超过一定的阈值，就关闭这个socket。</li>
<li>使用一个Heart-Beat线程，定期向socket发送指定格式的心跳数据包，如果接收到对方的RST报文，说明对方已经关闭了socket，那么我们也关闭这个socket。</li>
<li>设置SO_KEEPALIVE选项，并修改内核参数,下面会详细介绍<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a. 参数设置</div><div class="line">查看相关的参数,这是当前线上环境的配置</div></pre></td></tr></table></figure>
</li>
</ol>
<p>sysctl -a|grep tcp_keepalive<br>net.ipv4.tcp_keepalive_intvl = 300<br>net.ipv4.tcp_keepalive_probes = 9<br>net.ipv4.tcp_keepalive_time = 75<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">参数的含义</div></pre></td></tr></table></figure></p>
<p>tcp_keepalive_intvl: 在TCP保活打开的情况下，最后一次数据交换到TCP发送第一个保活探测包的间隔，即允许的持续空闲时长，或者说每次正常发送心跳的周期。<br>tcp_keepalive_probes: 在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包次数，默认值为9（次）<br>tcp_keepalive_time: tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包的发送频率，默认值为75s。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">设置相关的参数</div></pre></td></tr></table></figure></p>
<p>sysctl -w net.ipv4.tcp_keepalive_time = 75<br>也可以直接打开/etc/sysctl.conf<br>加入net.ipv4.tcp_keepalive_time = 75<br>``</p>
<p>让参数生效<br>sysctl -p</p>
<p>(tcp_keepalive_time + tcp_keepalive_intvl * tcp_keepalive_probes)时间内可检测到连接失效与否。</p>
<p>b. 开启keepalive属性<br>int keepAlive = 1;<br>setsockopt(client_fd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive)); </p>
<p>c. 系统调用设置<br>这样只会影响单个连接，上面修改内核参数会影响所有设置keepalive属性的连接</p>
<p>#include <sys types.h="">  </sys></p>
<p>#include <sys socket.h="">  </sys></p>
<p>#include <netinet tcp.h="">  </netinet></p>
<p>int keepAlive = 1;          // 开启keepalive属性<br>int keepIdle = 1800;        // 如该连接在1800秒内没有任何数据往来,则进行探测<br>int keepInterval = 3;       // 探测时发包的时间间隔为3秒<br>int keepCount = 2;          // 探测尝试的次数.如果第1次探测包就收到响应了,则后几次的不再发.<br>setsockopt(client_fd, SOL_SOCKET, SO_KEEPALIVE, (void<em>)&amp;keepAlive, sizeof(keepAlive));<br>setsockopt(client_fd, SOL_TCP, TCP_KEEPIDLE, (void </em>)&amp;keepIdle, sizeof(keepIdle));<br>setsockopt(client_fd, SOL_TCP,TCP_KEEPINTVL, (void <em>)&amp;keepInterval, sizeof(keepInterval));<br>setsockopt(client_fd, SOL_TCP, TCP_KEEPCNT, (void </em>)&amp;keepCount, sizeof(keepCount));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这篇文章对于一次生产环境遇到的CLOSE_WAIT问题分析很到位</div><div class="line">转载：https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&amp;mid=402163560&amp;idx=1&amp;sn=5269044286ce1d142cca1b5fed3efab1&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd</div><div class="line"></div><div class="line">### 总结</div><div class="line">1. 默认情况下使用keepalive周期为2个小时，如不选择更改，属于误用范畴，造成资源浪费：内核会为每一个连接都打开一个保活计时器，N个连接会打开N个保活计时器。 优势很明显：</div><div class="line">* TCP协议层面保活探测机制，系统内核完全替上层应用自动给做好了</div><div class="line">* 内核层面计时器相比上层应用，更为高效</div><div class="line">* 上层应用只需要处理数据收发、连接异常通知即可</div><div class="line">* 数据包将更为紧凑</div><div class="line">2. 关闭TCP的keepalive，完全使用业务层面心跳保活机制 完全应用掌管心跳，灵活和可控，比如每一个连接心跳周期的可根据需要减少或延长</div><div class="line">业务心跳 + TCP keepalive一起使用，互相作为补充，但TCP保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果。朋友的公司所做IM平台业务心跳2-5分钟智能调整 + tcp keepalive 300秒，组合协作，据说效果也不错。</div><div class="line"></div><div class="line">虽然说没有固定的模式可遵循，那么有以下原则可以参考：</div><div class="line">1. 不想折腾，那就弃用TCP Keepalive吧，完全依赖应用层心跳机制，灵活可控性强</div><div class="line">2. 除非可以很好把控TCP Keepalive机制，那就可以根据需要自由使用吧</div><div class="line"></div><div class="line">### http keep-alive与tcp keep-alive</div><div class="line">http keep-alive与tcp keep-alive，不是同一回事，意图不一样。http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保活机制。</div><div class="line"></div><div class="line">## TIME_WAIT</div><div class="line">主动发起close的一方会出现TIME_WAIT，比如nginx到web server之间，TIME_WAIT状态是为了保护TCP协议的正确性，避免端口发生复用后老的TCP连接残留在网络上的报文进入新的连接里。但这也引入了一个问题，临时端口数量有限，耗尽后，新建连接就会报错EADDRNOTAVAIL</div><div class="line"></div><div class="line">我们来看下，为什么这个状态能影响到一个处理大量连接的服务器，从下面三个方面来说：</div><div class="line">* 新老连接（相同四元组）在TCP连接表中的slot复用避免</div><div class="line">* 内核中，socket结构体的内存占用</div><div class="line">* 额外的CPU开销</div><div class="line"></div><div class="line">### 解决方法</div><div class="line">* 首先要增加临时端口的数量，增加可被消耗的临时端口资源</div></pre></td></tr></table></figure></p>
<p>sysctl -w “net.ipv4.ip_local_port_range=1024 65535”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 然后要加速临时端口回收,可以对内核参数做优化(/etc/sysctl.conf)</div><div class="line">1. 启用tcp_tw_reuse</div></pre></td></tr></table></figure></p>
<p>sysctl -w net.ipv4.tcp_timestamps=1<br>sysctl -w net.ipv4.tcp_tw_reuse=1<br>sysctl -p<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">它定义了一个新的TCP选项–两个四字节的timestamp fields时间戳字段，第一个是TCP发送方的当前时钟时间戳，而第二个是从远程主机接收到的最新时间戳。</div><div class="line">启用net.ipv4.tcp_tw_reuse后，如果新的时间戳，比以前存储的时间戳更大，那么linux将会从TIME-WAIT状态的存活连接中，选取一个，重新分配给新的连接出去的TCP连接。</div><div class="line">连出的TIME-WAIT状态连接，仅仅1秒后就可以被重用了</div><div class="line"></div><div class="line">2. 方法更激进些，启用tw_recycle，tw_recycle允许在两个RTT。当多个客户端处于NAT后时，在服务器端开启tw_recycle会引起丢包问题，如果丢SYN包，就会造成新建连接失败</div></pre></td></tr></table></figure></p>
<p>sysctl -w net.ipv4.tcp_timestamps=1<br>sysctl -w net.ipv4.tcp_tw_recycle=1<br>sysctl -p<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 给socket配置SO_LINGER，on设为1，linger设为0，这样关闭连接后TCP状态从ESTAB直接进入CLOSED，向服务器发rst包而不是fin包来关闭连接。这种方法风险最高，会丢弃buffer里未发送完的数据，不过通过设计协议（客户端和服务器协议上协商后再关闭TCP连接）可以规避这个问题，使用需要小心，选择合适的场景。</div><div class="line"></div><div class="line"></div><div class="line">### 代码验证</div><div class="line">&quot;纸上得来终觉浅，绝知此事要躬行&quot;, 下面我们来验证这样的方法是否真的可行</div><div class="line"></div><div class="line">1. TIME_WAIT过多会耗尽端口，为了模拟端口耗尽的情况，先修改本地临时端口只有一个可用</div></pre></td></tr></table></figure></p>
<p>sysctl -w “net.ipv4.ip_local_port_range=20000 20000”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 启动一个server进程</div></pre></td></tr></table></figure></p>
<p> ./tcp_server05 127.0.0.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 第一个客户端连接</div></pre></td></tr></table></figure></p>
<p>./tcp_client01 127.0.0.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">关闭client，查看连接状态</div><div class="line">![img01](/2017/11/29/network-tcp-machine-state/tcp_machine_state.png)</div><div class="line"></div><div class="line">4. 第二个客户端连接</div></pre></td></tr></table></figure></p>
<p>chris@ubuntu:~/myspace/test/network$ ./tcp_client01 127.0.0.1<br>connect: Cannot assign requested address<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. 修改系统参数</div></pre></td></tr></table></figure></p>
<p>sysctl -w net.ipv4.tcp_tw_reuse=1<br>```</p>
<ol>
<li>重复3、4，可以看到可以成功建立连接</li>
</ol>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li>tcp_tw_recycle (Boolean; default: disabled; since Linux 2.4)<br>Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not recommended since this causes problems when working with NAT (Network Address Translation).</li>
<li>tcp_tw_reuse (Boolean; default: disabled; since Linux 2.4.19/2.6)<br>Allow to reuse TIME_WAIT sockets for new connections when it is safe from protocol viewpoint.  It should not be changed without advice/request of technical experts.</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/" target="_blank" rel="external">http://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[<<Linux多线程服务端编程-使用muduo c++网络库>>笔记（一）]]></title>
      <url>http://hlei.io/2017/10/30/muduo-chapter01/</url>
      <content type="html"><![CDATA[<p>##c++主要内存问题及解决方法<br>1、缓冲区溢出<br>solution：使用vector<char>、string或自己编写的BufferClass来管理缓冲区，记录缓冲区的长度，并通过成员函数而不是裸指针修改缓冲区。</char></p>
<p>2、空悬指针/野指针<br>solution：shared_ptr/weak_ptr</p>
<p>3、重复释放<br>solution：scoped_ptr，只在对象析构时候释放一次</p>
<p>4、内存泄漏<br>solution：scoped_ptr，对象析构时候自动释放内存</p>
<p>5、不配对的new[]/delete<br>solution：把new[]替换为vector/scoped_array</p>
<p>6、内存碎片<br>solution：todo</p>
<p>##shared_ptr是否线程安全<br>shared_ptr计数操作是线程安全的，release 1.33.0后在大多数系统中采用无锁的原子操作实现；但对于对象本身的访问不是线程安全的。对于shared_ptr的线程安全问题，boost官方文档中作了详细说明, <a href="http://www.boost.org/doc/libs/1_65_1/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr" target="_blank" rel="external">http://www.boost.org/doc/libs/1_65_1/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr</a><br>这里作了下总结：</p>
<ol>
<li>多个线程可以同时读一个shared_ptr实例</li>
<li>不同的线程中可以对不同的shared_ptr实例进行“写操作”（包括operator=、reset、析构）</li>
<li>一个shared_ptr实例被不同的线程同时读写是不安全的</li>
</ol>
<p>代码例子：<br>Reading a shared_ptr from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>));</div><div class="line"></div><div class="line"><span class="comment">// thread A</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p); <span class="comment">// reads p</span></div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3(p); <span class="comment">// OK, multiple reads are safe</span></div></pre></td></tr></table></figure></p>
<p>Writing different shared_ptr instances from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// thread A</span></div><div class="line">p.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1912</span>)); <span class="comment">// writes p</span></div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line">p2.reset(); <span class="comment">// OK, writes p2</span></div></pre></td></tr></table></figure></p>
<p>Reading and writing a shared_ptr from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// thread A</span></div><div class="line">p = p3; <span class="comment">// reads p3, writes p</span></div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line">p3.reset(); <span class="comment">// writes p3; undefined, simultaneous read/write</span></div></pre></td></tr></table></figure></p>
<p>Reading and destroying a shared_ptr from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// thread A</span></div><div class="line">p3 = p2; <span class="comment">// reads p2, writes p3</span></div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line"><span class="comment">// p2 goes out of scope: undefined, the destructor is considered a "write access"</span></div></pre></td></tr></table></figure></p>
<p>Writing a shared_ptr from two threads<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// thread A</span></div><div class="line">p3.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</div><div class="line"></div><div class="line"><span class="comment">// thread B</span></div><div class="line">p3.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>)); <span class="comment">// undefined, multiple writes</span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis-rdb]]></title>
      <url>http://hlei.io/2017/10/17/redis-rdb/</url>
      <content type="html"><![CDATA[<p>Reids是一个内存型数据库，所有的数据都存放在内存中。这种模式的缺点就是一旦服务器关闭后会立刻丢失所有存储的数据，Redis当然要避免这种情况的发生，于是其提供了两种持久化机制：RDB和AOF。它们的功能都是将内存中存放的数据保存到磁盘文件上，等到服务器下次开启时能重载数据，以免数据丢失。今天，我们先来剖析一下RDB持久化机制。</p>
<p>##RDB概述<br>开启一个redis-cli，执行添加数据操作如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; flushdb</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set name chris</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; save</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>我先开启了一个Redis客户端，清空数据，然后依次添加了一个键值对到数据库，最后通过SAVE文件将数据库中的数据保存到rdb文件中，实现数据的持久化，服务器会显示数据已经存放在磁盘文件上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">6228:M 17 Oct 05:15:16.846 * DB saved on disk</div></pre></td></tr></table></figure></p>
<p>保存到磁盘的文件名为dump.rdb，利用od命令就能查看里面的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">chris@ubuntu:~/software/redis-3.2.6/src$ od -c dump.rdb </div><div class="line">0000000   R   E   D   I   S   0   0   0   7 372  \t   r   e   d   i   s</div><div class="line">0000020   -   v   e   r 005   3   .   2   .   6 372  \n   r   e   d   i</div><div class="line">0000040   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 302</div><div class="line">0000060   T 364 345   Y 372  \b   u   s   e   d   -   m   e   m 302 350</div><div class="line">0000100   H  \b  \0 376  \0 373 001  \0  \0 004   n   a   m   e 005   c</div><div class="line">0000120   h   r   i   s 376 002 373 001  \0  \0 004   n   a   m   e 005</div><div class="line">0000140   c   h   r   i   s 377 326 354   a   i 227   . 350   %</div><div class="line">0000156</div></pre></td></tr></table></figure></p>
<p><em>RDB文件标识和版本号：REDIS0007
</em>Redis版本：redis-ver 3.2.3<br><em>Redis系统位数（32位或64位）：redis-bits
</em>系统时间：ctime<br><em>内存使用量：used-mem
</em>一组键值对：name-chris</p>
<p>##RDB文件结构<br>| REDIS | db_version | databases | EOF | checksum | </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jvm04]]></title>
      <url>http://hlei.io/2017/10/11/jvm04/</url>
      <content type="html"><![CDATA[<p>jstat -gcutil 25354 500 3<br>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT<br> 96.48   0.00  29.45  57.62  89.07  17974  409.657    18    7.916  417.572<br> 96.48   0.00  30.32  57.62  89.07  17974  409.657    18    7.916  417.572<br> 96.48   0.00  31.14  57.62  89.07  17974  409.657    18    7.916  417.572</p>
<p>after restart:<br> 3733 work      20   0 6525m 1.4g  18m S  9.3  2.3   1:45.08 java </p>
<p> jstat -gcutil 3733 500 3<br>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT<br>  0.00  21.84  13.14  29.65  97.65     19    0.403     2    0.162    0.565<br>  0.00  21.84  14.02  29.65  97.65     19    0.403     2    0.162    0.565<br>  0.00  21.84  14.42  29.65  97.65     19    0.403     2    0.162    0.565</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jvm03]]></title>
      <url>http://hlei.io/2017/10/11/jvm03/</url>
      <content type="html"><![CDATA[<p>Sun JVM参数选项的官方文档<br><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker(一)]]></title>
      <url>http://hlei.io/2017/10/11/docker01-install/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。<br>Docker通常用于如下场景：</p>
<ol>
<li>web应用的自动化打包和发布；</li>
<li>自动化测试和持续集成、发布；</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用；</li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li>
</ol>
<h2 id="docker-vs-虚拟机"><a href="#docker-vs-虚拟机" class="headerlink" title="docker vs 虚拟机"></a>docker vs 虚拟机</h2><pre><code>容器与虚拟机拥有着类似的使命：对应用程序及其关联性进行隔离，从而构建起一套能够随处运
</code></pre><p>行的自容纳单元。此外，容器与虚拟机还摆脱了对物理硬件的需求，允许我们更为高效地使用计算资源，从而提升能源效率与成本效益。<br>　　<br>　　虚拟机会将虚拟硬件、内核（即操作系统）以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。虚拟机依赖于hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致hypervisor在某些方面被认为是一种操作系统。一旦 hypervisor安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载(应用程序)。简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层Runtime，然后供应用程序运行。<br>　　<br>　　 对于容器环境来说，不需要安装主机操作系统，直接将容器层(比如LXC或libcontainer)安装在主机操作系统(通常是Linux变种)之上。在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。</p>
<p>　　相比于虚拟机，容器拥有更高的资源使用效率，因为它并不需要为每个应用分配单独的操作系统——实例规模更小、创建和迁移速度也更快。这意味相比于虚拟机，单个操作系统能够承载更多的容器。云提供商十分热衷于容器技术，因为在相同的硬件设备当中，可以部署数量更多的容器实例。此外，容器易于迁移，但是只能被迁移到具有兼容操作系统内核的其他服务器当中，这样就会给迁移选择带来限制。<br>　　<br>　　因为容器不像虚拟机那样同样对内核或者虚拟硬件进行打包，所以每套容器都拥有自己的隔离化用户空间，从而使得多套容器能够运行在同一主机系统之上。我们可以看到全部操作系统层级的架构都可实现跨容器共享，惟一需要独立构建的就是二进制文件与库。正因为如此，容器才拥有极为出色的轻量化特性。<br>　　<br>　　对Docker稍有接触的人应该都见过下图，无需更多解释，Docker减少Guest OS这一层级，所以更轻量和更高性能。 </p>
<p>docker架构图<br><img src="/2017/10/10/docker01-install/virtual_machine.png" alt="virtual machine diagram"></p>
<p>虚拟机架构图<br><img src="/2017/10/10/docker01-install/docker.png" alt="docker diagram"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java基础（一）-编译时类型和运行时类型]]></title>
      <url>http://hlei.io/2017/10/09/java-basic01/</url>
      <content type="html"><![CDATA[<p>Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态。因为子类其实是一种特殊的父类，因此java允许把一个子类对象直接赋值给一个父类引用变量，无须任何类型转换，或者被称为向上转型，由系统自动完成。</p>
<pre><code class="Java"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>
</span>{
    <span class="keyword">int</span> i = <span class="number">1</span>;
    Base() {
        System.out.println(<span class="keyword">this</span>.i);
        System.out.println(<span class="keyword">this</span>.getClass());
        <span class="keyword">this</span>.print();
    }

    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"Base print:"</span>+i);
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span>
</span>{
    <span class="keyword">int</span> i = <span class="number">2</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"Derived print:"</span>+i);
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Derived d = <span class="keyword">new</span> Derived();
    }
}
</code></pre>
<p>运行结果</p>
<pre><code>1(Base.i)
class com.java_basic.test01.Derived
Derived print:0(Derived.print)
</code></pre><p>Java这里与c++不同之处是，c++的运行时多态依赖virtual关键字，c++中若在Base构造函数中调用print方法，是调用Base的print方法。有这样一条规则，<strong>对象调用编译时类型的属性和运行时类型的方法</strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[atomic variable]]></title>
      <url>http://hlei.io/2017/09/26/linux-atomic-variable/</url>
      <content type="html"><![CDATA[<p>##How atomic variables work</p>
<p>Intel的x86和x86_64架构当访问内存时，有锁住前端总线（FSB）的指令，前端总线是处理器和RAM通信的通道，锁住FSB可以阻止其它处理器或进程在当前处理器运行，也可以阻止访问RAM。</p>
<p>##原子变量的字节数限制<br>Intel的专家建议并不用每次访问内存都要锁住FSB，Intel处理器允许memcpy() and memcmp()允许在一个处理器上执行，但锁住大块内存的代价太大。实际使用中，当访问1, 2, 4, 8字节的整数时可以锁住FSB，gcc支持int、long、long long的原子操作。</p>
<p>##什么情况下不能使用原子变量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">decrement_atomic_value();</div><div class="line"><span class="keyword">if</span> (atomic_value() == <span class="number">0</span>)</div><div class="line">    fire_a_gun();</div></pre></td></tr></table></figure></p>
<p>##gcc支持的原子操作函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">type __sync_fetch_and_add (type *ptr, type value);</div><div class="line">type __sync_fetch_and_sub (type *ptr, type value);</div><div class="line">type __sync_fetch_and_or (type *ptr, type value);</div><div class="line">type __sync_fetch_and_and (type *ptr, type value);</div><div class="line">type __sync_fetch_and_xor (type *ptr, type value);</div><div class="line">type __sync_fetch_and_nand (type *ptr, type value);</div><div class="line"></div><div class="line">type __sync_add_and_fetch (type *ptr, type value);</div><div class="line">type __sync_sub_and_fetch (type *ptr, type value);</div><div class="line">type __sync_or_and_fetch (type *ptr, type value);</div><div class="line">type __sync_and_and_fetch (type *ptr, type value);</div><div class="line">type __sync_xor_and_fetch (type *ptr, type value);</div><div class="line">type __sync_nand_and_fetch (type *ptr, type value);</div></pre></td></tr></table></figure></p>
<p>使用原子操作的例子</p>
<pre><code class="cpp"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span>

<span class="meta">#<span class="meta-keyword">define</span> INC_TO 1000000 <span class="comment">// one million...</span></span>

<span class="keyword">int</span> global_int = <span class="number">0</span>;

<span class="keyword">pid_t</span> gettid( <span class="keyword">void</span> )
{
    <span class="keyword">return</span> syscall( __NR_gettid );
}

<span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">( <span class="keyword">void</span> *arg )</span>
</span>{
    <span class="keyword">int</span> i;
    <span class="keyword">int</span> proc_num = (<span class="keyword">int</span>)(<span class="keyword">long</span>)arg;
    <span class="keyword">cpu_set_t</span> <span class="built_in">set</span>;

    CPU_ZERO( &amp;<span class="built_in">set</span> );
    CPU_SET( proc_num, &amp;<span class="built_in">set</span> );

    <span class="keyword">if</span> (sched_setaffinity( gettid(), <span class="keyword">sizeof</span>( <span class="keyword">cpu_set_t</span> ), &amp;<span class="built_in">set</span> ))
    {
        perror( <span class="string">"sched_setaffinity"</span> );
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    }

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INC_TO; i++)
    {
        global_int++;
        <span class="comment">//__sync_fetch_and_add( &amp;global_int, 1 );</span>
    }

    <span class="keyword">return</span> <span class="literal">NULL</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> procs = <span class="number">0</span>;
    <span class="keyword">int</span> i;
    <span class="keyword">pthread_t</span> *thrs;

    <span class="comment">// Getting number of CPUs</span>
    procs = (<span class="keyword">int</span>)sysconf( _SC_NPROCESSORS_ONLN );
    <span class="keyword">if</span> (procs &lt; <span class="number">0</span>)
    {
        perror( <span class="string">"sysconf"</span> );
        <span class="keyword">return</span> <span class="number">-1</span>;
    }
    <span class="keyword">else</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cpu nums:"</span> &lt;&lt; procs &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;
    }

    thrs = (<span class="keyword">pthread_t</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( <span class="keyword">pthread_t</span> ) * procs );
    <span class="keyword">if</span> (thrs == <span class="literal">NULL</span>)
    {
        perror( <span class="string">"malloc"</span> );
        <span class="keyword">return</span> <span class="number">-1</span>;
    }

    <span class="built_in">printf</span>( <span class="string">"Starting %d threads...\n"</span>, procs );

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; procs; i++)
    {
        <span class="keyword">if</span> (pthread_create( &amp;thrs[i], <span class="literal">NULL</span>, thread_routine,
            (<span class="keyword">void</span> *)(<span class="keyword">long</span>)i ))
        {
            perror( <span class="string">"pthread_create"</span> );
            procs = i;
            <span class="keyword">break</span>;
        }
    }

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; procs; i++)
        pthread_join( thrs[i], <span class="literal">NULL</span> );

    <span class="built_in">free</span>( thrs );

    <span class="built_in">printf</span>( <span class="string">"After doing all the math, global_int value is: %d\n"</span>,
        global_int );
    <span class="built_in">printf</span>( <span class="string">"Expected value is: %d\n"</span>, INC_TO * procs );

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
<p>平均耗时90ms</p>
<p>同样的逻辑使用互斥锁的例子</p>
<pre><code class="cpp"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span>

<span class="meta">#<span class="meta-keyword">define</span> INC_TO 1000000 <span class="comment">// one million...</span></span>

<span class="keyword">int</span> global_int = <span class="number">0</span>;
<span class="keyword">pthread_mutex_t</span> mutex;

<span class="keyword">pid_t</span> gettid( <span class="keyword">void</span> )
{
    <span class="keyword">return</span> syscall( __NR_gettid );
}

<span class="keyword">uint64_t</span> get_time()
{
    <span class="keyword">struct</span> timeval tv;
    gettimeofday(&amp;tv, <span class="literal">NULL</span>);
    <span class="keyword">return</span> tv.tv_sec*<span class="number">1000</span> + tv.tv_usec/<span class="number">1000</span>;
}

<span class="function"><span class="keyword">void</span> *<span class="title">thread_routine</span><span class="params">( <span class="keyword">void</span> *arg )</span>
</span>{
    <span class="keyword">int</span> i;
    <span class="keyword">int</span> proc_num = (<span class="keyword">int</span>)(<span class="keyword">long</span>)arg;
    <span class="keyword">cpu_set_t</span> <span class="built_in">set</span>;

    CPU_ZERO( &amp;<span class="built_in">set</span> );
    CPU_SET( proc_num, &amp;<span class="built_in">set</span> );

    <span class="keyword">if</span> (sched_setaffinity( gettid(), <span class="keyword">sizeof</span>( <span class="keyword">cpu_set_t</span> ), &amp;<span class="built_in">set</span> ))
    {
        perror( <span class="string">"sched_setaffinity"</span> );
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    }

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INC_TO; i++)
    {
        pthread_mutex_lock(&amp;mutex);
        global_int++;
        pthread_mutex_unlock(&amp;mutex);
    }

    <span class="keyword">return</span> <span class="literal">NULL</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> procs = <span class="number">0</span>;
    <span class="keyword">int</span> i;
    <span class="keyword">pthread_t</span> *thrs;

    <span class="comment">// Getting number of CPUs</span>
    procs = (<span class="keyword">int</span>)sysconf( _SC_NPROCESSORS_ONLN );
    <span class="keyword">if</span> (procs &lt; <span class="number">0</span>)
    {
        perror( <span class="string">"sysconf"</span> );
        <span class="keyword">return</span> <span class="number">-1</span>;
    }
    <span class="keyword">else</span>
    {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cpu nums:"</span> &lt;&lt; procs &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;
    }

    thrs = (<span class="keyword">pthread_t</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( <span class="keyword">pthread_t</span> ) * procs );
    <span class="keyword">if</span> (thrs == <span class="literal">NULL</span>)
    {
        perror( <span class="string">"malloc"</span> );
        <span class="keyword">return</span> <span class="number">-1</span>;
    }

    <span class="built_in">printf</span>( <span class="string">"Starting %d threads...\n"</span>, procs );
    <span class="keyword">uint64_t</span> begin_ts = get_time();
    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; procs; i++)
    {
        <span class="keyword">if</span> (pthread_create( &amp;thrs[i], <span class="literal">NULL</span>, thread_routine,
            (<span class="keyword">void</span> *)(<span class="keyword">long</span>)i ))
        {
            perror( <span class="string">"pthread_create"</span> );
            procs = i;
            <span class="keyword">break</span>;
        }
    }

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; procs; i++)
        pthread_join( thrs[i], <span class="literal">NULL</span> );

    pthread_mutex_destroy(&amp;mutex);
    <span class="keyword">uint64_t</span> end_ts = get_time();

    <span class="built_in">printf</span>(<span class="string">"time costs:%lld\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>)end_ts-begin_ts);
    <span class="built_in">free</span>( thrs );

    <span class="built_in">printf</span>( <span class="string">"After doing all the math, global_int value is: %d\n"</span>,
        global_int );
    <span class="built_in">printf</span>( <span class="string">"Expected value is: %d\n"</span>, INC_TO * procs );

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
<p>平均耗时400ms,可以看出原子操作相比互斥锁有很大的性能优势.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.alexonlinux.com/multithreaded-simple-data-type-access-and-atomic-variables#table_of_contents" target="_blank" rel="external">http://www.alexonlinux.com/multithreaded-simple-data-type-access-and-atomic-variables#table_of_contents</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux-memory-barrier]]></title>
      <url>http://hlei.io/2017/09/05/linux-memory-barrier/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[java-timer]]></title>
      <url>http://hlei.io/2017/08/21/java-timer/</url>
      <content type="html"><![CDATA[<h2 id="使用Timer类实现"><a href="#使用Timer类实现" class="headerlink" title="使用Timer类实现"></a>使用Timer类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStringDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        Date currentTime = <span class="keyword">new</span> Date();</div><div class="line">        SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">        String dateString = formatter.format(currentTime);</div><div class="line">        <span class="keyword">return</span> dateString;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> TimerTask timerTask1 = <span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.println(<span class="string">"task2 invoked!"</span>+Thread.currentThread().getId());</div><div class="line">                    System.out.println(<span class="string">"begin: "</span>+getStringDate());</div><div class="line">                    <span class="comment">//Thread.sleep(5000L);</span></div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> TimerTask timerTask2 = <span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.println(<span class="string">"task2 invoked!"</span>+Thread.currentThread().getId());</div><div class="line">                    System.out.println(<span class="string">"begin: "</span>+getStringDate());</div><div class="line">                    <span class="comment">//Thread.sleep(5000L);</span></div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Timer timer = <span class="keyword">new</span> Timer();<span class="comment">// 实例化Timer</span></div><div class="line">        timer.schedule(timerTask1, <span class="number">8000</span>);</div><div class="line">        timer.schedule(timerTask2, <span class="number">10000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Timer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Protocal Buffer trap 1-CopyFrom]]></title>
      <url>http://hlei.io/2017/06/22/pb-CopyFrom/</url>
      <content type="html"><![CDATA[<p>最近在使用pb时遇到了这么一个问题，还是废了不少时间去定位，出现coredump的场景类似下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student stu;</div><div class="line">Teacher teacher;</div><div class="line"></div><div class="line">stu.CopyFrom(teacher);</div></pre></td></tr></table></figure></p>
<p>奇怪的是这样居然可以编译通过，查了pb的源码发现类都是共同的基类Message，而有两个overload版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void CopyFrom(const ::google::protobuf::Message&amp; from);</div><div class="line">void CopyFrom(const Student&amp; from);</div></pre></td></tr></table></figure></p>
<p>终于恍然大悟了！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java-cmd01-jps]]></title>
      <url>http://hlei.io/2017/05/18/java-cmd01/</url>
      <content type="html"><![CDATA[<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>我们知道，很多Java命令都在jdk的JAVA_HOME/bin目录下面，jps也不例外，他就在bin目录下，所以，他是java自带的一个命令。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>jps(Java Virtual Machine Process Status Tool)是JDK1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>jdk中的jps命令可以显示当前运行的java进程以及相关参数，它的实现机制如下：<br>java程序在启动以后，会在java.io.tmpdir指定的目录下，就是临时文件夹里，生成一个类似于hsperfdata<em>User的文件夹，这个文件夹里（在Linux中为/tmp/hsperfdata</em>{userName}/），有几个文件，名字就是java进程的pid，因此列出当前运行的java进程，只是把这个目录里的文件名列一下而已。至于系统的参数什么，就可以解析这几个文件获得。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数<br>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null<br>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名<br>-v 输出传递给JVM的参数</p>
<p>PS:jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java-cmd01-jstat]]></title>
      <url>http://hlei.io/2017/05/18/java-cmd02/</url>
      <content type="html"><![CDATA[<p>jstat位于java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。可见，Jstat是轻量级的、专门针对JVM的工具，非常适用。</p>
<h2 id="jstat-命令格式"><a href="#jstat-命令格式" class="headerlink" title="jstat 命令格式"></a>jstat 命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</div></pre></td></tr></table></figure>
<p>参数解释：<br>Option — 选项，我们一般使用 -gcutil 查看gc情况<br>vmid — VM的进程号，即当前运行的java进程号<br>interval– 间隔时间，单位为秒或者毫秒<br>count — 打印次数，如果缺省则打印无数次</p>
<p>参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程5828垃圾收集状况，一共查询5次，那命令行如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat -gc 5828 250 5</div></pre></td></tr></table></figure></p>
<h2 id="option"><a href="#option" class="headerlink" title="option"></a>option</h2><p>选项option代表这用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集和运行期编译状况，具体选项及作用如下：</p>
<table>
<thead>
<tr>
<th>param</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>–class</td>
<td>监视类装载、卸载数量、总空间及类装载所耗费的时间</td>
</tr>
<tr>
<td>–gc</td>
<td>监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量</td>
</tr>
<tr>
<td>–gccapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最小空间</td>
</tr>
<tr>
<td>–gcutil</td>
<td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td>–gccause</td>
<td>与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td>–gcnew</td>
<td>监视新生代GC的状况</td>
</tr>
<tr>
<td>–gcnewcapacity</td>
<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间</td>
</tr>
<tr>
<td>–gcold</td>
<td>监视老年代GC的状况</td>
</tr>
<tr>
<td>–gcoldcapacity</td>
<td>监视内容与——gcold基本相同，输出主要关注使用到的最大和最小空间</td>
</tr>
<tr>
<td>–gcpermcapacity</td>
<td>输出永久代使用到的最大和最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出JIT编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td>–printcompilation</td>
<td>输出已经被JIT编译的方法</td>
</tr>
</tbody>
</table>
<p>1、jstat –class <pid>: 显示加载class的数量，及所占空间等信息。<br>Loaded 装载的类的数量<br>Bytes 装载类所占用的字节数<br>Unloaded 卸载类的数量<br>Bytes 卸载类的字节数<br>Time 装载和卸载类所花费的时间</pid></p>
<p>2、jstat -compiler <pid>: 显示VM实时编译的数量等信息。</pid></p>
<p>Compiled 编译任务执行数量 Failed 编译任务执行失败数量 Invalid 编译任务执行失效数量 Time 编译任务消耗时间 FailedType 最后一个编译失败任务的类型 FailedMethod 最后一个编译失败任务所在的类及方法</p>
<p>3、jstat -gc <pid>: 可以显示gc的信息，查看gc的次数，及时间。</pid></p>
<p>S0C 年轻代中第一个survivor（幸存区）的容量 (字节) S1C 年轻代中第二个survivor（幸存区）的容量 (字节) S0U 年轻代中第一个survivor（幸存区）目前已使用空间 (字节) S1U 年轻代中第二个survivor（幸存区）目前已使用空间 (字节) EC 年轻代中Eden（伊甸园）的容量 (字节) EU 年轻代中Eden（伊甸园）目前已使用空间 (字节) OC Old代的容量 (字节) OU Old代目前已使用空间 (字节) PC Perm(持久代)的容量 (字节) PU Perm(持久代)目前已使用空间 (字节) YGC 从应用程序启动到采样时年轻代中gc次数 YGCT 从应用程序启动到采样时年轻代中gc所用时间(s) FGC 从应用程序启动到采样时old代(全gc)gc次数 FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s) GCT 从应用程序启动到采样时gc用的总时间(s)</p>
<p>4、jstat -gccapacity <pid>:可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小</pid></p>
<p>NGCMN 年轻代(young)中初始化(最小)的大小(字节) NGCMX 年轻代(young)的最大容量 (字节) NGC 年轻代(young)中当前的容量 (字节) S0C 年轻代中第一个survivor（幸存区）的容量 (字节) S1C 年轻代中第二个survivor（幸存区）的容量 (字节) EC 年轻代中Eden（伊甸园）的容量 (字节) OGCMN old代中初始化(最小)的大小 (字节) OGCMX old代的最大容量(字节) OGC old代当前新生成的容量 (字节) OC Old代的容量 (字节) PGCMN perm代中初始化(最小)的大小 (字节) PGCMX perm代的最大容量 (字节)<br>PGC perm代当前新生成的容量 (字节) PC Perm(持久代)的容量 (字节) YGC 从应用程序启动到采样时年轻代中gc次数 FGC 从应用程序启动到采样时old代(全gc)gc次数</p>
<p>5、jstat -gcutil <pid>:统计gc信息</pid></p>
<p>S0 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比 S1 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比 E 年轻代中Eden（伊甸园）已使用的占当前容量百分比 O old代已使用的占当前容量百分比 P perm代已使用的占当前容量百分比 YGC 从应用程序启动到采样时年轻代中gc次数 YGCT 从应用程序启动到采样时年轻代中gc所用时间(s) FGC 从应用程序启动到采样时old代(全gc)gc次数 FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s) GCT 从应用程序启动到采样时gc用的总时间(s)</p>
<p>6、jstat -gcnew <pid>:年轻代对象的信息。</pid></p>
<p>S0C 年轻代中第一个survivor（幸存区）的容量 (字节) S1C 年轻代中第二个survivor（幸存区）的容量 (字节) S0U 年轻代中第一个survivor（幸存区）目前已使用空间 (字节) S1U 年轻代中第二个survivor（幸存区）目前已使用空间 (字节) TT 持有次数限制 MTT 最大持有次数限制 EC 年轻代中Eden（伊甸园）的容量 (字节) EU 年轻代中Eden（伊甸园）目前已使用空间 (字节) YGC 从应用程序启动到采样时年轻代中gc次数 YGCT 从应用程序启动到采样时年轻代中gc所用时间(s)</p>
<p>7、jstat -gcnewcapacity<pid>: 年轻代对象的信息及其占用量。</pid></p>
<p>NGCMN 年轻代(young)中初始化(最小)的大小(字节) NGCMX 年轻代(young)的最大容量 (字节) NGC 年轻代(young)中当前的容量 (字节) S0CMX 年轻代中第一个survivor（幸存区）的最大容量 (字节) S0C 年轻代中第一个survivor（幸存区）的容量 (字节) S1CMX 年轻代中第二个survivor（幸存区）的最大容量 (字节) S1C 年轻代中第二个survivor（幸存区）的容量 (字节) ECMX 年轻代中Eden（伊甸园）的最大容量 (字节) EC 年轻代中Eden（伊甸园）的容量 (字节) YGC 从应用程序启动到采样时年轻代中gc次数 FGC 从应用程序启动到采样时old代(全gc)gc次数</p>
<p>8、jstat -gcold <pid>：old代对象的信息。</pid></p>
<p>PC Perm(持久代)的容量 (字节) PU Perm(持久代)目前已使用空间 (字节) OC Old代的容量 (字节) OU Old代目前已使用空间 (字节) YGC 从应用程序启动到采样时年轻代中gc次数 FGC 从应用程序启动到采样时old代(全gc)gc次数 FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s) GCT 从应用程序启动到采样时gc用的总时间(s)</p>
<p>9、stat -gcoldcapacity <pid>: old代对象的信息及其占用量。</pid></p>
<p>OGCMN old代中初始化(最小)的大小 (字节) OGCMX old代的最大容量(字节) OGC old代当前新生成的容量 (字节) OC Old代的容量 (字节) YGC 从应用程序启动到采样时年轻代中gc次数 FGC 从应用程序启动到采样时old代(全gc)gc次数 FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s) GCT 从应用程序启动到采样时gc用的总时间(s)</p>
<p>10、jstat -gcpermcapacity<pid>: perm对象的信息及其占用量。</pid></p>
<p>PGCMN perm代中初始化(最小)的大小 (字节) PGCMX perm代的最大容量 (字节)<br>PGC perm代当前新生成的容量 (字节) PC Perm(持久代)的容量 (字节) YGC 从应用程序启动到采样时年轻代中gc次数 FGC 从应用程序启动到采样时old代(全gc)gc次数 FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s) GCT 从应用程序启动到采样时gc用的总时间(s)</p>
<p>11、jstat -printcompilation <pid>：当前VM执行的信息。</pid></p>
<p>Compiled 编译任务的数目 Size 方法生成的字节码的大小 Type 编译类型 Method 类名和方法名用来标识编译的方法。类名使用/做为一个命名空间分隔符。方法名是给定类中的方法。上述格式是由-XX:+PrintComplation选项进行设置的</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GC algorithm]]></title>
      <url>http://hlei.io/2017/05/12/jvm02/</url>
      <content type="html"><![CDATA[<p>##1 按照基本回收策略分<br>标记-清除算法<br>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。<br>它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 </p>
<p>复制算法<br>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
<p>分代收集算法<br>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<p>分代垃圾回收详解:<br>分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p>
<p>虚拟机中的共划分为三个代：年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p>
<p>年轻代:<br>       所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p>
<p>年老代:<br>    在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>持久代:<br>    用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<n>进行设置。</n></p>
<p>什么情况下触发垃圾回收<br>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p>
<p>Scavenge GC<br>    一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
<p>Full GC<br>    对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：<br>· 年老代（Tenured）被写满<br>· 持久代（Perm）被写满<br>· System.gc()被显示调用<br>·上一次GC之后Heap的各域分配策略动态变化</p>
<p>##2 按分区对待的方式分<br>增量收集（IncrementalCollecting）:实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。</p>
<p>分代收集（Generational Collecting）:基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</p>
<p>##3 按系统线程分<br>串行收集:串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然,此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</p>
<p>并行收集:并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。（串型收集的并发版本，需要暂停jvm）并行paralise指的是多个任务在多个cpu中一起并行执行，最后将结果合并。效率是N倍。</p>
<p>并发收集:相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。（和并行收集不同，并发只有在开头和结尾会暂停jvm）并发concurrent指的是多个任务在一个cpu伪同步执行，但其实是串行调度的，效率并非直接是N倍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jvm01]]></title>
      <url>http://hlei.io/2017/05/11/jvm01/</url>
      <content type="html"><![CDATA[<h2 id="阻塞io模型"><a href="#阻塞io模型" class="headerlink" title="阻塞io模型"></a>阻塞io模型</h2><p><img src="/2017/03/08/network/阻塞io模型.png" alt="阻塞io模型"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java-multithread]]></title>
      <url>http://hlei.io/2017/04/25/java-multithread/</url>
      <content type="html"><![CDATA[<p>##<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incre</span><span class="params">()</span> </span>&#123;</div><div class="line">                count += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Counter counter = <span class="keyword">new</span> Counter();</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CountingThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200000</span>; ++i) &#123;</div><div class="line">                    System.out.println(<span class="string">"thread id:"</span>+<span class="keyword">this</span>.getId());</div><div class="line">                    counter.incre();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Thread thread1 = <span class="keyword">new</span> CountingThread();</div><div class="line">        Thread thread2 = <span class="keyword">new</span> CountingThread();</div><div class="line"></div><div class="line">        thread2.start();</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">        thread2.join();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"counter: "</span>+counter.getCount());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counter: 399998</div></pre></td></tr></table></figure>
<p>使用synchronized修饰方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized void incre() &#123;</div><div class="line">    count += 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用synchronized修饰”关键区域”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void incre() &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        count += 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>synchronized不能继承——也就是说，假如一个方法在基础类中是“ 同步”的，那么在衍生类过载版本中，它不会自动进入“同步”状态。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[elasticsearch01]]></title>
      <url>http://hlei.io/2017/04/21/elasticsearch01/</url>
      <content type="html"><![CDATA[<p>##<br>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。<br>但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。<br>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。<br>不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：</p>
<ul>
<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>
<li>分布式的实时分析搜索引擎</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据<br>而且，所有的这些功能被集成到一个服务里面，你的应用可以通过简单的RESTful API、各种语言的客户端甚至命令行与之交互。</li>
</ul>
<p>可以用传统的关系数据库来作对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</div><div class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</div></pre></td></tr></table></figure></p>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>1.安装jdk，我自己机器上的是jdk7<br>2.下载安装包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/tar/elasticsearch/2.3.4/elasticsearch-2.3.4.tar.gz</div></pre></td></tr></table></figure></p>
<p>3.解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf elasticsearch-2.3.4.tar.gz</div></pre></td></tr></table></figure></p>
<p>4.启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/elasticsearch</div></pre></td></tr></table></figure></p>
<p>5.测试是否成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;http://localhost:9200/?pretty&apos;</div></pre></td></tr></table></figure></p>
<p>如果输出下面的结果就大功告成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;count&quot; : 3,</div><div class="line">  &quot;_shards&quot; : &#123;</div><div class="line">    &quot;total&quot; : 5,</div><div class="line">    &quot;successful&quot; : 5,</div><div class="line">    &quot;failed&quot; : 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>###让我们建立一个员工目录</p>
<p>假设我们刚好在Megacorp工作，这时人力资源部门出于某种目的需要让我们创建一个员工目录，这个目录用于促进人文关怀和用于实时协同工作</p>
<p>###索引员工文档<br>所以为了创建员工目录，我们将进行如下操作：<br><em>为每个员工的文档(document)建立索引，每个文档包含了相应员工的所有信息。
</em>每个文档的类型为employee。<br><em>employee类型归属于索引megacorp。
</em>megacorp索引存储在Elasticsearch集群中。</p>
<p>我们看到path:/megacorp/employee/1包含三部分信息：<br>| 名字 | 说明 |<br>| ————- | ————- |<br>| megacorp | 索引名 |<br>| employee | 类型名 |<br>| 1 | 这个员工的ID |</p>
<p>使用RESTful API，通过9200端口的与Elasticsearch进行通信<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">curl -XPUT 'localhost:9200/megacorp/employee/1' -d '</div><div class="line">&#123;</div><div class="line">    "first_name" : "John",</div><div class="line">    "last_name" :  "Smith",</div><div class="line">    "age" :        25,</div><div class="line">    "about" :      "I love to go rock climbing",</div><div class="line">    "interests": [ "sports", "music" ]</div><div class="line">&#125;'</div><div class="line"></div><div class="line">curl -XPUT 'localhost:9200/megacorp/employee/2' -d '</div><div class="line">&#123;</div><div class="line">    "first_name" :  "Jane",</div><div class="line">    "last_name" :   "Smith",</div><div class="line">    "age" :         32,</div><div class="line">    "about" :       "I like to collect rock albums",</div><div class="line">    "interests":  [ "music" ]</div><div class="line">&#125;'</div><div class="line"></div><div class="line">curl -XPUT 'localhost:9200/megacorp/employee/3' -d '</div><div class="line">&#123;</div><div class="line">    "first_name" :  "Douglas",</div><div class="line">    "last_name" :   "Fir",</div><div class="line">    "age" :         35,</div><div class="line">    "about":        "I like to build cabinets",</div><div class="line">    "interests":  [ "forestry" ]</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[回顾C++(二)-STL中的sort]]></title>
      <url>http://hlei.io/2017/04/17/c-02-stlsort/</url>
      <content type="html"><![CDATA[<h2 id="相等-or-等价"><a href="#相等-or-等价" class="headerlink" title="相等 or 等价"></a>相等 or 等价</h2><p>STL充满了比较对象是否有同样的值。比如，当你用find来定位区间中第一个有特定值的对象的位置，find必须可以比较两个对象，看看一个的值是否与另一个相等。同样，当你尝试向set中插入一个新元素时，set::insert必须可以判断那个元素的值是否已经在set中了。</p>
<p>find算法和set的insert成员函数是很多必须判断两个值是否相同的函数的代表。但它们以不同的方式完成，find对“相同”的定义是相等，基于operator==。set::insert对“相同”的定义是等价，通常基于operator&lt;。等价是基于在一个有序区间中对象值的相对位置。等价一般在每种标准关联容器（比如，set、multiset、map和multimap）的一部分——排序顺序方面有意义。两个对象x和y如果在关联容器c的排序顺序中没有哪个排在另一个之前，那么它们关于c使用的排序顺序有等价的值。set<widget>的默认比较函数是less<widget>，而默认的less<widget>简单地对Widget调用operator&lt;，所以w1和w2关于operator&lt;有等价的值如果下面表达式为真：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(w1 &lt; w2) // w1 &lt; w2时它非真</div><div class="line">&amp;&amp;        // 而且</div><div class="line">(w2&lt;w1)   // w2 &lt; w1时它非真</div></pre></td></tr></table></figure></widget></widget></widget></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[回顾C++(一)-STL中的clear]]></title>
      <url>http://hlei.io/2017/04/17/c-01-stlclear/</url>
      <content type="html"><![CDATA[<p>通常我们可能会写下这样的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</div><div class="line">&#123;</div><div class="line">	v1.push_back(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"v1 before clear"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v1.size() = "</span>&lt;&lt;v1.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v1.capacity() = "</span>&lt;&lt;v1.capacity()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">v1.clear();</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"v1 after clear"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v1.size() = "</span>&lt;&lt;v1.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v1.capacity() = "</span>&lt;&lt;v1.capacity()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</div><div class="line">&#123;</div><div class="line">	v2.push_back(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">v1 before clear--------------</div><div class="line">v1.size() = <span class="number">100</span></div><div class="line">v1.capacity() = <span class="number">128</span></div><div class="line">v1 after clear--------------</div><div class="line">v1.size() = <span class="number">0</span></div><div class="line">v1.capacity() = <span class="number">128</span></div></pre></td></tr></table></figure></p>
<p>clear并没有释放掉内存，而仅仅是将size置为0，如果需要立即释放掉内存，可以用一个空的容器和其交换，修改后的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"v2 before swap"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v2.size() = "</span>&lt;&lt;v2.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v2.capacity() = "</span>&lt;&lt;v2.capacity()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(v2);</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"v2 after swap--------------"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v2.size() = "</span>&lt;&lt;v2.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v2.capacity() = "</span>&lt;&lt;v2.capacity()&lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">v2 before swap--------------</div><div class="line">v2.size() = <span class="number">100</span></div><div class="line">v2.capacity() = <span class="number">128</span></div><div class="line">v2 after swap--------------</div><div class="line">v2.size() = <span class="number">0</span></div><div class="line">v2.capacity() = <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>c++11中增加了新的方法shrink_to_fit，可以释放掉多余的内存<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</div><div class="line">&#123;</div><div class="line">	v3.push_back(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"v3 before shrink_to_fit--------------"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v3.size() = "</span>&lt;&lt;v3.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v3.capacity() = "</span>&lt;&lt;v3.capacity()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">v3.shrink_to_fit();</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"v3 after shrink_to_fit--------------"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v3.size() = "</span>&lt;&lt;v3.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"v3.capacity() = "</span>&lt;&lt;v3.capacity()&lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">v3 before shrink_to_fit--------------</div><div class="line">v3.size() = <span class="number">100</span></div><div class="line">v3.capacity() = <span class="number">128</span></div><div class="line">v3 after shrink_to_fit--------------</div><div class="line">v3.size() = <span class="number">100</span></div><div class="line">v3.capacity() = <span class="number">100</span></div></pre></td></tr></table></figure></p>
<p><em>Question?</em><br>不理解这个方法的作用，设置capacity的本意是预留内存，下次插入元素时不用涉及耗时的内存分配，这样下次插入元素肯定会触发重新分配内存。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[lucence-01]]></title>
      <url>http://hlei.io/2017/04/11/lucence-01/</url>
      <content type="html"><![CDATA[<h2 id="lucence简介"><a href="#lucence简介" class="headerlink" title="lucence简介"></a>lucence简介</h2><p>Lucene不是一个完整的全文索引应用，而是是一个用Java写的全文索引引擎工具包，它可以方便的嵌入到各种应用中实现针对应用的全文索引/检索功能。</p>
<p>Lucene的作者：Lucene的贡献者Doug Cutting是一位资深全文索引/检索专家，曾经是V-Twin搜索引擎(Apple的Copland操作系统的成就之一)的主要开发者，后在Excite担任高级系统架构设计师，目前从事于一些INTERNET底层架构的研究。他贡献出的Lucene的目标是为各种中小型应用程序加入全文检索功能。</p>
<p>Lucene的发展历程：早先发布在作者自己的www.lucene.com，后来发布在SourceForge，2001年年底成为APACHE基金会jakarta的一个子项目：<a href="http://jakarta.apache.org/lucene/" target="_blank" rel="external">http://jakarta.apache.org/lucene/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[generate]]></title>
      <url>http://hlei.io/2017/03/23/generate/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[boost_coroutine]]></title>
      <url>http://hlei.io/2017/03/23/boost-coroutine/</url>
      <content type="html"><![CDATA[<h2 id="两个函数如何并发执行？"><a href="#两个函数如何并发执行？" class="headerlink" title="两个函数如何并发执行？"></a>两个函数如何并发执行？</h2><p><img src="/2017/03/22/boost-coroutine/coroutine01.png" alt="函数并发执行"></p>
<h2 id="执行转移机制"><a href="#执行转移机制" class="headerlink" title="执行转移机制"></a>执行转移机制</h2><p><img src="/2017/03/22/boost-coroutine/coroutine02.png" alt="执行转移机制"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/coroutine/all.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::coroutines::asymmetric_coroutine&lt; <span class="keyword">void</span> &gt;::pull_type <span class="keyword">pull_coro_t</span>;</div><div class="line"><span class="keyword">typedef</span> boost::coroutines::asymmetric_coroutine&lt; <span class="keyword">void</span> &gt;::push_type <span class="keyword">push_coro_t</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">push_coro_t</span> &amp; sink)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</div><div class="line">    sink();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>;</div><div class="line">    sink();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>;</div><div class="line">    sink();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">pull_coro_t</span> source(foo);</div><div class="line">        <span class="keyword">while</span> (source)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</div><div class="line">            source();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nDone"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1-2-3-4</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/coroutine/all.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::coroutines::asymmetric_coroutine&lt; <span class="keyword">int</span> &gt;::pull_type pull_coro_t1;</div><div class="line"><span class="keyword">typedef</span> boost::coroutines::asymmetric_coroutine&lt; <span class="keyword">int</span> &gt;::push_type push_coro_t1;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(push_coro_t1&amp; sink1)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>;</div><div class="line">	sink1(<span class="number">10</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"2"</span>;</div><div class="line">	sink1(<span class="number">20</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"3"</span>;</div><div class="line">	sink1(<span class="number">30</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"4"</span>;</div><div class="line">	sink1(<span class="number">40</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	&#123;</div><div class="line">		<span class="function">pull_coro_t1 <span class="title">source1</span><span class="params">(foo1)</span></span>;</div><div class="line">		<span class="keyword">while</span> (source1)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">int</span> ret = source1.get();</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"ret: "</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			source1();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"\nDone"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1ret: 10</div><div class="line">2ret: 20</div><div class="line">3ret: 30</div><div class="line">4ret: 40</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/coroutine/all.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::coroutines::asymmetric_coroutine&lt; <span class="keyword">int</span> &gt;::pull_type pull_coro_t1;</div><div class="line"><span class="keyword">typedef</span> boost::coroutines::asymmetric_coroutine&lt; <span class="keyword">int</span> &gt;::push_type push_coro_t1;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(pull_coro_t1&amp; sink1)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"1 "</span>&lt;&lt;source1.get();</div><div class="line">	sink1();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"2 "</span>&lt;&lt;source1.get();</div><div class="line">	sink1();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"3 "</span>&lt;&lt;source1.get();</div><div class="line">	sink1();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"4 "</span>&lt;&lt;source1.get();</div><div class="line">	sink1();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	&#123;</div><div class="line">		<span class="function">push_coro_t1 <span class="title">source1</span><span class="params">(foo1)</span></span>;</div><div class="line">		<span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span> (source1)</div><div class="line">		&#123;</div><div class="line">			++c;</div><div class="line">			source1();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"\nDone"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IO模型介绍]]></title>
      <url>http://hlei.io/2017/03/22/network-io-model/</url>
      <content type="html"><![CDATA[<h2 id="阻塞io模型"><a href="#阻塞io模型" class="headerlink" title="阻塞io模型"></a>阻塞io模型</h2><p><img src="/2017/03/22/network-io-model/阻塞io模型.png" alt="阻塞io模型"></p>
<h2 id="非阻塞io模型"><a href="#非阻塞io模型" class="headerlink" title="非阻塞io模型"></a>非阻塞io模型</h2><p><img src="/2017/03/22/network-io-model/非阻塞io模型.png" alt="非阻塞io模型"></p>
<h2 id="io复用模型"><a href="#io复用模型" class="headerlink" title="io复用模型"></a>io复用模型</h2><p><img src="/2017/03/22/network-io-model/io复用模型.png" alt="io复用模型"></p>
<h2 id="信号驱动io模型"><a href="#信号驱动io模型" class="headerlink" title="信号驱动io模型"></a>信号驱动io模型</h2><p><img src="/2017/03/22/network-io-model/信号驱动io模型.png" alt="信号驱动io模型"></p>
<h2 id="异步io模型"><a href="#异步io模型" class="headerlink" title="异步io模型"></a>异步io模型</h2><p><img src="/2017/03/22/network-io-model/异步io.png" alt="异步io模型"></p>
<p>多啰嗦几句：<br>a. <strong>阻塞和非阻塞</strong>描述的对象是函数，指调用这个函数后是否会block进程/线程。<br>b. <strong>同步/异步</strong>描述的是执行IO操作的主体是谁，同步是由用户进程自己去执行最终的IO操作。异步是用户进程自己不关系实际IO操作的过程，只需要由内核在IO完成后通知它既可，由内核进程来执行最终的IO操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据发送过程]]></title>
      <url>http://hlei.io/2017/03/20/network-send-recv/</url>
      <content type="html"><![CDATA[<h2 id="tcp发送"><a href="#tcp发送" class="headerlink" title="tcp发送"></a>tcp发送</h2><p><img src="/2017/03/20/network-send-recv/tcp_send.png" alt="tcp发送过程"></p>
<ul>
<li>从写一个TCP套接字的write调用成功返回仅表示可以使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接受到数据</li>
<li>通过getsockopt得到默认的发送缓冲区的大小为16384B。</li>
<li>非阻塞的send时，发送缓冲区满后会阻塞；非阻塞的send时，会返回EAGAIN。</li>
</ul>
<h2 id="udp发送"><a href="#udp发送" class="headerlink" title="udp发送"></a>udp发送</h2><p><img src="/2017/03/20/network-send-recv/udp_send.png" alt="udp发送过程"></p>
<ul>
<li>udp是不可靠的，不会保存应用进程数据的一个副本，因此没有真正的发送缓冲区（数据被发送后，这个副本就被数据链路层丢弃）。udp的write调用成功返回表示所写的数据报或其所有片段已加入数据链路层的输出队列（如果空间不够，应用进程也不会知道）。</li>
<li>通过getsockopt得到默认的接收缓冲区的大小为87380B。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP状态机分析（一）]]></title>
      <url>http://hlei.io/2017/03/09/network/</url>
      <content type="html"><![CDATA[<h2 id="tcp状态机"><a href="#tcp状态机" class="headerlink" title="tcp状态机"></a>tcp状态机</h2><p><img src="/2017/03/09/network/tcp_state_machine.png" alt="tcp状态机"></p>
<h2 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h2><p>流程图<br><img src="/2017/03/09/network/tcp_connect.png" alt="三次握手流程图"></p>
<p>tcpdump抓包(listen port 1234)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i lo tcp port 1234 and host 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>客户端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(connect(sockfd,(struct sockaddr *)&amp;server,sizeof(server))==-1)&#123;</div><div class="line">       printf(&quot;connect()error\n&quot;);</div><div class="line">       exit(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if((connectfd = accept(listenfd,(struct sockaddr*)&amp;client,&amp;addrlen))==-1) &#123;</div><div class="line">       perror(&quot;accept()error\n&quot;);</div><div class="line">       exit(1);</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">       printf(&quot;Yougot a connection from cient&apos;s ip is %s, prot is %d\n&quot;,inet_ntoa(client.sin_addr),htons(client.sin_port));</div><div class="line">&#125;</div><div class="line">sleep(30);</div></pre></td></tr></table></figure></p>
<p>tcpdump抓包<br><img src="/2017/03/09/network/tcpdump_connect.png" alt="tcpdump三次握手"></p>
<p>netstat查看连接状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -apn |grep 1234</div></pre></td></tr></table></figure></p>
<p><img src="/2017/03/09/network/established.png" alt="established status"></p>
<h2 id="关闭连接过程"><a href="#关闭连接过程" class="headerlink" title="关闭连接过程"></a>关闭连接过程</h2><p>为验证CLOSE_WAIT状态，服务端accpet后sleep，客户单立即调用close</p>
<p>流程图<br><img src="/2017/03/09/network/network_close.png" alt="四次挥手流程图"></p>
<p>客户端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close(sockfd);</div></pre></td></tr></table></figure></p>
<p>服务端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sleep(30);</div></pre></td></tr></table></figure></p>
<p>tcpdump抓包<br><img src="/2017/03/09/network/tcpdump_close.png" alt="tcpdump四次挥手"></p>
<p>netstat查看连接状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -apn |grep 1234</div></pre></td></tr></table></figure></p>
<p><img src="/2017/03/09/network/close_wait.png" alt="established status"></p>
<p>服务端sleep时间到后，此时客户端已close，read返回0后，服务端也调用close，进入TIME_WAIT状态。</p>
<p>为什么需要TIME_WAIT?<br>a. 当发起关闭一方的最后一个ack丢失后，对方会重传FIN，如果直接关闭连接，发起发就收不到重传FIN。<br>b. 当被动关闭一方的最后一个FIN包超时重传，如果没有TIME_WAIT状态而且此时发起方用相同的ip和port建立了新的连接，这时候会收到这个重传的包，并认为他是新连接的包，就会导致严重错误。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nginx内存管理]]></title>
      <url>http://hlei.io/2017/02/26/nginx-mem-manage/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux-ipc]]></title>
      <url>http://hlei.io/2017/02/23/linux-ipc/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>linux中的两种共享内存。一种是我们的IPC通信System V版本的共享内存，另外的一种是存储映射I/O（mmap函数）</p>
<p>在说mmap之前我们先说一下普通的读写文件的原理，进程调用read或是write后会陷入内核，因为这两个函数都是系统调用，进入系统调用后，内核开始读写文件，假设内核在读取文件，内核首先把文件读入自己的内核空间，读完之后进程在内核回归用户态，内核把读入内核内存的数据再copy进入进程的用户态内存空间。实际上我们同一份文件内容相当于读了两次，先读入内核空间，再从内核空间读入用户空间。</p>
<p>Linux提供了内存映射函数mmap, 它把文件内容映射到一段内存上(准确说是虚拟内存上),通过对这段内存的读取和修改, 实现对文件的读取和修改,mmap()系统调用使得进程之间可以通过映射一个普通的文件实现共享内存。普通文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问，不需要其他系统调用(read,write)去操作。</p>
<h2 id="共享内存-System-V"><a href="#共享内存-System-V" class="headerlink" title="共享内存-System V"></a>共享内存-System V</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE   40000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_SIZE  100000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE  100000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_MODE  (SHM_R | SHM_W)</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> <span class="built_in">array</span>[ARRAY_SIZE];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> shmid;</div><div class="line">	<span class="keyword">char</span> *ptr, *shmptr;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"array[] from %x to %x \n"</span>, &amp;<span class="built_in">array</span>[<span class="number">0</span>], &amp;<span class="built_in">array</span>[ARRAY_SIZE]);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"stack around %x \n"</span>, &amp;shmid);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == (ptr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(MALLOC_SIZE)))</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"malloc error"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"malloced from %x to %x \n"</span>, ptr, ptr+MALLOC_SIZE);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, SHM_MODE)) &lt;<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"shmget error"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> ( (shmptr = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span> )</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"shmat error"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"shared memory attached from %x to %x \n"</span>,</div><div class="line">			shmptr, shmptr+SHM_SIZE);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="number">0</span>) &lt;<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"shmctl error"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内存布局<br><img src="/2017/03/23/linux-ipc/share_mem01.png" alt="程序内存布局"></p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>####a. /dev/zero####<br>设备/dev/zero在读时，是0字节的无限资源。此设备也接收写向它的任何数据，但忽略此<br>数据。我们对此设备作为IPC的兴趣在于，当对其进行存储映射时，它具有一些特殊性质：<br>• 创建一个未名存储区，其长度是mmap的第二个参数，将其取整为系统上的最近页长。<br>• 存储区都初始化为 0。<br>• 如果多个进程的共同祖先进程对mmap指定了MAP_SHARED标志，则这些进程可共享此存储区。</p>
<p>使用/dev/zero的优点是：在调用mmap创建映射区之前，无需存在一个实际文件。映射/dev/zero自动创建一个指定长度的映射区。<br>这种技术的缺点是：它只能由相关进程使用。如果在无关进程之间需要使用共享存储区，则必须使用shmXXX函数。</p>
<p>example<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> STU</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</div><div class="line">	<span class="keyword">char</span> sex;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOOP_TIMES = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">uint64_t</span>* p)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (*p)++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> <span class="comment">//这个进程用于创建映射区进行写。</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">struct</span> STU *p = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">uint64_t</span>* incre = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	fd = open(<span class="string">"/dev/zero"</span>, O_RDWR, <span class="number">0644</span>);</div><div class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"open"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	incre = (<span class="keyword">uint64_t</span>*)mmap(<span class="literal">NULL</span>, </div><div class="line">							  <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>),</div><div class="line">							  PROT_READ|PROT_WRITE,</div><div class="line">							  MAP_SHARED,</div><div class="line">							  fd,<span class="number">0</span></div><div class="line">							  );</div><div class="line">	<span class="keyword">if</span>(incre == MAP_FAILED)</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"mmap"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">3</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	close(fd); <span class="comment">//关闭不用的文件描述符</span></div><div class="line"></div><div class="line">	pid = fork();</div><div class="line">	<span class="keyword">if</span> (pid &lt;  <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"fork"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_TIMES; ++i)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent&gt;&gt;"</span></div><div class="line">				 &lt;&lt; <span class="string">" i="</span> &lt;&lt; i</div><div class="line">				 &lt;&lt; <span class="string">" ts="</span> &lt;&lt; time(<span class="literal">NULL</span>) </div><div class="line">				 &lt;&lt; <span class="string">" pid="</span> &lt;&lt; getpid() </div><div class="line">				 &lt;&lt; <span class="string">" incre="</span> &lt;&lt; update(incre)</div><div class="line">				 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">			<span class="comment">//sleep(1);</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_TIMES; ++i)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"child&gt;&gt;"</span></div><div class="line">				 &lt;&lt; <span class="string">" i="</span> &lt;&lt; i</div><div class="line">				 &lt;&lt; <span class="string">" ts="</span> &lt;&lt; time(<span class="literal">NULL</span>) </div><div class="line">				 &lt;&lt; <span class="string">" pid="</span> &lt;&lt; getpid() </div><div class="line">				 &lt;&lt; <span class="string">" incre="</span> &lt;&lt; update(incre)</div><div class="line">				 &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="comment">//sleep(1);</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####b.匿名存储映射<br>4.3+BSD提供了一种类似于/dev/zero的施设，称为匿名存储映射。为了使用这种功能，在调用mmap时指定MAP_ A NON标志，并将描述符指定为－1。</p>
<p>example<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> STU</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</div><div class="line">	<span class="keyword">char</span> sex;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOOP_TIMES = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">uint64_t</span>* p)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (*p)++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> <span class="comment">//这个进程用于创建映射区进行写。</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> STU *p = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">uint64_t</span>* incre = <span class="literal">NULL</span>;</div><div class="line">	</div><div class="line">	incre = (<span class="keyword">uint64_t</span>*)mmap(<span class="literal">NULL</span>, </div><div class="line">							  <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>),</div><div class="line">							  PROT_READ|PROT_WRITE,</div><div class="line">							  MAP_ANON|MAP_SHARED,</div><div class="line">							  <span class="number">-1</span>,<span class="number">0</span></div><div class="line">							  );</div><div class="line">	<span class="keyword">if</span>(incre == MAP_FAILED)</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"mmap"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">3</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	pid = fork();</div><div class="line">	<span class="keyword">if</span> (pid &lt;  <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"fork"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_TIMES; ++i)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent&gt;&gt;"</span></div><div class="line">				 &lt;&lt; <span class="string">" i="</span> &lt;&lt; i</div><div class="line">				 &lt;&lt; <span class="string">" ts="</span> &lt;&lt; time(<span class="literal">NULL</span>) </div><div class="line">				 &lt;&lt; <span class="string">" pid="</span> &lt;&lt; getpid() </div><div class="line">				 &lt;&lt; <span class="string">" incre="</span> &lt;&lt; update(incre)</div><div class="line">				 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">			<span class="comment">//sleep(1);</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_TIMES; ++i)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"child&gt;&gt;"</span></div><div class="line">				 &lt;&lt; <span class="string">" i="</span> &lt;&lt; i</div><div class="line">				 &lt;&lt; <span class="string">" ts="</span> &lt;&lt; time(<span class="literal">NULL</span>) </div><div class="line">				 &lt;&lt; <span class="string">" pid="</span> &lt;&lt; getpid() </div><div class="line">				 &lt;&lt; <span class="string">" incre="</span> &lt;&lt; update(incre)</div><div class="line">				 &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="comment">//sleep(1);</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[What is Hexo?]]></title>
      <url>http://hlei.io/2017/02/23/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="1-Hexo简介"><a href="#1-Hexo简介" class="headerlink" title="1. Hexo简介"></a>1. Hexo简介</h2><p>Hexo 是一款基于 Node.js 的静态博客框架。Hexo 使用 Markdown 解析文章，用户在本地安装Hexo并进行写作，通过一条命令，Hexo即可利用靓丽的主题自动生成静态网页。<br>参考：Hexo Github地址     Hexo帮助文档(<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">https://hexo.io/zh-cn/docs/</a>)</p>
<h2 id="2-如何使用Hexo搭建自己的博客"><a href="#2-如何使用Hexo搭建自己的博客" class="headerlink" title="2. 如何使用Hexo搭建自己的博客"></a>2. 如何使用Hexo搭建自己的博客</h2><h3 id="uninstall-old-version-of-nodejs-amp-npm"><a href="#uninstall-old-version-of-nodejs-amp-npm" class="headerlink" title="uninstall old version of nodejs &amp; npm"></a>uninstall old version of nodejs &amp; npm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get purge nodejs npm</div></pre></td></tr></table></figure>
<h3 id="update-gcc-g"><a href="#update-gcc-g" class="headerlink" title="update gcc g++"></a>update gcc g++</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/<span class="built_in">test</span></div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install gcc-4.9</div><div class="line">sudo apt-get install g++-4.9</div><div class="line"></div><div class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 100</div><div class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/g++-4.9 100</div></pre></td></tr></table></figure>
<h3 id="install-nodejs"><a href="#install-nodejs" class="headerlink" title="install nodejs"></a>install nodejs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ wget https://nodejs.org/dist/v6.9.5/node-v6.9.5.tar.gz</div><div class="line">$ tar xvf node-v6.9.5.tar.gz</div><div class="line">$ ./configure</div><div class="line">$ make </div><div class="line">$ make install</div></pre></td></tr></table></figure>
<h3 id="install-npm"><a href="#install-npm" class="headerlink" title="install npm"></a>install npm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install npm</div></pre></td></tr></table></figure>
<h3 id="check-res"><a href="#check-res" class="headerlink" title="check res"></a>check res</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node -v</div><div class="line">v6.9.5</div><div class="line"></div><div class="line">$ npm -v</div><div class="line">3.10.10</div></pre></td></tr></table></figure>
<h3 id="安装并初始化Hexo"><a href="#安装并初始化Hexo" class="headerlink" title="安装并初始化Hexo"></a>安装并初始化Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div><div class="line">$ hexo init</div></pre></td></tr></table></figure>
<p>安装完成后，指定文件夹的目录如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1 ├── _config.yml</div><div class="line">2 ├── package.json</div><div class="line">3 ├── scaffolds</div><div class="line">4 ├── <span class="built_in">source</span></div><div class="line">5 |   ├── _drafts</div><div class="line">6 |   └── _posts</div><div class="line">7 └── themes</div></pre></td></tr></table></figure></p>
<p>其中_config.yml文件用于存放网站的配置信息，你可以在此配置大部分的参数；scaffolds是存放模板的文件夹，当新建文章时，Hexo 会根据scaffold来建立文件；source是资源文件夹，用于存放用户资源，themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析和注释（一）---链表结构]]></title>
      <url>http://hlei.io/2017/02/22/redis-analysis/</url>
      <content type="html"><![CDATA[<h2 id="1-redis中的链表"><a href="#1-redis中的链表" class="headerlink" title="1. redis中的链表"></a>1. redis中的链表</h2><p>在redis中链表的应用非常广泛，例如列表键的底层实现之一就是链表。而且，在redis中的链表结构被实现成为双向链表，因此，在头部和尾部进行的操作就会非常快。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH <span class="built_in">list</span> a b c    <span class="comment">//依次在链表头部插入a、b、c</span></div><div class="line">(integer) <span class="number">3</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH <span class="built_in">list</span> d e f    <span class="comment">//依次在链表尾部插入d、e、f</span></div><div class="line">(integer) <span class="number">6</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE <span class="built_in">list</span> <span class="number">0</span> <span class="number">-1</span>    <span class="comment">//查看list的值</span></div><div class="line"><span class="number">1</span>) <span class="string">"c"</span></div><div class="line"><span class="number">2</span>) <span class="string">"b"</span></div><div class="line"><span class="number">3</span>) <span class="string">"a"</span></div><div class="line"><span class="number">4</span>) <span class="string">"d"</span></div><div class="line"><span class="number">5</span>) <span class="string">"e"</span></div><div class="line"><span class="number">6</span>) <span class="string">"f"</span></div></pre></td></tr></table></figure>
<h2 id="2-链表的实现"><a href="#2-链表的实现" class="headerlink" title="2. 链表的实现"></a>2. 链表的实现</h2><h3 id="2-1-链表节点的实现"><a href="#2-1-链表节点的实现" class="headerlink" title="2.1 链表节点的实现"></a>2.1 链表节点的实现</h3><p>每个链表节点由adlist.h/listNode来表示<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</div><div class="line">    <span class="keyword">struct</span> listNode *prev; <span class="comment">//前驱节点，如果是list的头结点，则prev指向NULL</span></div><div class="line">    <span class="keyword">struct</span> listNode *next;<span class="comment">//后继节点，如果是list尾部结点，则next指向NULL</span></div><div class="line">    <span class="keyword">void</span> *value;            <span class="comment">//万能指针，能够存放任何信息</span></div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure></p>
<p>listNode结构通过prev和next指针就组成了双向链表。刚才通过列表键生成的双向链表如下图：<br><img src="/2017/02/22/redis-analysis/redis-list01.jpg" alt="listNode"></p>
<p>使用双向链表的好处：<br>prev和next指针：获取某个节点的前驱节点和后继节点复杂度为O(1)。</p>
<h3 id="2-2-表头的实现"><a href="#2-2-表头的实现" class="headerlink" title="2.2 表头的实现"></a>2.2 表头的实现</h3><p>redis还提供了一个表头，用于存放上面双向链表的信息，它由adlist.h/list结构表示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</div><div class="line">    listNode *head;     <span class="comment">//链表头结点指针</span></div><div class="line">    listNode *tail;     <span class="comment">//链表尾结点指针</span></div><div class="line"></div><div class="line">    <span class="comment">//下面的三个函数指针就像类中的成员函数一样</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);    <span class="comment">//复制链表节点保存的值</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);    <span class="comment">//释放链表节点保存的值</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">//比较链表节点所保存的节点值和另一个输入的值是否相等</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;      <span class="comment">//链表长度计数器</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure></p>
<p>将表头和双向链表连接起来，如图：<br><img src="/2017/02/22/redis-analysis/redis-list02.jpg" alt="list"></p>
<p>利用list表头管理链表信息的好处：</p>
<ul>
<li>head和tail指针：对于链表的头结点和尾结点操作的复杂度为O(1)。</li>
<li>len 链表长度计数器：获取链表中节点数量的复杂度为O(1)。</li>
<li>dup、free和match指针：实现多态，链表节点listNode使用万能指针void *保存节点的值，而表头list使用dup、free和match指针来针对链表中存放的不同对象从而实现不同的方法。</li>
</ul>
<h2 id="3-链表结构源码剖析"><a href="#3-链表结构源码剖析" class="headerlink" title="3. 链表结构源码剖析"></a>3. 链表结构源码剖析</h2><h3 id="3-1-adlist-h文件"><a href="#3-1-adlist-h文件" class="headerlink" title="3.1 adlist.h文件"></a>3.1 adlist.h文件</h3><p>针对list结构和listNode结构的赋值和查询操作使用宏进行封装，而且一下操作的复杂度均为O(1)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)                    <span class="comment">//返回链表l节点数量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)                    <span class="comment">//返回链表l的头结点地址</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)                     <span class="comment">//返回链表l的尾结点地址</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)                 <span class="comment">//返回节点n的前驱节点地址</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)                 <span class="comment">//返回节点n的后继节点地址</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)               <span class="comment">//返回节点n的节点值</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))      <span class="comment">//设置链表l的复制函数为m方法</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))    <span class="comment">//设置链表l的释放函数为m方法</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))  <span class="comment">//设置链表l的比较函数为m方法</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)              <span class="comment">//返回链表l的赋值函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)                  <span class="comment">//返回链表l的释放函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)          <span class="comment">//返回链表l的比较函数</span></span></div><div class="line">``` </div><div class="line"></div><div class="line">链表操作的函数原型（Prototypes）：</div><div class="line">``` <span class="function">cpp</span></div><div class="line"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span>;                                 <span class="comment">//创建一个表头</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;                           <span class="comment">//释放list表头和链表</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;         <span class="comment">//将value添加到list链表的头部</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;         <span class="comment">//将value添加到list链表的尾部</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;<span class="comment">//在list中，根据after在old_node节点前后插入值为value的节点。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;           <span class="comment">//从list删除node节点</span></div><div class="line"></div><div class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;   <span class="comment">//为list创建一个迭代器iterator</span></div><div class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;                     <span class="comment">//返回迭代器iter指向的当前节点并更新iter       </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;               <span class="comment">//释放iter迭代器</span></div><div class="line"></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;                              <span class="comment">//拷贝表头为orig的链表并返回</span></div><div class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;         <span class="comment">//在list中查找value为key的节点并返回</span></div><div class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;            <span class="comment">//返回下标为index的节点地址</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;              <span class="comment">//将迭代器li重置为list的头结点并且设置为正向迭代</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;          <span class="comment">//将迭代器li重置为list的尾结点并且设置为反向迭代</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;                            <span class="comment">//将尾节点插到头结点</span></div></pre></td></tr></table></figure></p>
<h3 id="3-2-链表迭代器"><a href="#3-2-链表迭代器" class="headerlink" title="3.2 链表迭代器"></a>3.2 链表迭代器</h3><p>在adlist.h文件中，使用C语言实现了迭代器，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct listIter &#123;</div><div class="line">    listNode *next;     //迭代器当前指向的节点（名字叫next有点迷惑）</div><div class="line">    int direction;      //迭代方向，可以取以下两个值：AL_START_HEAD和AL_START_TAIL</div><div class="line">&#125; listIter</div><div class="line"></div><div class="line">#define AL_START_HEAD 0 //正向迭代：从表头向表尾进行迭代</div><div class="line">#define AL_START_TAIL 1 //反向迭代：从表尾到表头进行迭代</div></pre></td></tr></table></figure></p>
<p>在listDup函数中就使用了迭代器，listDup函数的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//listDup的功能是拷贝一份链表</div><div class="line">list *listDup(list *orig)</div><div class="line">&#123;</div><div class="line">    list *copy;</div><div class="line">    listIter *iter;</div><div class="line">    listNode *node;</div><div class="line"></div><div class="line">    if ((copy = listCreate()) == NULL)  //创建一个表头</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    //设置新建表头的处理函数</div><div class="line">    copy-&gt;dup = orig-&gt;dup;</div><div class="line">    copy-&gt;free = orig-&gt;free;</div><div class="line">    copy-&gt;match = orig-&gt;match;</div><div class="line"></div><div class="line">    //迭代整个orig的链表，重点关注此部分。</div><div class="line">    iter = listGetIterator(orig, AL_START_HEAD);//为orig定义一个迭代器并设置迭代方向，在c++中例如是  vector&lt;int&gt;::interator it;</div><div class="line">    while((node = listNext(iter)) != NULL) &#123;    //迭代器根据迭代方向不停迭代，相当于++it</div><div class="line">        void *value;</div><div class="line"></div><div class="line">        //复制节点值到新节点</div><div class="line">        if (copy-&gt;dup) &#123;    //如果定义了list结构中的dup指针，则使用该方法拷贝节点值。</div><div class="line">            value = copy-&gt;dup(node-&gt;value);</div><div class="line">            if (value == NULL) &#123;</div><div class="line">                listRelease(copy);</div><div class="line">                listReleaseIterator(iter);</div><div class="line">                return NULL;</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            value = node-&gt;value;    //获得当前node的value值</div><div class="line"></div><div class="line">        if (listAddNodeTail(copy, value) == NULL) &#123; //将node节点尾插到copy表头的链表中</div><div class="line">            listRelease(copy);</div><div class="line">            listReleaseIterator(iter);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    listReleaseIterator(iter);    //自行释放迭代器</div><div class="line">    return copy;    //返回拷贝副本</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>迭代器的好处：</p>
<ul>
<li>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</li>
<li>将指针操作进行了统一封装，代码可读性增强。</li>
</ul>
<p>###3.3 adlist.c文件<br>刚才所有函数的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div></pre></td><td class="code"><pre><div class="line">list *listCreate(void)  //创建一个表头</div><div class="line">&#123;</div><div class="line">    struct list *list;</div><div class="line"></div><div class="line">    //为表头分配内存</div><div class="line">    if ((list = zmalloc(sizeof(*list))) == NULL)</div><div class="line">        return NULL;</div><div class="line">    //初始化表头</div><div class="line">    list-&gt;head = list-&gt;tail = NULL;</div><div class="line">    list-&gt;len = 0;</div><div class="line">    list-&gt;dup = NULL;</div><div class="line">    list-&gt;free = NULL;</div><div class="line">    list-&gt;match = NULL;</div><div class="line"></div><div class="line">    return list;    //返回表头</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Free the whole list.</div><div class="line"> *</div><div class="line"> * This function can&apos;t fail. */</div><div class="line">void listRelease(list *list)    //释放list表头和链表</div><div class="line">&#123;</div><div class="line">    unsigned long len;</div><div class="line">    listNode *current, *next;</div><div class="line"></div><div class="line">    current = list-&gt;head;   //备份头节点地址</div><div class="line">    len = list-&gt;len;        //备份链表元素个数，使用备份操作防止更改原有信息</div><div class="line">    while(len--) &#123;          //遍历链表</div><div class="line">        next = current-&gt;next;</div><div class="line">        if (list-&gt;free) list-&gt;free(current-&gt;value); //如果设置了list结构的释放函数，则调用该函数释放节点值</div><div class="line">        zfree(current);</div><div class="line">        current = next;</div><div class="line">    &#125;</div><div class="line">    zfree(list);    //最后释放表头</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Add a new node to the list, to head, containing the specified &apos;value&apos;</div><div class="line"> * pointer as value.</div><div class="line"> *</div><div class="line"> * On error, NULL is returned and no operation is performed (i.e. the</div><div class="line"> * list remains unaltered).</div><div class="line"> * On success the &apos;list&apos; pointer you pass to the function is returned. */</div><div class="line">list *listAddNodeHead(list *list, void *value)  //将value添加到list链表的头部</div><div class="line">&#123;</div><div class="line">    listNode *node;</div><div class="line"></div><div class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)    //为新节点分配空间</div><div class="line">        return NULL;</div><div class="line">    node-&gt;value = value;    //设置node的value值</div><div class="line"></div><div class="line">    if (list-&gt;len == 0) &#123;   //将node头插到空链表</div><div class="line">        list-&gt;head = list-&gt;tail = node;</div><div class="line">        node-&gt;prev = node-&gt;next = NULL;</div><div class="line">    &#125; else &#123;                //将node头插到非空链表</div><div class="line">        node-&gt;prev = NULL;</div><div class="line">        node-&gt;next = list-&gt;head;</div><div class="line">        list-&gt;head-&gt;prev = node;</div><div class="line">        list-&gt;head = node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    list-&gt;len++;    //链表元素计数器加1</div><div class="line"></div><div class="line">    return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Add a new node to the list, to tail, containing the specified &apos;value&apos;</div><div class="line"> * pointer as value.</div><div class="line"> *</div><div class="line"> * On error, NULL is returned and no operation is performed (i.e. the</div><div class="line"> * list remains unaltered).</div><div class="line"> * On success the &apos;list&apos; pointer you pass to the function is returned. */</div><div class="line">list *listAddNodeTail(list *list, void *value)  //将value添加到list链表的尾部</div><div class="line">&#123;</div><div class="line">    listNode *node;</div><div class="line"></div><div class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)    //为新节点分配空间</div><div class="line">        return NULL;</div><div class="line">    node-&gt;value = value;    //设置node的value值</div><div class="line">    if (list-&gt;len == 0) &#123;   //将node尾插到空链表</div><div class="line">        list-&gt;head = list-&gt;tail = node;</div><div class="line">        node-&gt;prev = node-&gt;next = NULL;</div><div class="line">    &#125; else &#123;                //将node头插到非空链表</div><div class="line">        node-&gt;prev = list-&gt;tail;</div><div class="line">        node-&gt;next = NULL;</div><div class="line">        list-&gt;tail-&gt;next = node;</div><div class="line">        list-&gt;tail = node;</div><div class="line">    &#125;</div><div class="line">    list-&gt;len++;    //更新链表节点计数器</div><div class="line"></div><div class="line">    return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">list *listInsertNode(list *list, listNode *old_node, void *value, int after)    //在list中，根据after在old_node节点前后插入值为value的节点。</div><div class="line">&#123;</div><div class="line">    listNode *node;</div><div class="line"></div><div class="line">    if ((node = zmalloc(sizeof(*node))) == NULL) //为新节点分配空间</div><div class="line">        return NULL;</div><div class="line">    node-&gt;value = value;    //设置node的value值</div><div class="line"></div><div class="line">    if (after) &#123;    //after 非零，则将节点插入到old_node的后面</div><div class="line">        node-&gt;prev = old_node;</div><div class="line">        node-&gt;next = old_node-&gt;next;</div><div class="line">        if (list-&gt;tail == old_node) &#123;   //目标节点如果是链表的尾节点，更新list的tail指针</div><div class="line">            list-&gt;tail = node;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;        //after 为零，则将节点插入到old_node的前面</div><div class="line">        node-&gt;next = old_node;</div><div class="line">        node-&gt;prev = old_node-&gt;prev;</div><div class="line">        if (list-&gt;head == old_node) &#123;   //如果节点如果是链表的头节点，更新list的head指针</div><div class="line">            list-&gt;head = node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (node-&gt;prev != NULL) &#123;   //如果有，则更新node的前驱节点的指针</div><div class="line">        node-&gt;prev-&gt;next = node;</div><div class="line">    &#125;</div><div class="line">    if (node-&gt;next != NULL) &#123;   //如果有，则更新node的后继节点的指针</div><div class="line">        node-&gt;next-&gt;prev = node;</div><div class="line">    &#125;</div><div class="line">    list-&gt;len++;    //更新链表节点计数器</div><div class="line">    return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Remove the specified node from the specified list.</div><div class="line"> * It&apos;s up to the caller to free the private value of the node.</div><div class="line"> *</div><div class="line"> * This function can&apos;t fail. */</div><div class="line">void listDelNode(list *list, listNode *node)    //从list删除node节点</div><div class="line">&#123;</div><div class="line">    if (node-&gt;prev) //更新node的前驱节点的指针</div><div class="line">        node-&gt;prev-&gt;next = node-&gt;next;</div><div class="line">    else</div><div class="line">        list-&gt;head = node-&gt;next;</div><div class="line">    if (node-&gt;next) //更新node的后继节点的指针</div><div class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</div><div class="line">    else</div><div class="line">        list-&gt;tail = node-&gt;prev;</div><div class="line"></div><div class="line">    if (list-&gt;free) list-&gt;free(node-&gt;value);    //如果设置了list结构的释放函数，则调用该函数释放节点值</div><div class="line">    zfree(node);    //释放节点</div><div class="line">    list-&gt;len--;    //更新链表节点计数器</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Returns a list iterator &apos;iter&apos;. After the initialization every</div><div class="line"> * call to listNext() will return the next element of the list.</div><div class="line"> *</div><div class="line"> * This function can&apos;t fail. */</div><div class="line">listIter *listGetIterator(list *list, int direction)    //为list创建一个迭代器iterator</div><div class="line">&#123;</div><div class="line">    listIter *iter;</div><div class="line"></div><div class="line">    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;   //为迭代器申请空间</div><div class="line">    if (direction == AL_START_HEAD)     //设置迭代指针的起始位置</div><div class="line">        iter-&gt;next = list-&gt;head;</div><div class="line">    else</div><div class="line">        iter-&gt;next = list-&gt;tail;</div><div class="line">    iter-&gt;direction = direction;        //设置迭代方向</div><div class="line">    return iter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Release the iterator memory */</div><div class="line">void listReleaseIterator(listIter *iter) &#123;  //释放iter迭代器</div><div class="line">    zfree(iter);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Create an iterator in the list private iterator structure */</div><div class="line">void listRewind(list *list, listIter *li) &#123; //将迭代器li重置为list的头结点并且设置为正向迭代</div><div class="line">    li-&gt;next = list-&gt;head;              //设置迭代指针的起始位置</div><div class="line">    li-&gt;direction = AL_START_HEAD;      //设置迭代方向从头到尾</div><div class="line">&#125;</div><div class="line"></div><div class="line">void listRewindTail(list *list, listIter *li) &#123; //将迭代器li重置为list的尾结点并且设置为反向迭代</div><div class="line">    li-&gt;next = list-&gt;tail;              //设置迭代指针的起始位置</div><div class="line">    li-&gt;direction = AL_START_TAIL;      //设置迭代方向从尾到头</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return the next element of an iterator.</div><div class="line"> * It&apos;s valid to remove the currently returned element using</div><div class="line"> * listDelNode(), but not to remove other elements.</div><div class="line"> *</div><div class="line"> * The function returns a pointer to the next element of the list,</div><div class="line"> * or NULL if there are no more elements, so the classical usage patter</div><div class="line"> * is:</div><div class="line"> *</div><div class="line"> * iter = listGetIterator(list,&lt;direction&gt;);</div><div class="line"> * while ((node = listNext(iter)) != NULL) &#123;</div><div class="line"> *     doSomethingWith(listNodeValue(node));</div><div class="line"> * &#125;</div><div class="line"> *</div><div class="line"> * */</div><div class="line">listNode *listNext(listIter *iter)  //返回迭代器iter指向的当前节点并更新iter</div><div class="line">&#123;</div><div class="line">    listNode *current = iter-&gt;next; //备份当前迭代器指向的节点</div><div class="line"></div><div class="line">    if (current != NULL) &#123;</div><div class="line">        if (iter-&gt;direction == AL_START_HEAD)   //根据迭代方向更新迭代指针</div><div class="line">            iter-&gt;next = current-&gt;next;</div><div class="line">        else</div><div class="line">            iter-&gt;next = current-&gt;prev;</div><div class="line">    &#125;</div><div class="line">    return current;     //返回备份的当前节点地址</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Duplicate the whole list. On out of memory NULL is returned.</div><div class="line"> * On success a copy of the original list is returned.</div><div class="line"> *</div><div class="line"> * The &apos;Dup&apos; method set with listSetDupMethod() function is used</div><div class="line"> * to copy the node value. Otherwise the same pointer value of</div><div class="line"> * the original node is used as value of the copied node.</div><div class="line"> *</div><div class="line"> * The original list both on success or error is never modified. */</div><div class="line">list *listDup(list *orig)   //拷贝表头为orig的链表并返回</div><div class="line">&#123;</div><div class="line">    list *copy;</div><div class="line">    listIter *iter;</div><div class="line">    listNode *node;</div><div class="line"></div><div class="line">    if ((copy = listCreate()) == NULL)  //创建一个表头</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    //设置新建表头的处理函数</div><div class="line">    copy-&gt;dup = orig-&gt;dup;</div><div class="line">    copy-&gt;free = orig-&gt;free;</div><div class="line">    copy-&gt;match = orig-&gt;match;</div><div class="line">    //迭代整个orig的链表</div><div class="line">    iter = listGetIterator(orig, AL_START_HEAD);    //为orig定义一个迭代器并设置迭代方向</div><div class="line">    while((node = listNext(iter)) != NULL) &#123;    //迭代器根据迭代方向不停迭代</div><div class="line">        void *value;</div><div class="line"></div><div class="line">        //复制节点值到新节点</div><div class="line">        if (copy-&gt;dup) &#123;</div><div class="line">            value = copy-&gt;dup(node-&gt;value); //如果定义了list结构中的dup指针，则使用该方法拷贝节点值。</div><div class="line">            if (value == NULL) &#123;</div><div class="line">                listRelease(copy);</div><div class="line">                listReleaseIterator(iter);</div><div class="line">                return NULL;</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            value = node-&gt;value;    //获得当前node的value值</div><div class="line"></div><div class="line">        if (listAddNodeTail(copy, value) == NULL) &#123; //将node节点尾插到copy表头的链表中</div><div class="line">            listRelease(copy);</div><div class="line">            listReleaseIterator(iter);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    listReleaseIterator(iter);  //自行释放迭代器</div><div class="line">    return copy;    //返回拷贝副本</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Search the list for a node matching a given key.</div><div class="line"> * The match is performed using the &apos;match&apos; method</div><div class="line"> * set with listSetMatchMethod(). If no &apos;match&apos; method</div><div class="line"> * is set, the &apos;value&apos; pointer of every node is directly</div><div class="line"> * compared with the &apos;key&apos; pointer.</div><div class="line"> *</div><div class="line"> * On success the first matching node pointer is returned</div><div class="line"> * (search starts from head). If no matching node exists</div><div class="line"> * NULL is returned. */</div><div class="line">listNode *listSearchKey(list *list, void *key)  //在list中查找value为key的节点并返回</div><div class="line">&#123;</div><div class="line">    listIter *iter;</div><div class="line">    listNode *node;</div><div class="line"></div><div class="line">    iter = listGetIterator(list, AL_START_HEAD);    //创建迭代器</div><div class="line">    while((node = listNext(iter)) != NULL) &#123;        //迭代整个链表</div><div class="line">        if (list-&gt;match) &#123;                          //如果设置list结构中的match方法，则用该方法比较</div><div class="line">            if (list-&gt;match(node-&gt;value, key)) &#123;</div><div class="line">                listReleaseIterator(iter);          //如果找到，释放迭代器返回node地址</div><div class="line">                return node;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (key == node-&gt;value) &#123;</div><div class="line">                listReleaseIterator(iter);</div><div class="line">                return node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    listReleaseIterator(iter);      //释放迭代器</div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Return the element at the specified zero-based index</div><div class="line"> * where 0 is the head, 1 is the element next to head</div><div class="line"> * and so on. Negative integers are used in order to count</div><div class="line"> * from the tail, -1 is the last element, -2 the penultimate</div><div class="line"> * and so on. If the index is out of range NULL is returned. */</div><div class="line">listNode *listIndex(list *list, long index) &#123;   //返回下标为index的节点地址</div><div class="line">    listNode *n;</div><div class="line"></div><div class="line">    if (index &lt; 0) &#123;</div><div class="line">        index = (-index)-1;         //如果下标为负数，从链表尾部开始</div><div class="line">        n = list-&gt;tail;</div><div class="line">        while(index-- &amp;&amp; n) n = n-&gt;prev;</div><div class="line">    &#125; else &#123;</div><div class="line">        n = list-&gt;head;             //如果下标为正数，从链表头部开始</div><div class="line">        while(index-- &amp;&amp; n) n = n-&gt;next;</div><div class="line">    &#125;</div><div class="line">    return n;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Rotate the list removing the tail node and inserting it to the head. */</div><div class="line">void listRotate(list *list) &#123;       //将尾节点插到头结点</div><div class="line">    listNode *tail = list-&gt;tail;</div><div class="line"></div><div class="line">    if (listLength(list) &lt;= 1) return;  //只有一个节点或空链表直接返回</div><div class="line"></div><div class="line">    /* Detach current tail */</div><div class="line">    list-&gt;tail = tail-&gt;prev;        //取出尾节点，更新list的tail指针</div><div class="line">    list-&gt;tail-&gt;next = NULL;</div><div class="line">    /* Move it as head */</div><div class="line">    list-&gt;head-&gt;prev = tail;        //将节点插到表头，更新list的head指针</div><div class="line">    tail-&gt;prev = NULL;</div><div class="line">    tail-&gt;next = list-&gt;head;</div><div class="line">    list-&gt;head = tail;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Summary 1：Quartz定时任务为什么会被阻塞]]></title>
      <url>http://hlei.io/2017/02/22/spring-task/</url>
      <content type="html"><![CDATA[<ol>
<li><p>写了两个job</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTask1</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AuthCheckTask.class);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">void</span>  <span class="title">execute</span><span class="params">()</span></span>&#123;</div><div class="line">        logger.info(<span class="string">"execute TestTask1("</span> + <span class="keyword">new</span> Date()+ <span class="string">") begin number=&#123;&#125;"</span>, number.get());</div><div class="line">        <span class="keyword">try</span>  &#123;</div><div class="line">            Thread.sleep(<span class="number">1000000</span>);</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ire) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"execute TestTask1("</span> + <span class="keyword">new</span> Date()+ <span class="string">") end number=&#123;&#125;"</span>, number.get());</div><div class="line">        number.incrementAndGet();</div><div class="line">        <span class="comment">//++count;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTask2</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AuthCheckTask.class);</div><div class="line">    <span class="keyword">private</span> AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> nCount = <span class="number">5</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">void</span>  <span class="title">execute</span><span class="params">()</span></span>&#123;</div><div class="line">        logger.info(<span class="string">"execute TestTask2("</span> + <span class="keyword">new</span> Date()+ <span class="string">") begin number=&#123;&#125;"</span>, number.get());</div><div class="line">        <span class="keyword">try</span>  &#123;</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ire) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"execute TestTask2("</span> + <span class="keyword">new</span> Date()+ <span class="string">") end number=&#123;&#125;"</span>, number.get());</div><div class="line">        number.incrementAndGet();</div><div class="line">        <span class="comment">//++count;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>任务并发执行时的配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="startQuertz" lazy-init="false" autowire="no" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;</div><div class="line">    &lt;property name="triggers"&gt;</div><div class="line">        &lt;list&gt;</div><div class="line">            &lt;ref bean="testTask1Job" /&gt;</div><div class="line">            &lt;ref bean="testTask2Job" /&gt;</div><div class="line">        &lt;/list&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;bean id="testTask1Task" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;</div><div class="line">    &lt;!-- 调用的类 --&gt;</div><div class="line">    &lt;property name="targetObject"&gt;</div><div class="line">        &lt;ref bean="testTask1" /&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!-- 调用类中的方法 --&gt;</div><div class="line">    &lt;property name="targetMethod"&gt;</div><div class="line">        &lt;value&gt;execute&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property name="concurrent" value = "false"/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;!-- vip 订阅统计job定时 --&gt;</div><div class="line">&lt;bean id="testTask1Job" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;</div><div class="line">    &lt;property name="jobDetail"&gt;</div><div class="line">        &lt;ref bean="testTask1Task" /&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!-- cron表达式 --&gt;</div><div class="line">    &lt;property name="cronExpression"&gt;</div><div class="line">        &lt;value&gt;0/5 * * * * ?&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id="testTask2Task" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;</div><div class="line">    &lt;!-- 调用的类 --&gt;</div><div class="line">    &lt;property name="targetObject"&gt;</div><div class="line">        &lt;ref bean="testTask2" /&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!-- 调用类中的方法 --&gt;</div><div class="line">    &lt;property name="targetMethod"&gt;</div><div class="line">        &lt;value&gt;execute&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;!-- vip 订阅统计job定时 --&gt;</div><div class="line">&lt;bean id="testTask2Job" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;</div><div class="line">    &lt;property name="jobDetail"&gt;</div><div class="line">        &lt;ref bean="testTask2Task" /&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!-- cron表达式 --&gt;</div><div class="line">    &lt;property name="cronExpression"&gt;</div><div class="line">        &lt;value&gt;0/5 * * * * ?&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>任务并发执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">50.001</span> startQuertz_Worker-<span class="number">3</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">50.002</span> startQuertz_Worker-<span class="number">3</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">50</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">55.000</span> startQuertz_Worker-<span class="number">4</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">55.006</span> startQuertz_Worker-<span class="number">4</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">55</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">57.462</span> main-SendThread(zc-jm-zookeeper04.bj:<span class="number">2181</span>)] org.apache.zookeeper.ClientCnxn$SendThread.readResponse(ClientCnxn.java:<span class="number">714</span>) (Got ping response <span class="keyword">for</span> sessionid: <span class="number">0x25939635b71730c</span> after <span class="number">1</span>ms)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">00.000</span> startQuertz_Worker-<span class="number">5</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">00.005</span> startQuertz_Worker-<span class="number">5</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">00</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">05.000</span> startQuertz_Worker-<span class="number">6</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">05.001</span> startQuertz_Worker-<span class="number">6</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">05</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">07.462</span> main-SendThread(zc-jm-zookeeper04.bj:<span class="number">2181</span>)] org.apache.zookeeper.ClientCnxn$SendThread.readResponse(ClientCnxn.java:<span class="number">714</span>) (Got ping response <span class="keyword">for</span> sessionid: <span class="number">0x25939635b71730c</span> after <span class="number">0</span>ms)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">10.001</span> startQuertz_Worker-<span class="number">7</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">10.004</span> startQuertz_Worker-<span class="number">7</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">10</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">15.000</span> startQuertz_Worker-<span class="number">8</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">15.001</span> startQuertz_Worker-<span class="number">8</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">15</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">17.463</span> main-SendThread(zc-jm-zookeeper04.bj:<span class="number">2181</span>)] org.apache.zookeeper.ClientCnxn$SendThread.readResponse(ClientCnxn.java:<span class="number">714</span>) (Got ping response <span class="keyword">for</span> sessionid: <span class="number">0x25939635b71730c</span> after <span class="number">0</span>ms)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">20.000</span> startQuertz_Worker-<span class="number">9</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">20.001</span> startQuertz_Worker-<span class="number">9</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">20</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">25.001</span> startQuertz_Worker-<span class="number">10</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">25.002</span> startQuertz_Worker-<span class="number">10</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">25</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>task1修改为同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"concurrent"</span> value = <span class="string">"false"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>task1修改为同步执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[INFO] Started Jetty Server</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">25.000</span> startQuertz_Worker-<span class="number">3</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask1Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">25.001</span> startQuertz_Worker-<span class="number">3</span>] com.huyu.zhibo.task.TestTask1.execute(TestTask1.java:<span class="number">20</span>) (<span class="function">execute <span class="title">TestTask1</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">25</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">25.001</span> startQuertz_Worker-<span class="number">4</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">25.002</span> startQuertz_Worker-<span class="number">4</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">25</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">30.001</span> startQuertz_Worker-<span class="number">5</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask1Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">30.002</span> startQuertz_Worker-<span class="number">5</span>] com.huyu.zhibo.task.TestTask1.execute(TestTask1.java:<span class="number">20</span>) (<span class="function">execute <span class="title">TestTask1</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">30</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">30.002</span> startQuertz_Worker-<span class="number">6</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">30.002</span> startQuertz_Worker-<span class="number">6</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">30</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">31.196</span> main-SendThread(sq-jm-stag03.bj:<span class="number">2181</span>)] org.apache.zookeeper.ClientCnxn$SendThread.readResponse(ClientCnxn.java:<span class="number">714</span>) (Got ping response <span class="keyword">for</span> sessionid: <span class="number">0x559396358edd1cb</span> after <span class="number">0</span>ms)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">35.000</span> startQuertz_Worker-<span class="number">7</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask1Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">35.002</span> startQuertz_Worker-<span class="number">7</span>] com.huyu.zhibo.task.TestTask1.execute(TestTask1.java:<span class="number">20</span>) (<span class="function">execute <span class="title">TestTask1</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">35</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">35.002</span> startQuertz_Worker-<span class="number">8</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">35.002</span> startQuertz_Worker-<span class="number">8</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">35</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">40.000</span> startQuertz_Worker-<span class="number">9</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask1Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">40.001</span> startQuertz_Worker-<span class="number">9</span>] com.huyu.zhibo.task.TestTask1.execute(TestTask1.java:<span class="number">20</span>) (<span class="function">execute <span class="title">TestTask1</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">40</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div><div class="line">[DEBUG <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">40.001</span> startQuertz_Worker-<span class="number">10</span>] org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">201</span>) (Calling execute on job DEFAULT.testTask2Task)</div><div class="line">[INFO  <span class="number">2017</span>-<span class="number">02</span>-<span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">40.002</span> startQuertz_Worker-<span class="number">10</span>] com.huyu.zhibo.task.TestTask2.execute(TestTask2.java:<span class="number">22</span>) (<span class="function">execute <span class="title">TestTask2</span><span class="params">(Thu Feb <span class="number">23</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">40</span> CST <span class="number">2017</span>)</span> begin number</span>=<span class="number">0</span>)</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[H]]></title>
      <url>http://hlei.io/2017/02/09/first/</url>
      <content type="html"></content>
    </entry>
    
  
  
</search>
